/**
 * @fileoverview added by tsickle
 * Generated from: lib/cell-tooltip.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NgModule, Optional, SkipSelf } from '@angular/core';
import { CommonModule } from '@angular/common';
import { OverlayModule } from '@angular/cdk/overlay';
import { MatTooltipModule } from '@angular/material/tooltip';
import { PblNgridModule, PblNgridPluginController, PblNgridConfigService } from '@pebula/ngrid';
import { PblNgridTargetEventsModule } from '@pebula/ngrid/target-events';
import { PblNgridCellTooltipDirective } from './cell-tooltip.directive';
var PblNgridCellTooltipModule = /** @class */ (function () {
    function PblNgridCellTooltipModule(parentModule, configService) {
        if (parentModule) {
            return;
        }
        PblNgridPluginController.created
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // Do not remove the explicit reference to `PblNgridCellTooltipDirective`
            // We use `PblNgridCellTooltipDirective.PLUGIN_KEY` to create a direct reference to `PblNgridCellTooltipDirective`
            // which will disable dead code elimination for the `PblNgridCellTooltipDirective` plugin.
            // If it is not set, using the plugin will only work when it is used in templates, other wise, if used programmatically (`autoSetAll`)
            // CLI prod builds will remove the plugin's code.
            /** @type {?} */
            var cellTooltipConfig = configService.get(PblNgridCellTooltipDirective.PLUGIN_KEY);
            if (cellTooltipConfig && cellTooltipConfig.autoSetAll === true) {
                /** @type {?} */
                var pluginCtrl_1 = event.controller;
                /** @type {?} */
                var subscription_1 = pluginCtrl_1.events
                    .subscribe((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    if (evt.kind === 'onInit') {
                        if (!pluginCtrl_1.hasPlugin(PblNgridCellTooltipDirective.PLUGIN_KEY)) {
                            pluginCtrl_1.createPlugin(PblNgridCellTooltipDirective.PLUGIN_KEY);
                        }
                        subscription_1.unsubscribe();
                        subscription_1 = undefined;
                    }
                }));
            }
        }));
    }
    PblNgridCellTooltipModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, MatTooltipModule, OverlayModule, PblNgridModule, PblNgridTargetEventsModule],
                    declarations: [PblNgridCellTooltipDirective],
                    exports: [PblNgridCellTooltipDirective, MatTooltipModule],
                },] }
    ];
    /** @nocollapse */
    PblNgridCellTooltipModule.ctorParameters = function () { return [
        { type: PblNgridCellTooltipModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: PblNgridConfigService }
    ]; };
    return PblNgridCellTooltipModule;
}());
export { PblNgridCellTooltipModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC10b29sdGlwLm1vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BwZWJ1bGEvbmdyaWQtbWF0ZXJpYWwvY2VsbC10b29sdGlwLyIsInNvdXJjZXMiOlsibGliL2NlbGwtdG9vbHRpcC5tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUU3RCxPQUFPLEVBQUUsY0FBYyxFQUFFLHdCQUF3QixFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hHLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRXpFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXhFO0lBTUUsbUNBQW9DLFlBQXVDLEVBQy9ELGFBQW9DO1FBQzlDLElBQUksWUFBWSxFQUFFO1lBQ2hCLE9BQU87U0FDUjtRQUVELHdCQUF3QixDQUFDLE9BQU87YUFDN0IsU0FBUzs7OztRQUFFLFVBQUEsS0FBSzs7Ozs7OztnQkFNVCxpQkFBaUIsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLDRCQUE0QixDQUFDLFVBQVUsQ0FBQztZQUNwRixJQUFJLGlCQUFpQixJQUFJLGlCQUFpQixDQUFDLFVBQVUsS0FBSyxJQUFJLEVBQUU7O29CQUN4RCxZQUFVLEdBQUcsS0FBSyxDQUFDLFVBQVU7O29CQUMvQixjQUFZLEdBQUcsWUFBVSxDQUFDLE1BQU07cUJBQ2pDLFNBQVM7Ozs7Z0JBQUUsVUFBQSxHQUFHO29CQUNiLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7d0JBQ3pCLElBQUksQ0FBQyxZQUFVLENBQUMsU0FBUyxDQUFDLDRCQUE0QixDQUFDLFVBQVUsQ0FBQyxFQUFFOzRCQUNsRSxZQUFVLENBQUMsWUFBWSxDQUFDLDRCQUE0QixDQUFDLFVBQVUsQ0FBQyxDQUFDO3lCQUNsRTt3QkFDRCxjQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7d0JBQzNCLGNBQVksR0FBRyxTQUFTLENBQUM7cUJBQzFCO2dCQUNILENBQUMsRUFBQzthQUNMO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDOztnQkFsQ0YsUUFBUSxTQUFDO29CQUNSLE9BQU8sRUFBRSxDQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLDBCQUEwQixDQUFFO29CQUN0RyxZQUFZLEVBQUUsQ0FBRSw0QkFBNEIsQ0FBRTtvQkFDOUMsT0FBTyxFQUFFLENBQUUsNEJBQTRCLEVBQUUsZ0JBQWdCLENBQUU7aUJBQzVEOzs7O2dCQUVtRCx5QkFBeUIsdUJBQTlELFFBQVEsWUFBSSxRQUFRO2dCQVhnQixxQkFBcUI7O0lBd0N4RSxnQ0FBQztDQUFBLEFBbkNELElBbUNDO1NBOUJZLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlLCBPcHRpb25hbCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgTWF0VG9vbHRpcE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3Rvb2x0aXAnO1xuXG5pbXBvcnQgeyBQYmxOZ3JpZE1vZHVsZSwgUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyLCBQYmxOZ3JpZENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAcGVidWxhL25ncmlkJztcbmltcG9ydCB7IFBibE5ncmlkVGFyZ2V0RXZlbnRzTW9kdWxlIH0gZnJvbSAnQHBlYnVsYS9uZ3JpZC90YXJnZXQtZXZlbnRzJztcblxuaW1wb3J0IHsgUGJsTmdyaWRDZWxsVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJy4vY2VsbC10b29sdGlwLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFsgQ29tbW9uTW9kdWxlLCBNYXRUb29sdGlwTW9kdWxlLCBPdmVybGF5TW9kdWxlLCBQYmxOZ3JpZE1vZHVsZSwgUGJsTmdyaWRUYXJnZXRFdmVudHNNb2R1bGUgXSxcbiAgZGVjbGFyYXRpb25zOiBbIFBibE5ncmlkQ2VsbFRvb2x0aXBEaXJlY3RpdmUgXSxcbiAgZXhwb3J0czogWyBQYmxOZ3JpZENlbGxUb29sdGlwRGlyZWN0aXZlLCBNYXRUb29sdGlwTW9kdWxlIF0sXG59KVxuZXhwb3J0IGNsYXNzIFBibE5ncmlkQ2VsbFRvb2x0aXBNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwYXJlbnRNb2R1bGU6IFBibE5ncmlkQ2VsbFRvb2x0aXBNb2R1bGUsXG4gICAgICAgICAgICAgIGNvbmZpZ1NlcnZpY2U6IFBibE5ncmlkQ29uZmlnU2VydmljZSkge1xuICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXIuY3JlYXRlZFxuICAgICAgLnN1YnNjcmliZSggZXZlbnQgPT4ge1xuICAgICAgICAvLyBEbyBub3QgcmVtb3ZlIHRoZSBleHBsaWNpdCByZWZlcmVuY2UgdG8gYFBibE5ncmlkQ2VsbFRvb2x0aXBEaXJlY3RpdmVgXG4gICAgICAgIC8vIFdlIHVzZSBgUGJsTmdyaWRDZWxsVG9vbHRpcERpcmVjdGl2ZS5QTFVHSU5fS0VZYCB0byBjcmVhdGUgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIGBQYmxOZ3JpZENlbGxUb29sdGlwRGlyZWN0aXZlYFxuICAgICAgICAvLyB3aGljaCB3aWxsIGRpc2FibGUgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGZvciB0aGUgYFBibE5ncmlkQ2VsbFRvb2x0aXBEaXJlY3RpdmVgIHBsdWdpbi5cbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IHNldCwgdXNpbmcgdGhlIHBsdWdpbiB3aWxsIG9ubHkgd29yayB3aGVuIGl0IGlzIHVzZWQgaW4gdGVtcGxhdGVzLCBvdGhlciB3aXNlLCBpZiB1c2VkIHByb2dyYW1tYXRpY2FsbHkgKGBhdXRvU2V0QWxsYClcbiAgICAgICAgLy8gQ0xJIHByb2QgYnVpbGRzIHdpbGwgcmVtb3ZlIHRoZSBwbHVnaW4ncyBjb2RlLlxuICAgICAgICBjb25zdCBjZWxsVG9vbHRpcENvbmZpZyA9IGNvbmZpZ1NlcnZpY2UuZ2V0KFBibE5ncmlkQ2VsbFRvb2x0aXBEaXJlY3RpdmUuUExVR0lOX0tFWSk7XG4gICAgICAgIGlmIChjZWxsVG9vbHRpcENvbmZpZyAmJiBjZWxsVG9vbHRpcENvbmZpZy5hdXRvU2V0QWxsID09PSB0cnVlKSB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luQ3RybCA9IGV2ZW50LmNvbnRyb2xsZXI7XG4gICAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHBsdWdpbkN0cmwuZXZlbnRzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCBldnQgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXZ0LmtpbmQgPT09ICdvbkluaXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbHVnaW5DdHJsLmhhc1BsdWdpbihQYmxOZ3JpZENlbGxUb29sdGlwRGlyZWN0aXZlLlBMVUdJTl9LRVkpKSB7XG4gICAgICAgICAgICAgICAgICBwbHVnaW5DdHJsLmNyZWF0ZVBsdWdpbihQYmxOZ3JpZENlbGxUb29sdGlwRGlyZWN0aXZlLlBMVUdJTl9LRVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufVxuIl19