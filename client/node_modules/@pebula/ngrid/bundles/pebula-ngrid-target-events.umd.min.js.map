{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@pebula/ngrid/target-events/lib/target-events/utils.ts","ng://@pebula/ngrid/target-events/lib/target-events/focus-and-selection.ts","ng://@pebula/ngrid/target-events/lib/target-events/target-events-plugin.ts","ng://@pebula/ngrid/target-events/lib/target-events/cell-edit.directive.ts","ng://@pebula/ngrid/target-events/lib/target-events.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","next","value","done","__read","e","ar","push","error","__spread","concat","isCellEvent","event","cellTarget","isDataCellEvent","context","isRowContainer","element","getAttribute","findParentCell","parentElement","matrixRowFromRow","row","vcRef","rowAttrType","rowIndex","sourceRow","previousElementSibling","Math","min","get","rootNodes","type","subType","getInnerCellsInRect","contextApi","xAxis","yAxis","spaceInside","yAxis_1","yAxis_1_1","vCell","xAxis_1","e_2","xAxis_1_1","hCell","findRowInCache","rowIdent","cells","colIndex","isOsx","test","navigator","platform","toLowerCase","isMainMouseButtonClick","source","button","handleFocusAndSelection","targetEvents","isCellFocusMode","grid","focusMode","handlers","handleSelectionChangeByMouseClickAndMove","cellContext","activeFocus","focusedCell","rowContext","identity","index","focusedRowState","hCells","vCells","_b","n1","n2","max","result","rangeBetween","_c","rowHeight","abs","dataIndex","dir","state","innerCells","selectCells","handleMouseDown","markForCheck","shiftKey","metaKey","ctrlKey","selected","unselectCells","focusCell","handleKeyDown","sourceCellRef","direction","rowState","sourceCell","coeff","axis","keyCode","UP_ARROW","DOWN_ARROW","LEFT_ARROW","RIGHT_ARROW","getCell","sourceCellState","_a","moveH","moveV","hAdj","vAdj","h","v","hContextIndex","hContext","pop","vContextIdent","vContext","handleSelectionChangeByArrows","createHandlers","keyDown","pipe","filter","subscribe","mouseDown","tap","stopPropagation","preventDefault","switchMap","cellEnter","takeUntil","mouseUp","hasListeners","observers","runOnce","PblColumn","extendProperty","PblNgridTargetEventsPlugin","injector","pluginCtrl","_this","rowClick","EventEmitter","rowDblClick","rowEnter","rowLeave","cellClick","cellDblClick","cellLeave","keyUp","destroyed","ReplaySubject","_removePlugin","setPlugin","isInit","init","subscription_1","events","kind","unsubscribe","undefined","create","table","PblNgridPluginController","find","PblNgridTargetEventsPlugin_1","setupDomEvents","lastCellEnterEvent","lastRowEnterEvent","cdkTable","_cdkTable","cdkTableElement","createCellEvent","rowTarget","matrixPoint","_rowOutlet","viewContainer","event_1","ds","renderedData","metaRowService","extApi","db","header","footer","fixed","sticky","item","el","cell","findCellRenderIndex","column","columnApi","findColumnAt","columnIndex","indexOf","store","columnStore","rowInfo","metaColumnIds","record","keys","isGroup","headerGroup","footerGroup","createRowEvent","root","event_2","event_3","getRow","$implicit","emitCellLeave","lastCellEnterEventTemp","emit","emitRowLeave","lastRowEnterEventTemp","processEvent","event_4","waitTime","event_5","splitProcessedEvent","cellEvent","rowEvent","registerUpDownEvents","eventName","emitter","fromEvent","map","syncRow","clickStream","bufferWhen","debounce","timer","shift","isDoubleClick","lastEvent","lastCellTarget","lastRowTarget","destroy","complete","syncRows","NgridPlugin","id","factory","PblNgridComponent","Injector","PblNgridTargetEventsPluginDirective","_super","__","constructor","__extends","ngOnDestroy","Directive","args","selector","outputs","UnRx","PblNgridCellEditDirective","_click","_dblClick","subscription","targetEventsPlugin","getPlugin","createPlugin","update","coerceBooleanProperty","kill","editable","startEdit","Input","PblNgridTargetEventsModule","parentModule","configService","created","targetEventsConfig","autoEnable","pluginCtrl_1","controller","evt","hasPlugin","NgModule","imports","CommonModule","CdkTableModule","PblNgridModule","declarations","exports","Optional","SkipSelf","PblNgridConfigService"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { ViewContainerRef, EmbeddedViewRef } from '@angular/core';\nimport { PblNgridContextApi, GridDataPoint } from '@pebula/ngrid';\nimport { PblNgridMatrixRow, PblNgridRowEvent, PblNgridCellEvent, PblNgridDataCellEvent } from './events';\n\nexport function isCellEvent<T, TEvent extends Event = MouseEvent | KeyboardEvent>(event: PblNgridRowEvent<T> | PblNgridCellEvent<T, TEvent>): event is PblNgridCellEvent<T, TEvent> {\n  return !!(event as  PblNgridCellEvent<T>).cellTarget;\n}\n\nexport function isDataCellEvent<T, TEvent extends Event = MouseEvent | KeyboardEvent>(event: PblNgridRowEvent<T> | PblNgridCellEvent<T, TEvent>): event is PblNgridDataCellEvent<T, TEvent> {\n  return isCellEvent(event) && !!(event as  PblNgridDataCellEvent<T, TEvent>).context;\n}\n\n/**\n * Returns true if the element is a row element (`pbl-ngrid-row`, `cdk-row`).\n *\n * This function works under the following assumptions:\n *\n *   - A row element MUST contain a \"role\" attribute with the value \"row\"\n */\nexport function isRowContainer(element: HTMLElement): boolean {\n  return element.getAttribute('role') === 'row';\n}\n\n/**\n * Find the cell element that is or wraps the provided element.\n * The element can be a table cell element (any type of) OR a nested element (any level) of a table cell element.\n *\n * This function works under the following assumptions:\n *\n *   - The parent of a cell element is a row element.\n *   - Each row element MUST contain a \"role\" attribute with the value \"row\"\n */\nexport function findParentCell(element: HTMLElement): HTMLElement | undefined {\n  while (element.parentElement) {\n    if (isRowContainer(element.parentElement)) {\n      return element;\n    }\n    element = element.parentElement;\n  }\n}\n\n/**\n * Returns the position (index) of the cell (element) among it's siblings.\n */\nexport function findCellRenderIndex(cell: Element): number {\n  let colIndex = 0;\n  while (cell = cell.previousElementSibling) {\n    colIndex++;\n  }\n  return colIndex;\n}\n\n/**\n * Returns table metadata for a given ROW element.\n * This function works under the following assumptions:\n *\n *   - Each row element MUST contain a \"role\" attribute with the value \"row\"\n *   - Each row element MUST contains the type identifier attribute \"data-rowtype\" (except \"data\" rows)\n *   - Allowed values for \"data-rowtype\" are: 'header' | 'meta-header' | 'footer' | 'meta-footer' | 'data'\n *   - Row's representing data items (data-rowtype=\"data\") can omit the type attribute and the function will infer it.\n *\n * NOTE that this function DOES NOT identify subType of `meta-group` (`PblNgridMatrixRow<'header' | 'footer', 'meta-group'>`), it will return it as\n * 'meta`, you need to handle this case specifically.\n *\n * Because detection is based on DOM element position finding the original row index when multiple row containers are set (fixed/style/row) will not work.\n * The rowIndex will be relative to the container, and not the entire table.\n */\nexport function matrixRowFromRow(row: Element,\n                                 vcRef: ViewContainerRef): PblNgridMatrixRow<'data'> | PblNgridMatrixRow<'header' | 'footer'> | PblNgridMatrixRow<'header' | 'footer', 'meta'> | undefined  {\n  const rowAttrType: 'header' | 'data' | 'footer' | 'meta-header' | 'meta-footer' = row.getAttribute('data-rowtype') as any || 'data';\n\n  // TODO: Error if rowAttrType is not one of the allowed values!\n\n  let rowIndex = 0;\n  switch (rowAttrType) {\n    case 'data':\n      const sourceRow = row;\n      while (row.previousElementSibling) {\n        rowIndex++;\n        row = row.previousElementSibling;\n      }\n      rowIndex = Math.min(rowIndex, vcRef.length - 1);\n      while (rowIndex > -1) {\n        if ((vcRef.get(rowIndex) as EmbeddedViewRef<any>).rootNodes[0] === sourceRow) {\n          return {\n            type: 'data',\n            subType: 'data',\n            rowIndex,\n          } as { rowIndex: number } & PblNgridMatrixRow<'data'>;\n        }\n        rowIndex--;\n      }\n      return;\n    case 'header':\n    case 'footer':\n     return {\n        type: rowAttrType,\n        subType: 'data',\n        rowIndex,\n      } as PblNgridMatrixRow<'header' | 'footer'>;\n    default:\n      while (row.previousElementSibling && row.previousElementSibling.getAttribute('data-rowtype') === rowAttrType) {\n        rowIndex++;\n        row = row.previousElementSibling;\n      }\n      return {\n        type: rowAttrType === 'meta-footer' ? 'footer' : 'header',\n        subType: 'meta',\n        rowIndex,\n      } as PblNgridMatrixRow<'header' | 'footer', 'meta'>;\n  }\n}\n\n/**\n * Given a list of cells stacked vertically (yAxis) and a list of cells stacked horizontally (xAxis) return all the cells inside (without the provided axis cells).\n *\n * In the following example, all [Yn] cells are provided in the yAxis param and all [Xn] cell in the xAxis params, the returned value will be an array\n * with all cells marked with Z.\n *    Y5  Z  Z  Z\n *    Y4  Z  Z  Z\n *    Y3  Z  Z  Z\n *    Y2  Z  Z  Z\n *    XY1 X2 X3 X4\n * @param contextApi\n * @param xAxis\n * @param yAxis\n */\nexport function getInnerCellsInRect(contextApi: PblNgridContextApi<any>, xAxis: GridDataPoint[], yAxis: GridDataPoint[]): GridDataPoint[] {\n  const spaceInside: GridDataPoint[] = [ ];\n  for (const vCell of yAxis) {\n    for (const hCell of xAxis) {\n      const vhContext = contextApi.findRowInCache(vCell.rowIdent).cells[hCell.colIndex];\n      if (vhContext) {\n        spaceInside.push({ rowIdent: vCell.rowIdent, colIndex: hCell.colIndex });\n      }\n    }\n  }\n  return spaceInside;\n}\n\nexport function rangeBetween(n1: number, n2: number): number[] {\n  const min = Math.min(n1, n2);\n  const max = min === n1 ? n2 : n1;\n\n  const result: number[] = [];\n  for (let i = min + 1; i < max; i++) {\n    result.push(i);\n  }\n  return result;\n}\n","import { takeUntil, switchMap, filter, tap } from 'rxjs/operators';\nimport { LEFT_ARROW, UP_ARROW, RIGHT_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';\n\nimport { GridDataPoint } from '@pebula/ngrid';\nimport { PblNgridRowEvent, PblNgridCellEvent, PblNgridDataCellEvent } from './events';\nimport { PblNgridTargetEventsPlugin } from './target-events-plugin';\nimport { isCellEvent, isDataCellEvent, rangeBetween, getInnerCellsInRect } from './utils';\n\nconst isOsx = /^mac/.test(navigator.platform.toLowerCase())\nconst isMainMouseButtonClick = (event: PblNgridDataCellEvent<any, MouseEvent>) => event.source.button === 0;\n\nexport function handleFocusAndSelection(targetEvents: PblNgridTargetEventsPlugin) {\n  const isCellFocusMode = () => targetEvents.grid.focusMode === 'cell';\n\n  const handlers = createHandlers(targetEvents);\n\n  // Handle array keys move (with shift for selection, without for cell focus change)\n  targetEvents.keyDown\n    .pipe(filter(isCellFocusMode))\n    .subscribe(handlers.handleKeyDown);\n\n  // Handle mouse down on cell (focus) and then moving for selection.\n  targetEvents.mouseDown\n    .pipe(\n      filter(isCellFocusMode),\n      filter(isDataCellEvent),\n      filter(isMainMouseButtonClick),\n      tap( event => {\n        event.source.stopPropagation();\n        event.source.preventDefault();\n      }),\n      tap(handlers.handleMouseDown), // handle mouse down focus\n      switchMap( () => targetEvents.cellEnter.pipe(takeUntil(targetEvents.mouseUp)) ),\n      filter(isDataCellEvent),\n      filter(isMainMouseButtonClick)\n    )\n    .subscribe(handlers.handleSelectionChangeByMouseClickAndMove); // now handle movements until mouseup\n\n}\n\nfunction createHandlers(targetEvents: PblNgridTargetEventsPlugin) {\n  const { contextApi } = targetEvents.grid;\n\n  function focusCell(rowIdent: any, colIndex: number, markForCheck?: boolean): void {\n    contextApi.focusCell({ rowIdent, colIndex }, markForCheck);\n  }\n\n  function handleMouseDown(event: PblNgridDataCellEvent<any, MouseEvent>): void {\n    if (contextApi.focusedCell && event.source.shiftKey) {\n      handleSelectionChangeByMouseClickAndMove(event);\n    } else if (isOsx ? event.source.metaKey : event.source.ctrlKey) {\n      if (event.context.selected) {\n        contextApi.unselectCells([ event.context ]);\n      } else {\n        contextApi.selectCells([ event.context ]);\n      }\n    } else {\n      focusCell(event.context.rowContext.identity, event.context.index);\n    }\n  }\n\n  function handleKeyDown(event: PblNgridRowEvent | PblNgridCellEvent): void {\n    const source: KeyboardEvent = event.source as any;\n    if (isCellEvent(event)) {\n      const sourceCell = event.cellTarget;\n\n      let coeff: 1 | -1 = 1;\n      let axis: 'h' | 'v';\n\n      switch (source.keyCode) {\n        case UP_ARROW:\n          coeff = -1;\n        case DOWN_ARROW: // tslint:disable-line: no-switch-case-fall-through\n          axis = 'v';\n          break;\n        case LEFT_ARROW:\n          coeff = -1;\n        case RIGHT_ARROW: // tslint:disable-line: no-switch-case-fall-through\n          axis = 'h';\n          break;\n        default:\n          return;\n      }\n\n      const cellContext = contextApi.getCell(sourceCell);\n      const activeFocus = contextApi.focusedCell || {\n        rowIdent: cellContext.rowContext.identity,\n        colIndex: cellContext.index,\n      };\n\n      if (!!source.shiftKey) {\n        handleSelectionChangeByArrows(activeFocus, axis === 'h' ? [coeff, 0] : [0, coeff]);\n      } else {\n        handleSingleItemFocus(activeFocus, axis === 'h' ? [coeff, 0] : [0, coeff])\n      }\n    }\n  }\n\n  /**\n   * Handle selection changes caused ONLY by the use of the arrow keys with SHIFT key.\n   *\n   * The implementation is NOT incremental, it will re-calculate the selected cell on every arrow key press (every call to this function).\n   *\n   * First. A simple adjacent cell detection is performed to determine the direction of the current selected cells relative to the\n   * source cell (usually the focused cell). We only care about 4 cells, adjacent to the source Cell: Top, Left, Bottom, Right\n   *\n   *    │ T │\n   * ───┼───┼───\n   *  R │ C │ L\n   * ───┼───┼───\n   *    │ B │\n   *\n   * We can only have 1 quarter selection with Arrow selection so it TL, TR, BR or BL, any other setup will clear the selection and start from scratch.\n   *\n   * > Note that the logic in this function is for use with arrow keys + SHIFT key, other selection logic\n   * does not fit this scenario (e.g. MOUSE selection or ARROW KEYS + CTRL KEY selection)\n   *\n   * @param sourceCellRef A point reference to the source cell the direction is relative to\n   * @param direction The direction of the new cell.\n   * [1 | -1, 0] -> HORIZONTAL\n   * [0, 1 | -1] -> VERTICAL\n   */\n  function handleSelectionChangeByArrows(sourceCellRef: GridDataPoint, direction: [0, 1 | -1] | [1 | -1, 0]) {\n    const { rowIdent, colIndex } = sourceCellRef;\n    const sourceCellState = contextApi.findRowInCache(rowIdent);\n    const [moveH, moveV] = direction;\n\n    const hAdj = [ sourceCellState.cells[colIndex - 1], sourceCellState.cells[colIndex + 1] ];\n    const vAdj = [ contextApi.findRowInCache(rowIdent, -1, true), contextApi.findRowInCache(rowIdent, 1, true) ];\n\n    let h = (hAdj[0] && hAdj[0].selected ? -1 : 0) + (hAdj[1] && hAdj[1].selected ? 1 : 0);\n    let v = (vAdj[0] && vAdj[0].cells[colIndex].selected ? -1 : 0) + (vAdj[1] && vAdj[1].cells[colIndex].selected ? 1 : 0);\n\n    if (h === 0) {\n      h += moveH;\n    }\n    if (v === 0) {\n      v += moveV;\n    }\n\n    const hCells: GridDataPoint[] = [];\n    if (h !== 0) {\n      let hContextIndex = colIndex;\n      let hContext = sourceCellState.cells[colIndex];\n      while (hContext && hContext.selected) {\n        hCells.push({ rowIdent, colIndex: hContextIndex });\n        hContextIndex += h;\n        hContext = sourceCellState.cells[hContextIndex];\n      }\n\n      if (moveH) {\n        if (h === moveH) {\n          if (hContext) {\n            hCells.push({ rowIdent, colIndex: hContextIndex });\n          }\n        } else {\n          hCells.pop();\n        }\n      }\n    }\n\n    const vCells: GridDataPoint[] = [ ];\n    if (v !== 0) {\n      let vContextIdent = rowIdent;\n      let vContext = contextApi.findRowInCache(vContextIdent, v, true);\n      while (vContext && vContext.cells[colIndex].selected) {\n        vContextIdent = vContext.identity;\n        vCells.push({ rowIdent: vContextIdent, colIndex });\n        vContext = contextApi.findRowInCache(vContextIdent, v, true);\n      }\n\n      if (moveV) {\n        if (v === moveV) {\n          if (vContext) {\n            vCells.push({ rowIdent: vContext.identity, colIndex });\n          }\n        } else {\n          vCells.pop();\n        }\n      }\n\n    }\n\n    const innerCells = getInnerCellsInRect(contextApi, hCells, vCells);\n    contextApi.selectCells([ sourceCellRef, ...hCells, ...vCells, ...innerCells ], false, true);\n  }\n\n  function handleSelectionChangeByMouseClickAndMove(event: PblNgridDataCellEvent<any, MouseEvent>) {\n    const cellContext = event.context;\n    const activeFocus = contextApi.focusedCell || {\n      rowIdent: cellContext.rowContext.identity,\n      colIndex: cellContext.index,\n    };\n    const focusedRowState = contextApi.findRowInCache(activeFocus.rowIdent);\n\n    const hCells: GridDataPoint[] = [];\n    const vCells: GridDataPoint[] = [];\n\n    for (const i of rangeBetween(activeFocus.colIndex, cellContext.index)) {\n      hCells.push({ rowIdent: activeFocus.rowIdent, colIndex: i });\n    }\n    hCells.push({ rowIdent: activeFocus.rowIdent, colIndex: cellContext.index });\n\n    const rowHeight = Math.abs(cellContext.rowContext.dataIndex - focusedRowState.dataIndex);\n    const dir = focusedRowState.dataIndex > cellContext.rowContext.dataIndex ? -1 : 1;\n    for (let i = 1; i <= rowHeight; i++) {\n      const state = contextApi.findRowInCache(activeFocus.rowIdent, dir * i, true);\n      vCells.push({ rowIdent: state.identity, colIndex: activeFocus.colIndex });\n    }\n    const innerCells = getInnerCellsInRect(contextApi, hCells, vCells);\n    contextApi.selectCells([ activeFocus, ...hCells, ...vCells, ...innerCells ], false, true);\n  }\n\n  /**\n   * Swap the focus from the source cell to a straight adjacent cell (not diagonal).\n   * @param sourceCellRef A point reference to the source cell the direction is relative to\n   * @param direction The direction of the new cell.\n   * [1 | -1, 0] -> HORIZONTAL\n   * [0, 1 | -1] -> VERTICAL\n   */\n  function handleSingleItemFocus(sourceCellRef: GridDataPoint, direction: [0, 1 | -1] | [1 | -1, 0]) {\n    const rowState = contextApi.findRowInCache(sourceCellRef.rowIdent, direction[1], true);\n    if (rowState) {\n      contextApi.focusCell({ rowIdent: rowState.identity, colIndex: sourceCellRef.colIndex + direction[0] }, true);\n    }\n  }\n\n  return {\n    handleMouseDown,\n    handleKeyDown,\n    handleSelectionChangeByMouseClickAndMove\n  }\n}\n\n","import { fromEvent, timer, Observer, ReplaySubject } from 'rxjs';\nimport { bufferWhen, debounce, map, filter, takeUntil } from 'rxjs/operators';\nimport { Directive, EventEmitter, OnDestroy, ChangeDetectorRef, Injector } from '@angular/core';\n\nimport { UnRx } from '@pebula/utils';\nimport { PblNgridComponent, PblNgridPluginController, PblColumn, NgridPlugin } from '@pebula/ngrid';\n\nimport * as Events from './events';\nimport { matrixRowFromRow, isRowContainer, findCellRenderIndex, findParentCell } from './utils';\nimport { handleFocusAndSelection } from './focus-and-selection';\n\ndeclare module '@pebula/ngrid/lib/grid/services/config' {\n  interface PblNgridConfig {\n    targetEvents?: {\n      /** When set to true will enable the target events plugin on all table instances by default. */\n      autoEnable?: boolean;\n    };\n  }\n}\n\ndeclare module '@pebula/ngrid/lib/ext/types' {\n  interface PblNgridPluginExtension {\n    targetEvents?: PblNgridTargetEventsPlugin;\n  }\n  interface PblNgridPluginExtensionFactories {\n    targetEvents: keyof typeof PblNgridTargetEventsPlugin;\n  }\n}\n\nexport const PLUGIN_KEY: 'targetEvents' = 'targetEvents';\n\nfunction hasListeners(source: { observers: Observer<any>[] }): boolean {\n  return source.observers.length > 0;\n}\n\nfunction findEventSource(source: Event): { type: 'row' | 'cell', target: HTMLElement } | undefined {\n  const cellTarget = findParentCell(source.target as any);\n  if (cellTarget) {\n    return { type: 'cell', target: cellTarget };\n  } else if (isRowContainer(source.target as any)) {\n    return { type: 'cell', target: source.target as any };\n  }\n}\n\nexport function runOnce(): void {\n  PblColumn.extendProperty('editable');\n}\n\n@NgridPlugin({ id: PLUGIN_KEY, factory: 'create', runOnce })\nexport class PblNgridTargetEventsPlugin<T = any> {\n  rowClick = new EventEmitter<Events.PblNgridRowEvent<T>>();\n  rowDblClick = new EventEmitter<Events.PblNgridRowEvent<T>>();\n  rowEnter = new EventEmitter<Events.PblNgridRowEvent<T>>();\n  rowLeave = new EventEmitter<Events.PblNgridRowEvent<T>>();\n\n  cellClick = new EventEmitter<Events.PblNgridCellEvent<T, MouseEvent>>();\n  cellDblClick = new EventEmitter<Events.PblNgridCellEvent<T, MouseEvent>>();\n  cellEnter = new EventEmitter<Events.PblNgridCellEvent<T, MouseEvent>>();\n  cellLeave = new EventEmitter<Events.PblNgridCellEvent<T, MouseEvent>>();\n\n  mouseDown = new EventEmitter<Events.PblNgridCellEvent<T, MouseEvent> | Events.PblNgridRowEvent<T>>();\n  mouseUp = new EventEmitter<Events.PblNgridCellEvent<T, MouseEvent> | Events.PblNgridRowEvent<T>>();\n  keyUp = new EventEmitter<Events.PblNgridCellEvent<T, KeyboardEvent> | Events.PblNgridRowEvent<T>>();\n  keyDown = new EventEmitter<Events.PblNgridCellEvent<T, KeyboardEvent> | Events.PblNgridRowEvent<T>>();\n\n  /** @deprecated use `gird` instead */\n  get table(): PblNgridComponent<any> { return this.grid; }\n\n  protected readonly destroyed = new ReplaySubject<void>();\n\n  private _removePlugin: (table: PblNgridComponent<any>) => void;\n\n  constructor(public readonly grid: PblNgridComponent<any>,\n              protected injector: Injector,\n              protected pluginCtrl: PblNgridPluginController) {\n    this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, this);\n    if (grid.isInit) {\n      this.init();\n    } else {\n      let subscription = pluginCtrl.events\n        .subscribe( event => {\n          if (event.kind === 'onInit') {\n            this.init();\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        });\n    }\n  }\n\n  static create<T = any>(table: PblNgridComponent<any>, injector: Injector): PblNgridTargetEventsPlugin<T> {\n    const pluginCtrl = PblNgridPluginController.find(table);\n    return new PblNgridTargetEventsPlugin<T>(table, injector, pluginCtrl);\n  }\n\n  private init(): void {\n    this.setupDomEvents();\n    handleFocusAndSelection(this);\n  }\n\n  private setupDomEvents(): void {\n    const grid = this.grid;\n    const cdkTable = grid._cdkTable;\n    const cdkTableElement: HTMLElement = cdkTable['_element'];\n\n    const createCellEvent = <TEvent extends Event>(cellTarget: HTMLElement, source: TEvent): Events.PblNgridCellEvent<T, TEvent> | undefined => {\n      const rowTarget = cellTarget.parentElement;\n      const matrixPoint = matrixRowFromRow(rowTarget, cdkTable._rowOutlet.viewContainer);\n      if (matrixPoint) {\n        const event: Events.PblNgridCellEvent<T, TEvent> = { ...matrixPoint, source, cellTarget, rowTarget } as any;\n        if (matrixPoint.type === 'data') {\n          (event as Events.PblNgridDataMatrixPoint<T>).row = grid.ds.renderedData[matrixPoint.rowIndex];\n        } else if (event.subType === 'meta') {\n          // When multiple containers exists (fixed/sticky/row) the rowIndex we get is the one relative to the container..\n          // We need to find the rowIndex relative to the definitions:\n          const { metaRowService } = this.pluginCtrl.extApi;\n          const db = event.type === 'header' ? metaRowService.header : metaRowService.footer;\n\n          for (const coll of [db.fixed, db.row, db.sticky]) {\n            const result = coll.find( item => item.el === event.rowTarget );\n            if (result) {\n              event.rowIndex = result.index;\n              break;\n            }\n          }\n        }\n\n        /* `metadataFromElement()` does not provide column information nor the column itself. This will extend functionality to add the columnIndex and column.\n            The simple case is when `subType === 'data'`, in this case the column is always the data column for all types (header, data and footer)\n\n            If `subType !== 'data'` we need to get the proper column based type (type can only be `header` or `footer` at this point).\n            But that's not all, because `metadataFromElement()` does not handle `meta-group` subType we need to do it here...\n        */\n        event.colIndex = findCellRenderIndex(cellTarget);\n        if (matrixPoint.subType === 'data') {\n          const column = this.grid.columnApi.findColumnAt(event.colIndex);\n          const columnIndex = this.grid.columnApi.indexOf(column);\n          event.column = column;\n          (event as Events.PblNgridDataMatrixPoint<T>).context = this.pluginCtrl.extApi.contextApi.getCell(event.rowIndex, columnIndex);\n        } else {\n          const store = this.pluginCtrl.extApi.columnStore;\n          const rowInfo = store.metaColumnIds[matrixPoint.type][event.rowIndex];\n          const record = store.find(rowInfo.keys[event.colIndex]);\n          if (rowInfo.isGroup) {\n            event.subType = 'meta-group';\n            event.column = matrixPoint.type === 'header' ? record.headerGroup : record.footerGroup;\n          } else {\n            event.column = matrixPoint.type === 'header' ? record.header : record.footer;\n          }\n        }\n        return event;\n      }\n    }\n\n    const createRowEvent = <TEvent extends Event>(rowTarget: HTMLElement, source: TEvent, root?: Events.PblNgridCellEvent<T, TEvent>): Events.PblNgridRowEvent<T> | undefined => {\n      if (root) {\n        const event: Events.PblNgridRowEvent<T> = {\n          source,\n          rowTarget,\n          type: root.type,\n          subType: root.subType,\n          rowIndex: root.rowIndex,\n          root\n        } as any;\n        if (root.type === 'data') {\n          (event as Events.PblNgridDataMatrixRow<T>).row = root.row;\n          (event as Events.PblNgridDataMatrixRow<T>).context = root.context.rowContext;\n        }\n        return event;\n      } else {\n        const matrixPoint = matrixRowFromRow(rowTarget, cdkTable._rowOutlet.viewContainer);\n        if (matrixPoint) {\n          const event: Events.PblNgridRowEvent<T> = { ...matrixPoint, source, rowTarget } as any;\n          if (matrixPoint.type === 'data') {\n            (event as Events.PblNgridDataMatrixRow<T>).context = this.pluginCtrl.extApi.contextApi.getRow(matrixPoint.rowIndex);\n            (event as Events.PblNgridDataMatrixRow<T>).row = (event as Events.PblNgridDataMatrixRow<T>).context.$implicit;\n          }\n\n          /*  If `subType !== 'data'` it can only be `meta` because `metadataFromElement()` does not handle `meta-group` subType.\n              We need to extend this missing part, we don't have columns here so we will try to infer it using the first column.\n\n              It's similar to how it's handled in cell clicks, but here we don't need to extends the column info.\n              We only need to change the `subType` when the row is a group row, getting a specific column is irrelevant.\n              We just need A column because group columns don't mix with regular meta columns.\n\n              NOTE: When subType is not 'data' the ype can only be `header` or `footer`.\n          */\n          if (matrixPoint.subType !== 'data') {\n            const rowInfo = this.pluginCtrl.extApi.columnStore.metaColumnIds[matrixPoint.type][event.rowIndex];\n            if (rowInfo.isGroup) {\n              event.subType = 'meta-group';\n            }\n          }\n          return event;\n        }\n      }\n    }\n\n    let lastCellEnterEvent: Events.PblNgridCellEvent<T, MouseEvent>;\n    let lastRowEnterEvent: Events.PblNgridRowEvent<T>;\n    const emitCellLeave = (source: MouseEvent): Events.PblNgridCellEvent<T> | undefined => {\n      if (lastCellEnterEvent) {\n        const lastCellEnterEventTemp = lastCellEnterEvent;\n        this.cellLeave.emit(Object.assign({}, lastCellEnterEventTemp, { source }));\n        lastCellEnterEvent = undefined;\n        return lastCellEnterEventTemp;\n      }\n    }\n    const emitRowLeave = (source: MouseEvent): Events.PblNgridRowEvent<T> | undefined => {\n      if (lastRowEnterEvent) {\n        const lastRowEnterEventTemp = lastRowEnterEvent;\n        this.rowLeave.emit(Object.assign({}, lastRowEnterEventTemp, { source }));\n        lastRowEnterEvent = undefined;\n        return lastRowEnterEventTemp;\n      }\n    }\n\n    const processEvent = <TEvent extends Event>(e: TEvent) => {\n      const result = findEventSource(e);\n      if (result) {\n        if (result.type === 'cell') {\n          const event = createCellEvent<TEvent>(result.target, e);\n          if (event) {\n            return {\n              type: result.type,\n              event,\n              waitTime: hasListeners(this.cellDblClick) ? 250 : 1,\n            };\n          }\n        } else if (result.type === 'row') {\n          const event = createRowEvent(result.target, e);\n          if (event) {\n            return {\n              type: result.type,\n              event,\n              waitTime: hasListeners(this.rowDblClick) ? 250 : 1,\n            };\n          }\n        }\n      }\n    };\n\n    /** Split the result of processEvent into cell and row events, if type is row only row event is returned, if cell then cell is returned and row is created along side. */\n    const splitProcessedEvent = <TEvent extends Event>(event: ReturnType<typeof processEvent>) => {\n      const cellEvent = event.type === 'cell' ? event.event as Events.PblNgridCellEvent<T, TEvent> : undefined;\n      const rowEvent = cellEvent\n        ? createRowEvent<TEvent>(cellEvent.rowTarget, cellEvent.source, cellEvent)\n        : event.event as Events.PblNgridRowEvent<T>\n      ;\n      return { cellEvent, rowEvent };\n    };\n\n    const registerUpDownEvents = <TEvent extends Event>(eventName: string, emitter: EventEmitter<Events.PblNgridCellEvent<T, TEvent> | Events.PblNgridRowEvent<T>>) => {\n      fromEvent(cdkTableElement, eventName)\n        .pipe(\n          takeUntil(this.destroyed),\n          filter( source => hasListeners(emitter) ),\n          map(processEvent),\n          filter( result => !!result ),\n        )\n        .subscribe( result => {\n          const { cellEvent, rowEvent } = splitProcessedEvent<TEvent>(result);\n          emitter.emit(cellEvent || rowEvent);\n          this.syncRow(cellEvent || rowEvent);\n        });\n    }\n\n    registerUpDownEvents<MouseEvent>('mouseup', this.mouseUp);\n    registerUpDownEvents<MouseEvent>('mousedown', this.mouseDown);\n    registerUpDownEvents<KeyboardEvent>('keyup', this.keyUp);\n    registerUpDownEvents<KeyboardEvent>('keydown', this.keyDown);\n\n    /*\n      Handling click stream for both click and double click events.\n      We want to detect double clicks and clicks with minimal delays\n      We check if a double click has listeners, if not we won't delay the click...\n      TODO: on double click, don't wait the whole 250 ms if 2 clicks happen.\n    */\n    const clickStream = fromEvent(cdkTableElement, 'click').pipe(\n      takeUntil(this.destroyed),\n      filter( source => hasListeners(this.cellClick) || hasListeners(this.cellDblClick) || hasListeners(this.rowClick) || hasListeners(this.rowDblClick) ),\n      map(processEvent),\n      filter( result => !!result ),\n    );\n\n    clickStream\n      .pipe(\n        bufferWhen( () => clickStream.pipe( debounce( e => timer(e.waitTime) ) ) ),\n        filter( events => events.length > 0 ),\n      )\n      .subscribe( events => {\n        const event = events.shift();\n        const isDoubleClick = events.length === 1; // if we have 2 events its double click, otherwise single.\n        const { cellEvent, rowEvent } = splitProcessedEvent<MouseEvent>(event);\n        if (isDoubleClick) {\n          if (cellEvent) {\n            this.cellDblClick.emit(cellEvent);\n          }\n          this.rowDblClick.emit(rowEvent);\n        } else {\n          if (cellEvent) {\n            this.cellClick.emit(cellEvent);\n          }\n          this.rowClick.emit(rowEvent);\n        }\n        this.syncRow(cellEvent || rowEvent);\n      });\n\n\n    fromEvent(cdkTableElement, 'mouseleave')\n      .pipe(\n        takeUntil(this.destroyed),\n      )\n      .subscribe( (source: MouseEvent) => {\n        let lastEvent: Events.PblNgridRowEvent<T> | Events.PblNgridCellEvent<T> = emitCellLeave(source);\n        lastEvent = emitRowLeave(source) || lastEvent;\n        if (lastEvent) {\n          this.syncRow(lastEvent);\n        }\n      });\n\n    fromEvent(cdkTableElement, 'mousemove')\n      .pipe(\n        takeUntil(this.destroyed),\n      )\n      .subscribe( (source: MouseEvent) => {\n        const cellTarget: HTMLElement = findParentCell(source.target as any);\n        const lastCellTarget = lastCellEnterEvent && lastCellEnterEvent.cellTarget;\n        const lastRowTarget = lastRowEnterEvent && lastRowEnterEvent.rowTarget;\n\n        let cellEvent: Events.PblNgridCellEvent<T, MouseEvent>;\n        let lastEvent: Events.PblNgridRowEvent<T> | Events.PblNgridCellEvent<T>;\n\n        if (lastCellTarget !== cellTarget) {\n          lastEvent = emitCellLeave(source) || lastEvent;\n        }\n\n        if (cellTarget) {\n          if (lastCellTarget !== cellTarget) {\n            cellEvent = createCellEvent(cellTarget, source);\n            if (cellEvent) {\n              this.cellEnter.emit(lastCellEnterEvent = cellEvent);\n            }\n          } else {\n            return;\n          }\n        }\n\n        const rowTarget = (cellEvent && cellEvent.rowTarget) || (isRowContainer(source.target as any) && source.target as any);\n\n        if (lastRowTarget !== rowTarget) {\n          lastEvent = emitRowLeave(source) || lastEvent;\n        }\n\n        if (rowTarget) {\n          if (lastRowTarget !== rowTarget) {\n            const rowEvent = createRowEvent(rowTarget, source, cellEvent);\n            if (rowEvent) {\n              this.rowEnter.emit(lastRowEnterEvent = rowEvent);\n            }\n          }\n        }\n\n        if (lastEvent) {\n          this.syncRow(lastEvent);\n        }\n      });\n  }\n\n  destroy(): void {\n    this.destroyed.next();\n    this.destroyed.complete();\n    this._removePlugin(this.grid);\n  }\n\n  private syncRow<TEvent extends Event>(event: Events.PblNgridRowEvent<T> | Events.PblNgridCellEvent<T, TEvent>): void {\n    this.grid._cdkTable.syncRows(event.type, event.rowIndex);\n  }\n}\n\n@Directive({\n  // tslint:disable-next-line:directive-selector\n  selector: 'pbl-ngrid[targetEvents], pbl-ngrid[rowClick], pbl-ngrid[rowDblClick], pbl-ngrid[rowEnter], pbl-ngrid[rowLeave], pbl-ngrid[cellClick], pbl-ngrid[cellDblClick], pbl-ngrid[cellEnter], pbl-ngrid[cellLeave], pbl-ngrid[keyDown], pbl-ngrid[keyUp]',\n  // tslint:disable-next-line:use-output-property-decorator\n  outputs: [ 'rowClick', 'rowDblClick', 'rowEnter', 'rowLeave', 'cellClick', 'cellDblClick', 'cellEnter', 'cellLeave', 'keyDown', 'keyUp' ]\n})\n@UnRx()\nexport class PblNgridTargetEventsPluginDirective<T> extends PblNgridTargetEventsPlugin<T> implements OnDestroy {\n\n  constructor(table: PblNgridComponent<any>, injector: Injector, pluginCtrl: PblNgridPluginController) {\n    super(table, injector, pluginCtrl);\n  }\n\n  ngOnDestroy() {\n    this.destroy();\n  }\n\n}\n","import { Directive, Input, Injector } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\n\nimport { UnRx } from '@pebula/utils';\nimport { PblNgridComponent, PblNgridPluginController } from '@pebula/ngrid';\nimport { PblNgridTargetEventsPlugin } from './target-events-plugin';\n\n@Directive({\n  // tslint:disable-next-line:directive-selector\n  selector: 'pbl-ngrid[cellEditClick], pbl-ngrid[cellEditDblClick]',\n})\n@UnRx()\nexport class PblNgridCellEditDirective<T> {\n  @Input() set cellEditClick(value: boolean) {\n    value = coerceBooleanProperty(value);\n    if (this._click !== value) {\n      this._click = value;\n      this.update();\n    }\n  }\n  @Input() set cellEditDblClick(value: boolean) {\n    value = coerceBooleanProperty(value);\n    if (this._dblClick !== value) {\n      this._dblClick = value;\n      this.update();\n    }\n  }\n\n  private _click = false;\n  private _dblClick = false;\n  private targetEventsPlugin: PblNgridTargetEventsPlugin<T>;\n\n  constructor(grid: PblNgridComponent<any>, injector: Injector, pluginCtrl: PblNgridPluginController) {\n\n    let subscription = pluginCtrl.events.subscribe( event => {\n      if (event.kind === 'onInit') {\n        subscription.unsubscribe();\n        subscription = undefined;\n\n        // Depends on target-events plugin\n        // if it's not set, create it.\n        this.targetEventsPlugin = pluginCtrl.getPlugin('targetEvents') || pluginCtrl.createPlugin('targetEvents');\n        this.update();\n      }\n    });\n  }\n\n  private update(): void {\n    if (this.targetEventsPlugin) {\n      UnRx.kill(this, this.targetEventsPlugin);\n      if (this._click) {\n        this.targetEventsPlugin.cellClick\n          .pipe(UnRx(this, this.targetEventsPlugin))\n          .subscribe( event => {\n            if (event.type === 'data' && event.column.editable) {\n              event.context.startEdit(true);\n            }\n          });\n      }\n\n      if (this._dblClick) {\n        this.targetEventsPlugin.cellDblClick\n          .pipe(UnRx(this, this.targetEventsPlugin))\n          .subscribe( event => {\n            if (event.type === 'data' && event.column.editable) {\n              event.context.startEdit(true);\n            }\n          });\n      }\n    }\n  }\n}\n","import { NgModule, Optional, SkipSelf } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { CdkTableModule } from '@angular/cdk/table';\nimport { PblNgridModule, PblNgridPluginController, PblNgridConfigService } from '@pebula/ngrid';\nimport { PblNgridTargetEventsPluginDirective, PLUGIN_KEY } from './target-events/target-events-plugin';\nimport { PblNgridCellEditDirective } from './target-events/cell-edit.directive';\n\n@NgModule({\n  imports: [ CommonModule, CdkTableModule, PblNgridModule ],\n  declarations: [ PblNgridTargetEventsPluginDirective, PblNgridCellEditDirective ],\n  exports: [ PblNgridTargetEventsPluginDirective, PblNgridCellEditDirective  ]\n})\nexport class PblNgridTargetEventsModule {\n  constructor(@Optional() @SkipSelf() parentModule: PblNgridTargetEventsModule,\n              configService: PblNgridConfigService) {\n\n  if (parentModule) {\n    return;\n  }\n\n  PblNgridPluginController.created\n    .subscribe( event => {\n      const targetEventsConfig = configService.get(PLUGIN_KEY);\n      if (targetEventsConfig && targetEventsConfig.autoEnable === true) {\n        const pluginCtrl = event.controller;\n        let subscription = pluginCtrl.events\n          .subscribe( evt => {\n            if (evt.kind === 'onInit') {\n              if (!pluginCtrl.hasPlugin(PLUGIN_KEY)) {\n                pluginCtrl.createPlugin(PLUGIN_KEY);\n              }\n              subscription.unsubscribe();\n              subscription = undefined;\n            }\n          });\n      }\n    });\n  }\n}\n"]}