import { OnInit, ElementRef, DoCheck, ViewContainerRef, NgZone, EmbeddedViewRef } from '@angular/core';
import { CdkHeaderCell, CdkCell, CdkFooterCell } from '@angular/cdk/table';
import { PblNgridComponent } from '../ngrid.component';
import { COLUMN, PblMetaColumn, PblColumn, PblColumnGroup } from '../columns';
import { MetaCellContext, PblNgridMetaCellContext, PblRowContext, PblCellContext } from '../context/index';
import { PblNgridColumnDef } from './column-def';
import { PblNgridDataHeaderExtensionContext, PblNgridMultiComponentRegistry } from './registry.directives';
/**
 * Header cell component.
 * The header cell component will render the header cell template and add the proper classes and role.
 *
 * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.
 * These extensions add features to the cells either as a template instance or as a component instance.
 * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...
 */
import * as ɵngcc0 from '@angular/core';
export declare class PblNgridHeaderCellComponent<T extends COLUMN = COLUMN> extends CdkHeaderCell implements OnInit {
    readonly columnDef: PblNgridColumnDef<T>;
    readonly grid: PblNgridComponent<any>;
    readonly elementRef: ElementRef;
    private zone;
    vcRef: ViewContainerRef;
    private el;
    cellCtx: PblNgridDataHeaderExtensionContext | MetaCellContext;
    /** @deprecated use grid instead */
    readonly table: PblNgridComponent<T>;
    constructor(columnDef: PblNgridColumnDef<T>, grid: PblNgridComponent<any>, elementRef: ElementRef, zone: NgZone);
    ngOnInit(): void;
    protected initMainHeaderColumnView(col: PblColumn): EmbeddedViewRef<PblNgridMetaCellContext<any, PblMetaColumn | PblColumn>>;
    protected initMetaHeaderColumnView(col: PblMetaColumn | PblColumnGroup): EmbeddedViewRef<PblNgridMetaCellContext<any, PblMetaColumn | PblColumn>>;
    protected runHeaderExtensions(context: PblNgridDataHeaderExtensionContext, view: EmbeddedViewRef<PblNgridMetaCellContext<any, PblColumn>>): void;
    protected createComponent(ext: PblNgridMultiComponentRegistry<any, "dataHeaderExtensions">, context: PblNgridDataHeaderExtensionContext, rootNodes: any[]): any[];
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridHeaderCellComponent<any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<PblNgridHeaderCellComponent<any>, "pbl-ngrid-header-cell", ["ngridHeaderCell"], {}, {}, never, never>;
}
/** Cell template container that adds the right classes and role. */
export declare class PblNgridCellDirective extends CdkCell implements DoCheck {
    private colDef;
    set rowCtx(value: PblRowContext<any>);
    private _rowCtx;
    cellCtx: PblCellContext | undefined;
    /**
     * The position of the column def among all columns regardless of visibility.
     */
    private colIndex;
    private el;
    private focused;
    private selected;
    constructor(colDef: PblNgridColumnDef<PblColumn>, elementRef: ElementRef);
    ngDoCheck(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridCellDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PblNgridCellDirective, "pbl-ngrid-cell", ["pblNgridCell"], { "rowCtx": "rowCtx"; }, {}, never>;
}
export declare class PblNgridFooterCellDirective extends CdkFooterCell implements OnInit {
    private columnDef;
    grid: PblNgridComponent;
    cellCtx: MetaCellContext;
    /** @deprecated use grid instead */
    readonly table: PblNgridComponent;
    private el;
    constructor(columnDef: PblNgridColumnDef<PblMetaColumn | PblColumnGroup>, grid: PblNgridComponent, elementRef: ElementRef);
    ngOnInit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridFooterCellDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PblNgridFooterCellDirective, "pbl-ngrid-footer-cell", ["ngridFooterCell"], {}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC5kLnRzIiwic291cmNlcyI6WyJjZWxsLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25Jbml0LCBFbGVtZW50UmVmLCBEb0NoZWNrLCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsIEVtYmVkZGVkVmlld1JlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrSGVhZGVyQ2VsbCwgQ2RrQ2VsbCwgQ2RrRm9vdGVyQ2VsbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90YWJsZSc7XG5pbXBvcnQgeyBQYmxOZ3JpZENvbXBvbmVudCB9IGZyb20gJy4uL25ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDT0xVTU4sIFBibE1ldGFDb2x1bW4sIFBibENvbHVtbiwgUGJsQ29sdW1uR3JvdXAgfSBmcm9tICcuLi9jb2x1bW5zJztcbmltcG9ydCB7IE1ldGFDZWxsQ29udGV4dCwgUGJsTmdyaWRNZXRhQ2VsbENvbnRleHQsIFBibFJvd0NvbnRleHQsIFBibENlbGxDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9pbmRleCc7XG5pbXBvcnQgeyBQYmxOZ3JpZENvbHVtbkRlZiB9IGZyb20gJy4vY29sdW1uLWRlZic7XG5pbXBvcnQgeyBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LCBQYmxOZ3JpZE11bHRpQ29tcG9uZW50UmVnaXN0cnkgfSBmcm9tICcuL3JlZ2lzdHJ5LmRpcmVjdGl2ZXMnO1xuLyoqXG4gKiBIZWFkZXIgY2VsbCBjb21wb25lbnQuXG4gKiBUaGUgaGVhZGVyIGNlbGwgY29tcG9uZW50IHdpbGwgcmVuZGVyIHRoZSBoZWFkZXIgY2VsbCB0ZW1wbGF0ZSBhbmQgYWRkIHRoZSBwcm9wZXIgY2xhc3NlcyBhbmQgcm9sZS5cbiAqXG4gKiBJdCBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgbWFuYWdpbmcgdGhlIGFueSBgZGF0YUhlYWRlckV4dGVuc2lvbnNgIHJlZ2lzdGVyZWQgaW4gdGhlIHJlZ2lzdHJ5LlxuICogVGhlc2UgZXh0ZW5zaW9ucyBhZGQgZmVhdHVyZXMgdG8gdGhlIGNlbGxzIGVpdGhlciBhcyBhIHRlbXBsYXRlIGluc3RhbmNlIG9yIGFzIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICogRXhhbXBsZXM6IFNvcnRpbmcgYmVoYXZpb3IsIGRyYWcmZHJvcC9yZXNpemUgaGFuZGxlcnMsIG1lbnVzIGV0Yy4uLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQYmxOZ3JpZEhlYWRlckNlbGxDb21wb25lbnQ8VCBleHRlbmRzIENPTFVNTiA9IENPTFVNTj4gZXh0ZW5kcyBDZGtIZWFkZXJDZWxsIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICByZWFkb25seSBjb2x1bW5EZWY6IFBibE5ncmlkQ29sdW1uRGVmPFQ+O1xuICAgIHJlYWRvbmx5IGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50PGFueT47XG4gICAgcmVhZG9ubHkgZWxlbWVudFJlZjogRWxlbWVudFJlZjtcbiAgICBwcml2YXRlIHpvbmU7XG4gICAgdmNSZWY6IFZpZXdDb250YWluZXJSZWY7XG4gICAgcHJpdmF0ZSBlbDtcbiAgICBjZWxsQ3R4OiBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0IHwgTWV0YUNlbGxDb250ZXh0O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZ3JpZCBpbnN0ZWFkICovXG4gICAgcmVhZG9ubHkgdGFibGU6IFBibE5ncmlkQ29tcG9uZW50PFQ+O1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbkRlZjogUGJsTmdyaWRDb2x1bW5EZWY8VD4sIGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50PGFueT4sIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHpvbmU6IE5nWm9uZSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgaW5pdE1haW5IZWFkZXJDb2x1bW5WaWV3KGNvbDogUGJsQ29sdW1uKTogRW1iZWRkZWRWaWV3UmVmPFBibE5ncmlkTWV0YUNlbGxDb250ZXh0PGFueSwgUGJsTWV0YUNvbHVtbiB8IFBibENvbHVtbj4+O1xuICAgIHByb3RlY3RlZCBpbml0TWV0YUhlYWRlckNvbHVtblZpZXcoY29sOiBQYmxNZXRhQ29sdW1uIHwgUGJsQ29sdW1uR3JvdXApOiBFbWJlZGRlZFZpZXdSZWY8UGJsTmdyaWRNZXRhQ2VsbENvbnRleHQ8YW55LCBQYmxNZXRhQ29sdW1uIHwgUGJsQ29sdW1uPj47XG4gICAgcHJvdGVjdGVkIHJ1bkhlYWRlckV4dGVuc2lvbnMoY29udGV4dDogUGJsTmdyaWREYXRhSGVhZGVyRXh0ZW5zaW9uQ29udGV4dCwgdmlldzogRW1iZWRkZWRWaWV3UmVmPFBibE5ncmlkTWV0YUNlbGxDb250ZXh0PGFueSwgUGJsQ29sdW1uPj4pOiB2b2lkO1xuICAgIHByb3RlY3RlZCBjcmVhdGVDb21wb25lbnQoZXh0OiBQYmxOZ3JpZE11bHRpQ29tcG9uZW50UmVnaXN0cnk8YW55LCBcImRhdGFIZWFkZXJFeHRlbnNpb25zXCI+LCBjb250ZXh0OiBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LCByb290Tm9kZXM6IGFueVtdKTogYW55W107XG59XG4vKiogQ2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGJsTmdyaWRDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrQ2VsbCBpbXBsZW1lbnRzIERvQ2hlY2sge1xuICAgIHByaXZhdGUgY29sRGVmO1xuICAgIHNldCByb3dDdHgodmFsdWU6IFBibFJvd0NvbnRleHQ8YW55Pik7XG4gICAgcHJpdmF0ZSBfcm93Q3R4O1xuICAgIGNlbGxDdHg6IFBibENlbGxDb250ZXh0IHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uIGRlZiBhbW9uZyBhbGwgY29sdW1ucyByZWdhcmRsZXNzIG9mIHZpc2liaWxpdHkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb2xJbmRleDtcbiAgICBwcml2YXRlIGVsO1xuICAgIHByaXZhdGUgZm9jdXNlZDtcbiAgICBwcml2YXRlIHNlbGVjdGVkO1xuICAgIGNvbnN0cnVjdG9yKGNvbERlZjogUGJsTmdyaWRDb2x1bW5EZWY8UGJsQ29sdW1uPiwgZWxlbWVudFJlZjogRWxlbWVudFJlZik7XG4gICAgbmdEb0NoZWNrKCk6IHZvaWQ7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQYmxOZ3JpZEZvb3RlckNlbGxEaXJlY3RpdmUgZXh0ZW5kcyBDZGtGb290ZXJDZWxsIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcml2YXRlIGNvbHVtbkRlZjtcbiAgICBncmlkOiBQYmxOZ3JpZENvbXBvbmVudDtcbiAgICBjZWxsQ3R4OiBNZXRhQ2VsbENvbnRleHQ7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBncmlkIGluc3RlYWQgKi9cbiAgICByZWFkb25seSB0YWJsZTogUGJsTmdyaWRDb21wb25lbnQ7XG4gICAgcHJpdmF0ZSBlbDtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5EZWY6IFBibE5ncmlkQ29sdW1uRGVmPFBibE1ldGFDb2x1bW4gfCBQYmxDb2x1bW5Hcm91cD4sIGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50LCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xufVxuIl19