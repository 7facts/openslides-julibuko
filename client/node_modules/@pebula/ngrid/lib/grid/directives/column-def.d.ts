import { OnDestroy, EventEmitter } from '@angular/core';
import { CdkColumnDef } from '@angular/cdk/table';
import { COLUMN } from '../columns';
import { PblNgridComponent } from '../ngrid.component';
import { PblNgridExtensionApi } from '../../ext/grid-ext-api';
import * as ɵngcc0 from '@angular/core';
export declare type UpdateWidthReason = 'attach' | 'update' | 'resize';
export declare type WidthSet = [string, string, string];
export interface WidthChangeEvent {
    reason: UpdateWidthReason;
}
/**
 * Represents a runtime column definition for a user-defined column definitions.
 *
 * User defined column definitions are `PblColumn`, `PblMetaColumn`, `PblColumnGroup` etc...
 * They represent static column definitions and `PblNgridColumnDef` is the runtime instance of them.
 *
 */
export declare class PblNgridColumnDef<T extends COLUMN = COLUMN> extends CdkColumnDef implements OnDestroy {
    protected extApi: PblNgridExtensionApi<any>;
    get column(): T;
    set column(value: T);
    /**
     * The absolute width definitions, as currently set in the DOM (getBoundingClientRect()).
     * If no measurements exists yet, return the user defined width's.
     *
     * The tuple represents them in that order, i.e: [ MIN-WIDTH, WIDTH, MAX-WIDTH ]
     */
    get widths(): WidthSet;
    /**
     * The last net width of the column.
     * The net width is the absolute width of the column, without padding, border etc...
     */
    get netWidth(): number;
    isDragging: boolean;
    /** @deprecated use grid instead */
    readonly table: PblNgridComponent<T>;
    readonly grid: PblNgridComponent<any>;
    /**
     * An event emitted when width of this column has changed.
     */
    widthChange: EventEmitter<WidthChangeEvent>;
    private _column;
    /**
     * The complete width definition for the column.
     *
     * There are 2 width sets (tuple):
     * - [0]: The source width definitions as set in static column definition instance
     * - [1]: The absolute width definitions, as currently set in the DOM (getBoundingClientRect())
     *
     * Each set is made up of 3 primitive width definitions: MIN-WIDTH, WIDTH and MAX-WIDTH.
     * The tuple represents them in that order, i.e: [ MIN-WIDTH, WIDTH, MAX-WIDTH ]
     */
    private _widths;
    /**
     * The last net width of the column.
     * The net width is the absolute width of the column, without padding, border etc...
     */
    private _netWidth;
    private widthBreakout;
    constructor(extApi: PblNgridExtensionApi<any>);
    /**
     * Update the "widths" for this column and when width has changed.
     *
     * The "widths" are the 3 values representing a width of a cell: [minWidth, width, maxWidth],
     * this method is given the width and will calculate the minWidth and maxWidth based on the column definitions.
     *
     * If at least one value of "widths" has changed, fires the `widthChange` event with the `reason` provided.
     *
     * The reason can be used to optionally update the relevant cells, based on the source (reason) of the update.
     * - attach: This runtime column definition instance was attached to a static column definition instance.
     * - update: The width value was updated in the static column definition instance , which triggered a width update to the runtime column definition instance
     * - resize: A resize event to the header PblColumn cell was triggered, the width of the static column definition is not updated, only the runtime value is.
     *
     * Note that this updates the width of the column-def instance, not the column definitions width itself.
     * Only when `reason === 'update'` it means that the column definition was updated and triggered this update
     *
     * @param width The new width
     * @param reason The reason for this change
     */
    updateWidth(width: string, reason: UpdateWidthReason): void;
    /**
     * Apply the current absolute width definitions (minWidth, width, maxWidth) onto an element.
     */
    applyWidth(element: HTMLElement): void;
    /**
     * Apply the source width definitions )set in static column definition instance) onto an element.
     */
    applySourceWidth(element: HTMLElement): void;
    /**
     * Query for cell elements related to this column definition.
     *
     * This query is not cached - cache in implementation.
     */
    queryCellElements(...filter: Array<'table' | 'header' | 'headerGroup' | 'footer' | 'footerGroup'>): HTMLElement[];
    /** @internal */
    ngOnDestroy(): void;
    onResize(): void;
    updatePin(pin?: 'start' | 'end'): void;
    private attach;
    private detach;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridColumnDef<any>, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PblNgridColumnDef<any>, "[pblNgridColumnDef]", never, { "column": "pblNgridColumnDef"; }, { "widthChange": "pblNgridColumnDefWidthChange"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLWRlZi5kLnRzIiwic291cmNlcyI6WyJjb2x1bW4tZGVmLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9uRGVzdHJveSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDZGtDb2x1bW5EZWYgfSBmcm9tICdAYW5ndWxhci9jZGsvdGFibGUnO1xuaW1wb3J0IHsgQ09MVU1OIH0gZnJvbSAnLi4vY29sdW1ucyc7XG5pbXBvcnQgeyBQYmxOZ3JpZENvbXBvbmVudCB9IGZyb20gJy4uL25ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYmxOZ3JpZEV4dGVuc2lvbkFwaSB9IGZyb20gJy4uLy4uL2V4dC9ncmlkLWV4dC1hcGknO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBVcGRhdGVXaWR0aFJlYXNvbiA9ICdhdHRhY2gnIHwgJ3VwZGF0ZScgfCAncmVzaXplJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgV2lkdGhTZXQgPSBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG5leHBvcnQgaW50ZXJmYWNlIFdpZHRoQ2hhbmdlRXZlbnQge1xuICAgIHJlYXNvbjogVXBkYXRlV2lkdGhSZWFzb247XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBydW50aW1lIGNvbHVtbiBkZWZpbml0aW9uIGZvciBhIHVzZXItZGVmaW5lZCBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gKlxuICogVXNlciBkZWZpbmVkIGNvbHVtbiBkZWZpbml0aW9ucyBhcmUgYFBibENvbHVtbmAsIGBQYmxNZXRhQ29sdW1uYCwgYFBibENvbHVtbkdyb3VwYCBldGMuLi5cbiAqIFRoZXkgcmVwcmVzZW50IHN0YXRpYyBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIGBQYmxOZ3JpZENvbHVtbkRlZmAgaXMgdGhlIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgdGhlbS5cbiAqXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFBibE5ncmlkQ29sdW1uRGVmPFQgZXh0ZW5kcyBDT0xVTU4gPSBDT0xVTU4+IGV4dGVuZHMgQ2RrQ29sdW1uRGVmIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBwcm90ZWN0ZWQgZXh0QXBpOiBQYmxOZ3JpZEV4dGVuc2lvbkFwaTxhbnk+O1xuICAgIGdldCBjb2x1bW4oKTogVDtcbiAgICBzZXQgY29sdW1uKHZhbHVlOiBUKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWJzb2x1dGUgd2lkdGggZGVmaW5pdGlvbnMsIGFzIGN1cnJlbnRseSBzZXQgaW4gdGhlIERPTSAoZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLlxuICAgICAqIElmIG5vIG1lYXN1cmVtZW50cyBleGlzdHMgeWV0LCByZXR1cm4gdGhlIHVzZXIgZGVmaW5lZCB3aWR0aCdzLlxuICAgICAqXG4gICAgICogVGhlIHR1cGxlIHJlcHJlc2VudHMgdGhlbSBpbiB0aGF0IG9yZGVyLCBpLmU6IFsgTUlOLVdJRFRILCBXSURUSCwgTUFYLVdJRFRIIF1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGhzKCk6IFdpZHRoU2V0O1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IG5ldCB3aWR0aCBvZiB0aGUgY29sdW1uLlxuICAgICAqIFRoZSBuZXQgd2lkdGggaXMgdGhlIGFic29sdXRlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHdpdGhvdXQgcGFkZGluZywgYm9yZGVyIGV0Yy4uLlxuICAgICAqL1xuICAgIGdldCBuZXRXaWR0aCgpOiBudW1iZXI7XG4gICAgaXNEcmFnZ2luZzogYm9vbGVhbjtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGdyaWQgaW5zdGVhZCAqL1xuICAgIHJlYWRvbmx5IHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxUPjtcbiAgICByZWFkb25seSBncmlkOiBQYmxOZ3JpZENvbXBvbmVudDxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB3aWR0aCBvZiB0aGlzIGNvbHVtbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICB3aWR0aENoYW5nZTogRXZlbnRFbWl0dGVyPFdpZHRoQ2hhbmdlRXZlbnQ+O1xuICAgIHByaXZhdGUgX2NvbHVtbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcGxldGUgd2lkdGggZGVmaW5pdGlvbiBmb3IgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSAyIHdpZHRoIHNldHMgKHR1cGxlKTpcbiAgICAgKiAtIFswXTogVGhlIHNvdXJjZSB3aWR0aCBkZWZpbml0aW9ucyBhcyBzZXQgaW4gc3RhdGljIGNvbHVtbiBkZWZpbml0aW9uIGluc3RhbmNlXG4gICAgICogLSBbMV06IFRoZSBhYnNvbHV0ZSB3aWR0aCBkZWZpbml0aW9ucywgYXMgY3VycmVudGx5IHNldCBpbiB0aGUgRE9NIChnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcbiAgICAgKlxuICAgICAqIEVhY2ggc2V0IGlzIG1hZGUgdXAgb2YgMyBwcmltaXRpdmUgd2lkdGggZGVmaW5pdGlvbnM6IE1JTi1XSURUSCwgV0lEVEggYW5kIE1BWC1XSURUSC5cbiAgICAgKiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGVtIGluIHRoYXQgb3JkZXIsIGkuZTogWyBNSU4tV0lEVEgsIFdJRFRILCBNQVgtV0lEVEggXVxuICAgICAqL1xuICAgIHByaXZhdGUgX3dpZHRocztcbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBuZXQgd2lkdGggb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBUaGUgbmV0IHdpZHRoIGlzIHRoZSBhYnNvbHV0ZSB3aWR0aCBvZiB0aGUgY29sdW1uLCB3aXRob3V0IHBhZGRpbmcsIGJvcmRlciBldGMuLi5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9uZXRXaWR0aDtcbiAgICBwcml2YXRlIHdpZHRoQnJlYWtvdXQ7XG4gICAgY29uc3RydWN0b3IoZXh0QXBpOiBQYmxOZ3JpZEV4dGVuc2lvbkFwaTxhbnk+KTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIFwid2lkdGhzXCIgZm9yIHRoaXMgY29sdW1uIGFuZCB3aGVuIHdpZHRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhlIFwid2lkdGhzXCIgYXJlIHRoZSAzIHZhbHVlcyByZXByZXNlbnRpbmcgYSB3aWR0aCBvZiBhIGNlbGw6IFttaW5XaWR0aCwgd2lkdGgsIG1heFdpZHRoXSxcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBnaXZlbiB0aGUgd2lkdGggYW5kIHdpbGwgY2FsY3VsYXRlIHRoZSBtaW5XaWR0aCBhbmQgbWF4V2lkdGggYmFzZWQgb24gdGhlIGNvbHVtbiBkZWZpbml0aW9ucy5cbiAgICAgKlxuICAgICAqIElmIGF0IGxlYXN0IG9uZSB2YWx1ZSBvZiBcIndpZHRoc1wiIGhhcyBjaGFuZ2VkLCBmaXJlcyB0aGUgYHdpZHRoQ2hhbmdlYCBldmVudCB3aXRoIHRoZSBgcmVhc29uYCBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSByZWFzb24gY2FuIGJlIHVzZWQgdG8gb3B0aW9uYWxseSB1cGRhdGUgdGhlIHJlbGV2YW50IGNlbGxzLCBiYXNlZCBvbiB0aGUgc291cmNlIChyZWFzb24pIG9mIHRoZSB1cGRhdGUuXG4gICAgICogLSBhdHRhY2g6IFRoaXMgcnVudGltZSBjb2x1bW4gZGVmaW5pdGlvbiBpbnN0YW5jZSB3YXMgYXR0YWNoZWQgdG8gYSBzdGF0aWMgY29sdW1uIGRlZmluaXRpb24gaW5zdGFuY2UuXG4gICAgICogLSB1cGRhdGU6IFRoZSB3aWR0aCB2YWx1ZSB3YXMgdXBkYXRlZCBpbiB0aGUgc3RhdGljIGNvbHVtbiBkZWZpbml0aW9uIGluc3RhbmNlICwgd2hpY2ggdHJpZ2dlcmVkIGEgd2lkdGggdXBkYXRlIHRvIHRoZSBydW50aW1lIGNvbHVtbiBkZWZpbml0aW9uIGluc3RhbmNlXG4gICAgICogLSByZXNpemU6IEEgcmVzaXplIGV2ZW50IHRvIHRoZSBoZWFkZXIgUGJsQ29sdW1uIGNlbGwgd2FzIHRyaWdnZXJlZCwgdGhlIHdpZHRoIG9mIHRoZSBzdGF0aWMgY29sdW1uIGRlZmluaXRpb24gaXMgbm90IHVwZGF0ZWQsIG9ubHkgdGhlIHJ1bnRpbWUgdmFsdWUgaXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB1cGRhdGVzIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLWRlZiBpbnN0YW5jZSwgbm90IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgd2lkdGggaXRzZWxmLlxuICAgICAqIE9ubHkgd2hlbiBgcmVhc29uID09PSAndXBkYXRlJ2AgaXQgbWVhbnMgdGhhdCB0aGUgY29sdW1uIGRlZmluaXRpb24gd2FzIHVwZGF0ZWQgYW5kIHRyaWdnZXJlZCB0aGlzIHVwZGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSBuZXcgd2lkdGhcbiAgICAgKiBAcGFyYW0gcmVhc29uIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlXG4gICAgICovXG4gICAgdXBkYXRlV2lkdGgod2lkdGg6IHN0cmluZywgcmVhc29uOiBVcGRhdGVXaWR0aFJlYXNvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGN1cnJlbnQgYWJzb2x1dGUgd2lkdGggZGVmaW5pdGlvbnMgKG1pbldpZHRoLCB3aWR0aCwgbWF4V2lkdGgpIG9udG8gYW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBhcHBseVdpZHRoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgc291cmNlIHdpZHRoIGRlZmluaXRpb25zIClzZXQgaW4gc3RhdGljIGNvbHVtbiBkZWZpbml0aW9uIGluc3RhbmNlKSBvbnRvIGFuIGVsZW1lbnQuXG4gICAgICovXG4gICAgYXBwbHlTb3VyY2VXaWR0aChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIGNlbGwgZWxlbWVudHMgcmVsYXRlZCB0byB0aGlzIGNvbHVtbiBkZWZpbml0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBxdWVyeSBpcyBub3QgY2FjaGVkIC0gY2FjaGUgaW4gaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgcXVlcnlDZWxsRWxlbWVudHMoLi4uZmlsdGVyOiBBcnJheTwndGFibGUnIHwgJ2hlYWRlcicgfCAnaGVhZGVyR3JvdXAnIHwgJ2Zvb3RlcicgfCAnZm9vdGVyR3JvdXAnPik6IEhUTUxFbGVtZW50W107XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgb25SZXNpemUoKTogdm9pZDtcbiAgICB1cGRhdGVQaW4ocGluPzogJ3N0YXJ0JyB8ICdlbmQnKTogdm9pZDtcbiAgICBwcml2YXRlIGF0dGFjaDtcbiAgICBwcml2YXRlIGRldGFjaDtcbn1cbiJdfQ==