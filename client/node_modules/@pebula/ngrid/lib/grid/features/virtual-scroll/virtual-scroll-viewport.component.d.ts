import { Observable } from 'rxjs';
import { AfterViewInit, ElementRef, EventEmitter, ChangeDetectorRef, NgZone, OnInit, OnDestroy } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { CdkVirtualScrollViewport, VirtualScrollStrategy, ScrollDispatcher, CdkVirtualForOf } from '@angular/cdk/scrolling';
import { PblNgridPluginController } from '../../../ext/plugin-control';
import { PblNgridConfigService } from '../../services/config';
import { PblNgridComponent } from '../../ngrid.component';
import { PblCdkVirtualScrollDirective } from './strategies';
import { NgeVirtualTableRowInfo } from './virtual-scroll-for-of';
import * as ɵngcc0 from '@angular/core';
declare module '../../services/config' {
    interface PblNgridConfig {
        virtualScroll?: {
            wheelMode?: PblCdkVirtualScrollDirective['wheelMode'];
            defaultStrategy?(): VirtualScrollStrategy;
        };
    }
}
export declare class PblCdkVirtualScrollViewportComponent extends CdkVirtualScrollViewport implements OnInit, AfterViewInit, OnDestroy {
    private cdr;
    pblScrollStrategy: VirtualScrollStrategy;
    private grid;
    get isScrolling(): boolean;
    readonly enabled: boolean;
    /**
     * Emits the offset (in pixels) of the rendered content every time it changes.
     * The emission is done OUTSIDE of angular (i.e. no change detection cycle is triggered).
     *
     * Note that when not enabled (i.e `NoVirtualScrollStrategy` is used) there are no emissions.
     */
    readonly offsetChange: Observable<number>;
    stickyRowHeaderContainer: HTMLElement;
    stickyRowFooterContainer: HTMLElement;
    /**
     * Event emitted when the scrolling state of rows in the grid changes.
     * When scrolling starts `true` is emitted and when the scrolling ends `false` is emitted.
     *
     * The grid is in "scrolling" state from the first scroll event and until 2 animation frames
     * have passed without a scroll event.
     *
     * When scrolling, the emitted value is the direction: -1 or 1
     * When not scrolling, the emitted value is 0.
     *
     * NOTE: This event runs outside the angular zone.
     */
    scrolling: EventEmitter<0 | 1 | -1>;
    /**
     * Emits an estimation of the current frame rate while scrolling, in a 500ms interval.
     *
     * The frame rate value is the average frame rate from all measurements since the scrolling began.
     * To estimate the frame rate, a significant number of measurements is required so value is emitted every 500 ms.
     * This means that a single scroll or short scroll bursts will not result in a `scrollFrameRate` emissions.
     *
     * Valid on when virtual scrolling is enabled.
     *
     * NOTE: This event runs outside the angular zone.
     *
     * In the future the measurement logic might be replaced with the Frame Timing API
     * See:
     * - https://developers.google.com/web/updates/2014/11/frame-timing-api
     * - https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver
     * - https://github.com/googlearchive/frame-timing-polyfill/wiki/Explainer
     */
    scrollFrameRate: EventEmitter<number>;
    /**
     * The `scrollHeight` of the virtual scroll viewport.
     * The `scrollHeight` is updated by the virtual scroll (update logic and frequency depends on the strategy implementation) through
     * the `setTotalContentSize(size)` method. The input size is used to position a dummy spacer element at a position that mimics the `scrollHeight`.
     *
     * In theory, the size sent to `setTotalContentSize` should equal the `scrollHeight` value, once the browser update's the layout.
     * In reality it does not happen, sometimes they are not equal. Setting a size will result in a different `scrollHeight`.
     * This might be due to changes in measurements when handling sticky meta rows (moving back and forth)
     *
     * Because the position of the dummy spacer element is set through DI the layout will run in the next micro-task after the call to `setTotalContentSize`.
     */
    scrollHeight: number;
    ngeRenderedContentSize: number;
    pblFillerHeight: string;
    get wheelMode(): PblCdkVirtualScrollDirective['wheelMode'];
    get innerWidth(): number;
    get outerWidth(): number;
    get innerHeight(): number;
    get outerHeight(): number;
    get scrollWidth(): number;
    /** A string representing the `style.width` property value to be used for the spacer element. */
    _totalContentWidth: string;
    /** A string representing the `style.height` property value to be used for the spacer element. */
    _totalContentHeight: string;
    /**
   * The transform used to scale the spacer to the same size as all content, including content that
   * is not currently rendered.
   * @deprecated
   */
    _totalContentSizeTransform: string;
    readonly _minWidth$: Observable<number>;
    private offsetChange$;
    private offset;
    private isCDPending;
    private _isScrolling;
    private wheelModeDefault;
    constructor(elementRef: ElementRef<HTMLElement>, cdr: ChangeDetectorRef, ngZone: NgZone, config: PblNgridConfigService, pblScrollStrategy: VirtualScrollStrategy, dir: Directionality, scrollDispatcher: ScrollDispatcher, pluginCtrl: PblNgridPluginController, grid: PblNgridComponent<any>);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    setTotalContentSize(size: number): void;
    checkViewportSize(): void;
    /** Measure the combined size of all of the rendered items. */
    measureRenderedContentSize(): number;
    private updateFiller;
    onSourceLengthChange(prev: number, curr: number): void;
    attach(forOf: CdkVirtualForOf<any> & NgeVirtualTableRowInfo): void;
    setRenderedContentOffset(offset: number, to?: 'to-start' | 'to-end'): void;
    /**
     * Init the scrolling watcher which track scroll events an emits `scrolling` and `scrollFrameRate` events.
     */
    private initScrollWatcher;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblCdkVirtualScrollViewportComponent, [null, null, null, null, { optional: true; }, { optional: true; }, null, null, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<PblCdkVirtualScrollViewportComponent, "pbl-cdk-virtual-scroll-viewport", never, { "stickyRowHeaderContainer": "stickyRowHeaderContainer"; "stickyRowFooterContainer": "stickyRowFooterContainer"; }, { "scrolling": "scrolling"; "scrollFrameRate": "scrollFrameRate"; }, never, [".cdk-virtual-scroll-before-content-wrapper", "*"]>;
}
declare global {
    interface CSSStyleDeclaration {
        contain: 'none' | 'strict' | 'content' | 'size' | 'layout' | 'style' | 'paint' | 'inherit' | 'initial' | 'unset';
    }
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1zY3JvbGwtdmlld3BvcnQuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBDaGFuZ2VEZXRlY3RvclJlZiwgTmdab25lLCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsIFZpcnR1YWxTY3JvbGxTdHJhdGVneSwgU2Nyb2xsRGlzcGF0Y2hlciwgQ2RrVmlydHVhbEZvck9mIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi8uLi9leHQvcGx1Z2luLWNvbnRyb2wnO1xuaW1wb3J0IHsgUGJsTmdyaWRDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29uZmlnJztcbmltcG9ydCB7IFBibE5ncmlkQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vbmdyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IFBibENka1ZpcnR1YWxTY3JvbGxEaXJlY3RpdmUgfSBmcm9tICcuL3N0cmF0ZWdpZXMnO1xuaW1wb3J0IHsgTmdlVmlydHVhbFRhYmxlUm93SW5mbyB9IGZyb20gJy4vdmlydHVhbC1zY3JvbGwtZm9yLW9mJztcbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9zZXJ2aWNlcy9jb25maWcnIHtcbiAgICBpbnRlcmZhY2UgUGJsTmdyaWRDb25maWcge1xuICAgICAgICB2aXJ0dWFsU2Nyb2xsPzoge1xuICAgICAgICAgICAgd2hlZWxNb2RlPzogUGJsQ2RrVmlydHVhbFNjcm9sbERpcmVjdGl2ZVsnd2hlZWxNb2RlJ107XG4gICAgICAgICAgICBkZWZhdWx0U3RyYXRlZ3k/KCk6IFZpcnR1YWxTY3JvbGxTdHJhdGVneTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQYmxDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRDb21wb25lbnQgZXh0ZW5kcyBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBjZHI7XG4gICAgcGJsU2Nyb2xsU3RyYXRlZ3k6IFZpcnR1YWxTY3JvbGxTdHJhdGVneTtcbiAgICBwcml2YXRlIGdyaWQ7XG4gICAgZ2V0IGlzU2Nyb2xsaW5nKCk6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgZW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB0aGUgb2Zmc2V0IChpbiBwaXhlbHMpIG9mIHRoZSByZW5kZXJlZCBjb250ZW50IGV2ZXJ5IHRpbWUgaXQgY2hhbmdlcy5cbiAgICAgKiBUaGUgZW1pc3Npb24gaXMgZG9uZSBPVVRTSURFIG9mIGFuZ3VsYXIgKGkuZS4gbm8gY2hhbmdlIGRldGVjdGlvbiBjeWNsZSBpcyB0cmlnZ2VyZWQpLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdoZW4gbm90IGVuYWJsZWQgKGkuZSBgTm9WaXJ0dWFsU2Nyb2xsU3RyYXRlZ3lgIGlzIHVzZWQpIHRoZXJlIGFyZSBubyBlbWlzc2lvbnMuXG4gICAgICovXG4gICAgcmVhZG9ubHkgb2Zmc2V0Q2hhbmdlOiBPYnNlcnZhYmxlPG51bWJlcj47XG4gICAgc3RpY2t5Um93SGVhZGVyQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBzdGlja3lSb3dGb290ZXJDb250YWluZXI6IEhUTUxFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2Nyb2xsaW5nIHN0YXRlIG9mIHJvd3MgaW4gdGhlIGdyaWQgY2hhbmdlcy5cbiAgICAgKiBXaGVuIHNjcm9sbGluZyBzdGFydHMgYHRydWVgIGlzIGVtaXR0ZWQgYW5kIHdoZW4gdGhlIHNjcm9sbGluZyBlbmRzIGBmYWxzZWAgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBncmlkIGlzIGluIFwic2Nyb2xsaW5nXCIgc3RhdGUgZnJvbSB0aGUgZmlyc3Qgc2Nyb2xsIGV2ZW50IGFuZCB1bnRpbCAyIGFuaW1hdGlvbiBmcmFtZXNcbiAgICAgKiBoYXZlIHBhc3NlZCB3aXRob3V0IGEgc2Nyb2xsIGV2ZW50LlxuICAgICAqXG4gICAgICogV2hlbiBzY3JvbGxpbmcsIHRoZSBlbWl0dGVkIHZhbHVlIGlzIHRoZSBkaXJlY3Rpb246IC0xIG9yIDFcbiAgICAgKiBXaGVuIG5vdCBzY3JvbGxpbmcsIHRoZSBlbWl0dGVkIHZhbHVlIGlzIDAuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGV2ZW50IHJ1bnMgb3V0c2lkZSB0aGUgYW5ndWxhciB6b25lLlxuICAgICAqL1xuICAgIHNjcm9sbGluZzogRXZlbnRFbWl0dGVyPDAgfCAxIHwgLTE+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGVzdGltYXRpb24gb2YgdGhlIGN1cnJlbnQgZnJhbWUgcmF0ZSB3aGlsZSBzY3JvbGxpbmcsIGluIGEgNTAwbXMgaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBUaGUgZnJhbWUgcmF0ZSB2YWx1ZSBpcyB0aGUgYXZlcmFnZSBmcmFtZSByYXRlIGZyb20gYWxsIG1lYXN1cmVtZW50cyBzaW5jZSB0aGUgc2Nyb2xsaW5nIGJlZ2FuLlxuICAgICAqIFRvIGVzdGltYXRlIHRoZSBmcmFtZSByYXRlLCBhIHNpZ25pZmljYW50IG51bWJlciBvZiBtZWFzdXJlbWVudHMgaXMgcmVxdWlyZWQgc28gdmFsdWUgaXMgZW1pdHRlZCBldmVyeSA1MDAgbXMuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGEgc2luZ2xlIHNjcm9sbCBvciBzaG9ydCBzY3JvbGwgYnVyc3RzIHdpbGwgbm90IHJlc3VsdCBpbiBhIGBzY3JvbGxGcmFtZVJhdGVgIGVtaXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFZhbGlkIG9uIHdoZW4gdmlydHVhbCBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgZXZlbnQgcnVucyBvdXRzaWRlIHRoZSBhbmd1bGFyIHpvbmUuXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZnV0dXJlIHRoZSBtZWFzdXJlbWVudCBsb2dpYyBtaWdodCBiZSByZXBsYWNlZCB3aXRoIHRoZSBGcmFtZSBUaW1pbmcgQVBJXG4gICAgICogU2VlOlxuICAgICAqIC0gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxNC8xMS9mcmFtZS10aW1pbmctYXBpXG4gICAgICogLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGVyZm9ybWFuY2VPYnNlcnZlclxuICAgICAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFyY2hpdmUvZnJhbWUtdGltaW5nLXBvbHlmaWxsL3dpa2kvRXhwbGFpbmVyXG4gICAgICovXG4gICAgc2Nyb2xsRnJhbWVSYXRlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPjtcbiAgICAvKipcbiAgICAgKiBUaGUgYHNjcm9sbEhlaWdodGAgb2YgdGhlIHZpcnR1YWwgc2Nyb2xsIHZpZXdwb3J0LlxuICAgICAqIFRoZSBgc2Nyb2xsSGVpZ2h0YCBpcyB1cGRhdGVkIGJ5IHRoZSB2aXJ0dWFsIHNjcm9sbCAodXBkYXRlIGxvZ2ljIGFuZCBmcmVxdWVuY3kgZGVwZW5kcyBvbiB0aGUgc3RyYXRlZ3kgaW1wbGVtZW50YXRpb24pIHRocm91Z2hcbiAgICAgKiB0aGUgYHNldFRvdGFsQ29udGVudFNpemUoc2l6ZSlgIG1ldGhvZC4gVGhlIGlucHV0IHNpemUgaXMgdXNlZCB0byBwb3NpdGlvbiBhIGR1bW15IHNwYWNlciBlbGVtZW50IGF0IGEgcG9zaXRpb24gdGhhdCBtaW1pY3MgdGhlIGBzY3JvbGxIZWlnaHRgLlxuICAgICAqXG4gICAgICogSW4gdGhlb3J5LCB0aGUgc2l6ZSBzZW50IHRvIGBzZXRUb3RhbENvbnRlbnRTaXplYCBzaG91bGQgZXF1YWwgdGhlIGBzY3JvbGxIZWlnaHRgIHZhbHVlLCBvbmNlIHRoZSBicm93c2VyIHVwZGF0ZSdzIHRoZSBsYXlvdXQuXG4gICAgICogSW4gcmVhbGl0eSBpdCBkb2VzIG5vdCBoYXBwZW4sIHNvbWV0aW1lcyB0aGV5IGFyZSBub3QgZXF1YWwuIFNldHRpbmcgYSBzaXplIHdpbGwgcmVzdWx0IGluIGEgZGlmZmVyZW50IGBzY3JvbGxIZWlnaHRgLlxuICAgICAqIFRoaXMgbWlnaHQgYmUgZHVlIHRvIGNoYW5nZXMgaW4gbWVhc3VyZW1lbnRzIHdoZW4gaGFuZGxpbmcgc3RpY2t5IG1ldGEgcm93cyAobW92aW5nIGJhY2sgYW5kIGZvcnRoKVxuICAgICAqXG4gICAgICogQmVjYXVzZSB0aGUgcG9zaXRpb24gb2YgdGhlIGR1bW15IHNwYWNlciBlbGVtZW50IGlzIHNldCB0aHJvdWdoIERJIHRoZSBsYXlvdXQgd2lsbCBydW4gaW4gdGhlIG5leHQgbWljcm8tdGFzayBhZnRlciB0aGUgY2FsbCB0byBgc2V0VG90YWxDb250ZW50U2l6ZWAuXG4gICAgICovXG4gICAgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gICAgbmdlUmVuZGVyZWRDb250ZW50U2l6ZTogbnVtYmVyO1xuICAgIHBibEZpbGxlckhlaWdodDogc3RyaW5nO1xuICAgIGdldCB3aGVlbE1vZGUoKTogUGJsQ2RrVmlydHVhbFNjcm9sbERpcmVjdGl2ZVsnd2hlZWxNb2RlJ107XG4gICAgZ2V0IGlubmVyV2lkdGgoKTogbnVtYmVyO1xuICAgIGdldCBvdXRlcldpZHRoKCk6IG51bWJlcjtcbiAgICBnZXQgaW5uZXJIZWlnaHQoKTogbnVtYmVyO1xuICAgIGdldCBvdXRlckhlaWdodCgpOiBudW1iZXI7XG4gICAgZ2V0IHNjcm9sbFdpZHRoKCk6IG51bWJlcjtcbiAgICAvKiogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBgc3R5bGUud2lkdGhgIHByb3BlcnR5IHZhbHVlIHRvIGJlIHVzZWQgZm9yIHRoZSBzcGFjZXIgZWxlbWVudC4gKi9cbiAgICBfdG90YWxDb250ZW50V2lkdGg6IHN0cmluZztcbiAgICAvKiogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBgc3R5bGUuaGVpZ2h0YCBwcm9wZXJ0eSB2YWx1ZSB0byBiZSB1c2VkIGZvciB0aGUgc3BhY2VyIGVsZW1lbnQuICovXG4gICAgX3RvdGFsQ29udGVudEhlaWdodDogc3RyaW5nO1xuICAgIC8qKlxuICAgKiBUaGUgdHJhbnNmb3JtIHVzZWQgdG8gc2NhbGUgdGhlIHNwYWNlciB0byB0aGUgc2FtZSBzaXplIGFzIGFsbCBjb250ZW50LCBpbmNsdWRpbmcgY29udGVudCB0aGF0XG4gICAqIGlzIG5vdCBjdXJyZW50bHkgcmVuZGVyZWQuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICAgIF90b3RhbENvbnRlbnRTaXplVHJhbnNmb3JtOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgX21pbldpZHRoJDogT2JzZXJ2YWJsZTxudW1iZXI+O1xuICAgIHByaXZhdGUgb2Zmc2V0Q2hhbmdlJDtcbiAgICBwcml2YXRlIG9mZnNldDtcbiAgICBwcml2YXRlIGlzQ0RQZW5kaW5nO1xuICAgIHByaXZhdGUgX2lzU2Nyb2xsaW5nO1xuICAgIHByaXZhdGUgd2hlZWxNb2RlRGVmYXVsdDtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgbmdab25lOiBOZ1pvbmUsIGNvbmZpZzogUGJsTmdyaWRDb25maWdTZXJ2aWNlLCBwYmxTY3JvbGxTdHJhdGVneTogVmlydHVhbFNjcm9sbFN0cmF0ZWd5LCBkaXI6IERpcmVjdGlvbmFsaXR5LCBzY3JvbGxEaXNwYXRjaGVyOiBTY3JvbGxEaXNwYXRjaGVyLCBwbHVnaW5DdHJsOiBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXIsIGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50PGFueT4pO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBzZXRUb3RhbENvbnRlbnRTaXplKHNpemU6IG51bWJlcik6IHZvaWQ7XG4gICAgY2hlY2tWaWV3cG9ydFNpemUoKTogdm9pZDtcbiAgICAvKiogTWVhc3VyZSB0aGUgY29tYmluZWQgc2l6ZSBvZiBhbGwgb2YgdGhlIHJlbmRlcmVkIGl0ZW1zLiAqL1xuICAgIG1lYXN1cmVSZW5kZXJlZENvbnRlbnRTaXplKCk6IG51bWJlcjtcbiAgICBwcml2YXRlIHVwZGF0ZUZpbGxlcjtcbiAgICBvblNvdXJjZUxlbmd0aENoYW5nZShwcmV2OiBudW1iZXIsIGN1cnI6IG51bWJlcik6IHZvaWQ7XG4gICAgYXR0YWNoKGZvck9mOiBDZGtWaXJ0dWFsRm9yT2Y8YW55PiAmIE5nZVZpcnR1YWxUYWJsZVJvd0luZm8pOiB2b2lkO1xuICAgIHNldFJlbmRlcmVkQ29udGVudE9mZnNldChvZmZzZXQ6IG51bWJlciwgdG8/OiAndG8tc3RhcnQnIHwgJ3RvLWVuZCcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIHNjcm9sbGluZyB3YXRjaGVyIHdoaWNoIHRyYWNrIHNjcm9sbCBldmVudHMgYW4gZW1pdHMgYHNjcm9sbGluZ2AgYW5kIGBzY3JvbGxGcmFtZVJhdGVgIGV2ZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRTY3JvbGxXYXRjaGVyO1xufVxuZGVjbGFyZSBnbG9iYWwge1xuICAgIGludGVyZmFjZSBDU1NTdHlsZURlY2xhcmF0aW9uIHtcbiAgICAgICAgY29udGFpbjogJ25vbmUnIHwgJ3N0cmljdCcgfCAnY29udGVudCcgfCAnc2l6ZScgfCAnbGF5b3V0JyB8ICdzdHlsZScgfCAncGFpbnQnIHwgJ2luaGVyaXQnIHwgJ2luaXRpYWwnIHwgJ3Vuc2V0JztcbiAgICB9XG59XG4iXX0=