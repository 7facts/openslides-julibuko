import { AfterViewInit, ElementRef, Injector, QueryList, AfterContentInit, OnChanges, OnDestroy, SimpleChanges, ChangeDetectorRef, TemplateRef, ViewContainerRef, EmbeddedViewRef, NgZone, IterableDiffers, DoCheck } from '@angular/core';
import { CdkHeaderRowDef, CdkFooterRowDef, CdkRowDef } from '@angular/cdk/table';
import { PblNgridExtensionApi } from '../ext/grid-ext-api';
import { PblNgridPluginController, PblNgridPluginContext } from '../ext/plugin-control';
import { PblNgridPaginatorKind } from '../paginator';
import { DataSourcePredicate, PblNgridSortDefinition, PblDataSource, DataSourceOf } from '../data-source/index';
import { PblCdkTableComponent } from './pbl-cdk-table/pbl-cdk-table.component';
import { PblColumn, PblColumnStore, PblNgridColumnSet, PblNgridColumnDefinitionSet } from './columns';
import { PblNgridCellContext, PblNgridMetaCellContext, PblNgridContextApi, PblNgridRowContext } from './context/index';
import { PblNgridRegistryService } from './services/grid-registry.service';
import { PblNgridConfigService } from './services/config';
import { DynamicColumnWidthLogic } from './col-width-logic/dynamic-column-width';
import { ColumnApi, AutoSizeToFitOptions } from './column-api';
import { PblCdkVirtualScrollViewportComponent } from './features/virtual-scroll/virtual-scroll-viewport.component';
import { PblNgridMetaRowService } from './meta-rows/index';
import './bind-to-datasource';
import * as ɵngcc0 from '@angular/core';
export declare function internalApiFactory(grid: {
    _extApi: PblNgridExtensionApi;
}): PblNgridExtensionApi<any>;
export declare function pluginControllerFactory(grid: {
    _plugin: PblNgridPluginContext;
}): PblNgridPluginController<any>;
export declare function metaRowServiceFactory(grid: {
    _extApi: PblNgridExtensionApi;
}): PblNgridMetaRowService<any>;
export declare class PblNgridComponent<T = any> implements AfterContentInit, AfterViewInit, DoCheck, OnChanges, OnDestroy {
    private elRef;
    private differs;
    private ngZone;
    private cdr;
    private config;
    registry: PblNgridRegistryService;
    readonly id: string;
    /**
     * Show/Hide the header row.
     * Default: true
     */
    get showHeader(): boolean;
    set showHeader(value: boolean);
    _showHeader: boolean;
    /**
     * Show/Hide the footer row.
     * Default: false
     */
    get showFooter(): boolean;
    set showFooter(value: boolean);
    _showFooter: boolean;
    /**
     * When true, the filler is disabled.
     */
    get noFiller(): boolean;
    set noFiller(value: boolean);
    _noFiller: boolean;
    /**
     * Set's the behavior of the grid when tabbing.
     * The default behavior is none (rows and cells are not focusable)
     *
     * Note that the focus mode has an effect on other functions, for example a detail row will toggle (open/close) using
     * ENTER / SPACE only when focusMode is set to `row`.
     */
    focusMode: 'row' | 'cell' | 'none' | '' | false | undefined;
    /**
     * @deprecated Use `pIndex` in the column definition. (Removed in 1.0.0)
     */
    get identityProp(): string;
    set identityProp(value: string);
    private __identityProp;
    /**
     * The grid's source of data
     *
     * @remarks
     * The grid's source of data, which can be provided in 2 ways:
     *
     * - DataSourceOf<T>
     * - PblDataSource<T>
     *
     * The grid only works with `PblDataSource<T>`, `DataSourceOf<T>` is a shortcut for providing
     * the data array directly.
     *
     * `DataSourceOf<T>` can be:
     *
     * - Simple data array (each object represents one grid row)
     * - Promise for a data array
     * - Stream that emits a data array each time the array changes
     *
     * When a `DataSourceOf<T>` is provided it is converted into an instance of `PblDataSource<T>`.
     *
     * To access the `PblDataSource<T>` instance use the `ds` property (readonly).
     *
     * It is highly recommended to use `PblDataSource<T>` directly, the datasource factory makes it easy.
     * For example, when an array is provided the factory is used to convert it to a datasource:
     *
     * ```typescript
     * const collection: T[] = [];
     * const pblDataSource = createDS<T>().onTrigger( () => collection ).create();
     * ```
     *
     * > This is a write-only (setter) property that triggers the `setDataSource` method.
     */
    set dataSource(value: PblDataSource<T> | DataSourceOf<T>);
    get ds(): PblDataSource<T>;
    get usePagination(): PblNgridPaginatorKind | false;
    set usePagination(value: PblNgridPaginatorKind | false);
    get noCachePaginator(): boolean;
    set noCachePaginator(value: boolean);
    /**
     * The column definitions for this grid.
     */
    columns: PblNgridColumnSet | PblNgridColumnDefinitionSet;
    set hideColumns(value: string[]);
    /**
     * A fallback height for "the inner scroll container".
     * The fallback is used only when it LOWER than the rendered height, so no empty gaps are created when setting the fallback.
     *
     * The "inner scroll container" is the area in which all data rows are rendered and all meta (header/footer) rows that are of type "row" or "sticky".
     * The "inner scroll container" is defined to consume all the height left after all external objects are rendered.
     * External objects can be fixed meta rows (header/footer), pagination row, action row etc...
     *
     * If the grid does not have a height (% or px) the "inner scroll container" will always have no height (0).
     * If the grid has a height, the "inner scroll container" will get the height left, which can also be 0 if there are a lot of external objects.
     *
     * To solve the no-height problem we use the fallbackMinHeight property.
     *
     * When virtual scroll is disabled and fallbackMinHeight is not set the grid will set the "inner scroll container" height to show all rows.
     *
     * Note that when using a fixed (px) height for the grid, if the height of all external objects + the height of the "inner scroll container" is greater then
     * the grid's height a vertical scroll bar will show.
     * If the "inner scroll container"s height will be lower then it's rendered content height and additional vertical scroll bar will appear, which is, usually, not good.
     *
     * To avoid this, don't use fallbackMinHeight together with a fixed height for the grid. Instead use fallbackMinHeight together with a min height for the grid.
     */
    get fallbackMinHeight(): number;
    set fallbackMinHeight(value: number);
    rowClassUpdate: undefined | ((context: PblNgridRowContext<T>) => (string | string[] | Set<string> | {
        [klass: string]: any;
    }));
    rowClassUpdateFreq: 'item' | 'ngDoCheck' | 'none';
    rowFocus: 0 | '';
    cellFocus: 0 | '';
    private _fallbackMinHeight;
    private _dataSource;
    _vcRefBeforeTable: ViewContainerRef;
    _vcRefBeforeContent: ViewContainerRef;
    _vcRefAfterContent: ViewContainerRef;
    _fbTableCell: TemplateRef<PblNgridCellContext<T>>;
    _fbHeaderCell: TemplateRef<PblNgridMetaCellContext<T>>;
    _fbFooterCell: TemplateRef<PblNgridMetaCellContext<T>>;
    _tableRowDef: CdkRowDef<T>;
    _headerRowDefs: QueryList<CdkHeaderRowDef>;
    _footerRowDefs: QueryList<CdkFooterRowDef>;
    get metaColumnIds(): PblColumnStore['metaColumnIds'];
    get metaColumns(): PblColumnStore['metaColumns'];
    get columnRowDef(): {
        header: import("./columns").PblMetaRowDefinitions;
        footer: import("./columns").PblMetaRowDefinitions;
    };
    /**
     * True when the component is initialized (after AfterViewInit)
     */
    readonly isInit: boolean;
    readonly columnApi: ColumnApi<T>;
    get contextApi(): PblNgridContextApi<T>;
    get viewport(): PblCdkVirtualScrollViewportComponent | undefined;
    _cdkTable: PblCdkTableComponent<T>;
    private _store;
    private _hideColumnsDirty;
    private _hideColumns;
    private _colHideDiffer;
    private _noDateEmbeddedVRef;
    private _paginatorEmbeddedVRef;
    private _pagination;
    private _noCachePaginator;
    private _minimumRowWidth;
    private _viewport?;
    private _plugin;
    private _extApi;
    constructor(injector: Injector, vcRef: ViewContainerRef, elRef: ElementRef<HTMLElement>, differs: IterableDiffers, ngZone: NgZone, cdr: ChangeDetectorRef, config: PblNgridConfigService, registry: PblNgridRegistryService, id: string);
    ngDoCheck(): void;
    ngAfterContentInit(): void;
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    trackBy(index: number, item: T): any;
    /**
     * Clear the current sort definitions.
     * This method is a proxy to `PblDataSource.setSort`, For more information see `PblDataSource.setSort`
     *
     * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.
     * default to false.
     */
    setSort(skipUpdate?: boolean): void;
    /**
     * Set the sorting definition for the current data set.
     *
     * This method is a proxy to `PblDataSource.setSort` with the added sugar of providing column by string that match the `id` or `sortAlias` properties.
     * For more information see `PblDataSource.setSort`
     *
     * @param columnOrSortAlias A column instance or a string matching `PblColumn.sortAlias` or `PblColumn.id`.
     * @param skipUpdate When true will not update the datasource, use this when the data comes sorted and you want to sync the definitions with the current data set.
     * default to false.
     */
    setSort(columnOrSortAlias: PblColumn | string, sort: PblNgridSortDefinition, skipUpdate?: boolean): void;
    /**
     * Clear the filter definition for the current data set.
     *
     * This method is a proxy to `PblDataSource.setFilter`, For more information see `PblDataSource.setFilter`.
     */
    setFilter(): void;
    /**
     * Set the filter definition for the current data set using a function predicate.
     *
    * This method is a proxy to `PblDataSource.setFilter` with the added sugar of providing column by string that match the `id` property.
     * For more information see `PblDataSource.setFilter`
     */
    setFilter(value: DataSourcePredicate, columns?: PblColumn[] | string[]): void;
    /**
     * Set the filter definition for the current data set using a value to compare with and a list of columns with the values to compare to.
     *
     * This method is a proxy to `PblDataSource.setFilter` with the added sugar of providing column by string that match the `id` property.
     * For more information see `PblDataSource.setFilter`
     */
    setFilter(value: any, columns: PblColumn[] | string[]): void;
    setDataSource(value: PblDataSource<T>): void;
    /**
     * Invalidates the header, including a full rebuild of column headers
     */
    invalidateColumns(): void;
    /**
     * Updates the column sizes for all columns in the grid based on the column definition metadata for each column.
     * The final width represent a static width, it is the value as set in the definition (except column without width, where the calculated global width is set).
     */
    resetColumnsWidth(): void;
    /**
     * Update the size of all group columns in the grid based on the size of their visible children (not hidden).
     * @param dynamicWidthLogic - Optional logic container, if not set a new one is created.
     */
    syncColumnGroupsSize(dynamicWidthLogic?: DynamicColumnWidthLogic): void;
    resizeColumns(columns?: PblColumn[]): void;
    /**
     * Create an embedded view before or after the user projected content.
     */
    createView<C>(location: 'beforeTable' | 'beforeContent' | 'afterContent', templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
    /**
     * Remove an already created embedded view.
     * @param view - The view to remove
     * @param location - The location, if not set defaults to `before`
     * @returns true when a view was removed, false when not. (did not exist in the view container for the provided location)
     */
    removeView(view: EmbeddedViewRef<any>, location: 'beforeTable' | 'beforeContent' | 'afterContent'): boolean;
    /**
     * Resize all visible columns to fit content of the grid.
     * @param forceFixedWidth - When true will resize all columns with absolute pixel values, otherwise will keep the same format as originally set (% or none)
     */
    autoSizeColumnToFit(options?: AutoSizeToFitOptions): void;
    findInitialRowHeight(): number;
    addClass(...cls: string[]): void;
    removeClass(...cls: string[]): void;
    private initPlugins;
    private listenToResize;
    private onResize;
    private initExtApi;
    private setupNoData;
    private getInternalVcRef;
    private setupPaginator;
    private attachCustomCellTemplates;
    private attachCustomHeaderCellTemplates;
    private resetHeaderRowDefs;
    private resetFooterRowDefs;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridComponent<any>, [null, null, null, null, null, null, null, null, { attribute: "id"; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<PblNgridComponent<any>, "pbl-ngrid", never, { "rowClassUpdateFreq": "rowClassUpdateFreq"; "showHeader": "showHeader"; "showFooter": "showFooter"; "noFiller": "noFiller"; "identityProp": "identityProp"; "dataSource": "dataSource"; "usePagination": "usePagination"; "noCachePaginator": "noCachePaginator"; "hideColumns": "hideColumns"; "fallbackMinHeight": "fallbackMinHeight"; "focusMode": "focusMode"; "columns": "columns"; "rowClassUpdate": "rowClassUpdate"; }, {}, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdyaWQuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbIm5ncmlkLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBJbmplY3RvciwgUXVlcnlMaXN0LCBBZnRlckNvbnRlbnRJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgU2ltcGxlQ2hhbmdlcywgQ2hhbmdlRGV0ZWN0b3JSZWYsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmLCBFbWJlZGRlZFZpZXdSZWYsIE5nWm9uZSwgSXRlcmFibGVEaWZmZXJzLCBEb0NoZWNrIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDZGtIZWFkZXJSb3dEZWYsIENka0Zvb3RlclJvd0RlZiwgQ2RrUm93RGVmIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RhYmxlJztcbmltcG9ydCB7IFBibE5ncmlkRXh0ZW5zaW9uQXBpIH0gZnJvbSAnLi4vZXh0L2dyaWQtZXh0LWFwaSc7XG5pbXBvcnQgeyBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXIsIFBibE5ncmlkUGx1Z2luQ29udGV4dCB9IGZyb20gJy4uL2V4dC9wbHVnaW4tY29udHJvbCc7XG5pbXBvcnQgeyBQYmxOZ3JpZFBhZ2luYXRvcktpbmQgfSBmcm9tICcuLi9wYWdpbmF0b3InO1xuaW1wb3J0IHsgRGF0YVNvdXJjZVByZWRpY2F0ZSwgUGJsTmdyaWRTb3J0RGVmaW5pdGlvbiwgUGJsRGF0YVNvdXJjZSwgRGF0YVNvdXJjZU9mIH0gZnJvbSAnLi4vZGF0YS1zb3VyY2UvaW5kZXgnO1xuaW1wb3J0IHsgUGJsQ2RrVGFibGVDb21wb25lbnQgfSBmcm9tICcuL3BibC1jZGstdGFibGUvcGJsLWNkay10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGJsQ29sdW1uLCBQYmxDb2x1bW5TdG9yZSwgUGJsTmdyaWRDb2x1bW5TZXQsIFBibE5ncmlkQ29sdW1uRGVmaW5pdGlvblNldCB9IGZyb20gJy4vY29sdW1ucyc7XG5pbXBvcnQgeyBQYmxOZ3JpZENlbGxDb250ZXh0LCBQYmxOZ3JpZE1ldGFDZWxsQ29udGV4dCwgUGJsTmdyaWRDb250ZXh0QXBpLCBQYmxOZ3JpZFJvd0NvbnRleHQgfSBmcm9tICcuL2NvbnRleHQvaW5kZXgnO1xuaW1wb3J0IHsgUGJsTmdyaWRSZWdpc3RyeVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2dyaWQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgeyBQYmxOZ3JpZENvbmZpZ1NlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2NvbmZpZyc7XG5pbXBvcnQgeyBEeW5hbWljQ29sdW1uV2lkdGhMb2dpYyB9IGZyb20gJy4vY29sLXdpZHRoLWxvZ2ljL2R5bmFtaWMtY29sdW1uLXdpZHRoJztcbmltcG9ydCB7IENvbHVtbkFwaSwgQXV0b1NpemVUb0ZpdE9wdGlvbnMgfSBmcm9tICcuL2NvbHVtbi1hcGknO1xuaW1wb3J0IHsgUGJsQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0Q29tcG9uZW50IH0gZnJvbSAnLi9mZWF0dXJlcy92aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbC12aWV3cG9ydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGJsTmdyaWRNZXRhUm93U2VydmljZSB9IGZyb20gJy4vbWV0YS1yb3dzL2luZGV4JztcbmltcG9ydCAnLi9iaW5kLXRvLWRhdGFzb3VyY2UnO1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaW50ZXJuYWxBcGlGYWN0b3J5KGdyaWQ6IHtcbiAgICBfZXh0QXBpOiBQYmxOZ3JpZEV4dGVuc2lvbkFwaTtcbn0pOiBQYmxOZ3JpZEV4dGVuc2lvbkFwaTxhbnk+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gcGx1Z2luQ29udHJvbGxlckZhY3RvcnkoZ3JpZDoge1xuICAgIF9wbHVnaW46IFBibE5ncmlkUGx1Z2luQ29udGV4dDtcbn0pOiBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXI8YW55PjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG1ldGFSb3dTZXJ2aWNlRmFjdG9yeShncmlkOiB7XG4gICAgX2V4dEFwaTogUGJsTmdyaWRFeHRlbnNpb25BcGk7XG59KTogUGJsTmdyaWRNZXRhUm93U2VydmljZTxhbnk+O1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGJsTmdyaWRDb21wb25lbnQ8VCA9IGFueT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBEb0NoZWNrLCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbFJlZjtcbiAgICBwcml2YXRlIGRpZmZlcnM7XG4gICAgcHJpdmF0ZSBuZ1pvbmU7XG4gICAgcHJpdmF0ZSBjZHI7XG4gICAgcHJpdmF0ZSBjb25maWc7XG4gICAgcmVnaXN0cnk6IFBibE5ncmlkUmVnaXN0cnlTZXJ2aWNlO1xuICAgIHJlYWRvbmx5IGlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2hvdy9IaWRlIHRoZSBoZWFkZXIgcm93LlxuICAgICAqIERlZmF1bHQ6IHRydWVcbiAgICAgKi9cbiAgICBnZXQgc2hvd0hlYWRlcigpOiBib29sZWFuO1xuICAgIHNldCBzaG93SGVhZGVyKHZhbHVlOiBib29sZWFuKTtcbiAgICBfc2hvd0hlYWRlcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTaG93L0hpZGUgdGhlIGZvb3RlciByb3cuXG4gICAgICogRGVmYXVsdDogZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgc2hvd0Zvb3RlcigpOiBib29sZWFuO1xuICAgIHNldCBzaG93Rm9vdGVyKHZhbHVlOiBib29sZWFuKTtcbiAgICBfc2hvd0Zvb3RlcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBmaWxsZXIgaXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgZ2V0IG5vRmlsbGVyKCk6IGJvb2xlYW47XG4gICAgc2V0IG5vRmlsbGVyKHZhbHVlOiBib29sZWFuKTtcbiAgICBfbm9GaWxsZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0J3MgdGhlIGJlaGF2aW9yIG9mIHRoZSBncmlkIHdoZW4gdGFiYmluZy5cbiAgICAgKiBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyBub25lIChyb3dzIGFuZCBjZWxscyBhcmUgbm90IGZvY3VzYWJsZSlcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZm9jdXMgbW9kZSBoYXMgYW4gZWZmZWN0IG9uIG90aGVyIGZ1bmN0aW9ucywgZm9yIGV4YW1wbGUgYSBkZXRhaWwgcm93IHdpbGwgdG9nZ2xlIChvcGVuL2Nsb3NlKSB1c2luZ1xuICAgICAqIEVOVEVSIC8gU1BBQ0Ugb25seSB3aGVuIGZvY3VzTW9kZSBpcyBzZXQgdG8gYHJvd2AuXG4gICAgICovXG4gICAgZm9jdXNNb2RlOiAncm93JyB8ICdjZWxsJyB8ICdub25lJyB8ICcnIHwgZmFsc2UgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBwSW5kZXhgIGluIHRoZSBjb2x1bW4gZGVmaW5pdGlvbi4gKFJlbW92ZWQgaW4gMS4wLjApXG4gICAgICovXG4gICAgZ2V0IGlkZW50aXR5UHJvcCgpOiBzdHJpbmc7XG4gICAgc2V0IGlkZW50aXR5UHJvcCh2YWx1ZTogc3RyaW5nKTtcbiAgICBwcml2YXRlIF9faWRlbnRpdHlQcm9wO1xuICAgIC8qKlxuICAgICAqIFRoZSBncmlkJ3Mgc291cmNlIG9mIGRhdGFcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGdyaWQncyBzb3VyY2Ugb2YgZGF0YSwgd2hpY2ggY2FuIGJlIHByb3ZpZGVkIGluIDIgd2F5czpcbiAgICAgKlxuICAgICAqIC0gRGF0YVNvdXJjZU9mPFQ+XG4gICAgICogLSBQYmxEYXRhU291cmNlPFQ+XG4gICAgICpcbiAgICAgKiBUaGUgZ3JpZCBvbmx5IHdvcmtzIHdpdGggYFBibERhdGFTb3VyY2U8VD5gLCBgRGF0YVNvdXJjZU9mPFQ+YCBpcyBhIHNob3J0Y3V0IGZvciBwcm92aWRpbmdcbiAgICAgKiB0aGUgZGF0YSBhcnJheSBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIGBEYXRhU291cmNlT2Y8VD5gIGNhbiBiZTpcbiAgICAgKlxuICAgICAqIC0gU2ltcGxlIGRhdGEgYXJyYXkgKGVhY2ggb2JqZWN0IHJlcHJlc2VudHMgb25lIGdyaWQgcm93KVxuICAgICAqIC0gUHJvbWlzZSBmb3IgYSBkYXRhIGFycmF5XG4gICAgICogLSBTdHJlYW0gdGhhdCBlbWl0cyBhIGRhdGEgYXJyYXkgZWFjaCB0aW1lIHRoZSBhcnJheSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBXaGVuIGEgYERhdGFTb3VyY2VPZjxUPmAgaXMgcHJvdmlkZWQgaXQgaXMgY29udmVydGVkIGludG8gYW4gaW5zdGFuY2Ugb2YgYFBibERhdGFTb3VyY2U8VD5gLlxuICAgICAqXG4gICAgICogVG8gYWNjZXNzIHRoZSBgUGJsRGF0YVNvdXJjZTxUPmAgaW5zdGFuY2UgdXNlIHRoZSBgZHNgIHByb3BlcnR5IChyZWFkb25seSkuXG4gICAgICpcbiAgICAgKiBJdCBpcyBoaWdobHkgcmVjb21tZW5kZWQgdG8gdXNlIGBQYmxEYXRhU291cmNlPFQ+YCBkaXJlY3RseSwgdGhlIGRhdGFzb3VyY2UgZmFjdG9yeSBtYWtlcyBpdCBlYXN5LlxuICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGFuIGFycmF5IGlzIHByb3ZpZGVkIHRoZSBmYWN0b3J5IGlzIHVzZWQgdG8gY29udmVydCBpdCB0byBhIGRhdGFzb3VyY2U6XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgY29sbGVjdGlvbjogVFtdID0gW107XG4gICAgICogY29uc3QgcGJsRGF0YVNvdXJjZSA9IGNyZWF0ZURTPFQ+KCkub25UcmlnZ2VyKCAoKSA9PiBjb2xsZWN0aW9uICkuY3JlYXRlKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiA+IFRoaXMgaXMgYSB3cml0ZS1vbmx5IChzZXR0ZXIpIHByb3BlcnR5IHRoYXQgdHJpZ2dlcnMgdGhlIGBzZXREYXRhU291cmNlYCBtZXRob2QuXG4gICAgICovXG4gICAgc2V0IGRhdGFTb3VyY2UodmFsdWU6IFBibERhdGFTb3VyY2U8VD4gfCBEYXRhU291cmNlT2Y8VD4pO1xuICAgIGdldCBkcygpOiBQYmxEYXRhU291cmNlPFQ+O1xuICAgIGdldCB1c2VQYWdpbmF0aW9uKCk6IFBibE5ncmlkUGFnaW5hdG9yS2luZCB8IGZhbHNlO1xuICAgIHNldCB1c2VQYWdpbmF0aW9uKHZhbHVlOiBQYmxOZ3JpZFBhZ2luYXRvcktpbmQgfCBmYWxzZSk7XG4gICAgZ2V0IG5vQ2FjaGVQYWdpbmF0b3IoKTogYm9vbGVhbjtcbiAgICBzZXQgbm9DYWNoZVBhZ2luYXRvcih2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbHVtbiBkZWZpbml0aW9ucyBmb3IgdGhpcyBncmlkLlxuICAgICAqL1xuICAgIGNvbHVtbnM6IFBibE5ncmlkQ29sdW1uU2V0IHwgUGJsTmdyaWRDb2x1bW5EZWZpbml0aW9uU2V0O1xuICAgIHNldCBoaWRlQ29sdW1ucyh2YWx1ZTogc3RyaW5nW10pO1xuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaGVpZ2h0IGZvciBcInRoZSBpbm5lciBzY3JvbGwgY29udGFpbmVyXCIuXG4gICAgICogVGhlIGZhbGxiYWNrIGlzIHVzZWQgb25seSB3aGVuIGl0IExPV0VSIHRoYW4gdGhlIHJlbmRlcmVkIGhlaWdodCwgc28gbm8gZW1wdHkgZ2FwcyBhcmUgY3JlYXRlZCB3aGVuIHNldHRpbmcgdGhlIGZhbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhlIFwiaW5uZXIgc2Nyb2xsIGNvbnRhaW5lclwiIGlzIHRoZSBhcmVhIGluIHdoaWNoIGFsbCBkYXRhIHJvd3MgYXJlIHJlbmRlcmVkIGFuZCBhbGwgbWV0YSAoaGVhZGVyL2Zvb3Rlcikgcm93cyB0aGF0IGFyZSBvZiB0eXBlIFwicm93XCIgb3IgXCJzdGlja3lcIi5cbiAgICAgKiBUaGUgXCJpbm5lciBzY3JvbGwgY29udGFpbmVyXCIgaXMgZGVmaW5lZCB0byBjb25zdW1lIGFsbCB0aGUgaGVpZ2h0IGxlZnQgYWZ0ZXIgYWxsIGV4dGVybmFsIG9iamVjdHMgYXJlIHJlbmRlcmVkLlxuICAgICAqIEV4dGVybmFsIG9iamVjdHMgY2FuIGJlIGZpeGVkIG1ldGEgcm93cyAoaGVhZGVyL2Zvb3RlciksIHBhZ2luYXRpb24gcm93LCBhY3Rpb24gcm93IGV0Yy4uLlxuICAgICAqXG4gICAgICogSWYgdGhlIGdyaWQgZG9lcyBub3QgaGF2ZSBhIGhlaWdodCAoJSBvciBweCkgdGhlIFwiaW5uZXIgc2Nyb2xsIGNvbnRhaW5lclwiIHdpbGwgYWx3YXlzIGhhdmUgbm8gaGVpZ2h0ICgwKS5cbiAgICAgKiBJZiB0aGUgZ3JpZCBoYXMgYSBoZWlnaHQsIHRoZSBcImlubmVyIHNjcm9sbCBjb250YWluZXJcIiB3aWxsIGdldCB0aGUgaGVpZ2h0IGxlZnQsIHdoaWNoIGNhbiBhbHNvIGJlIDAgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGV4dGVybmFsIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBUbyBzb2x2ZSB0aGUgbm8taGVpZ2h0IHByb2JsZW0gd2UgdXNlIHRoZSBmYWxsYmFja01pbkhlaWdodCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFdoZW4gdmlydHVhbCBzY3JvbGwgaXMgZGlzYWJsZWQgYW5kIGZhbGxiYWNrTWluSGVpZ2h0IGlzIG5vdCBzZXQgdGhlIGdyaWQgd2lsbCBzZXQgdGhlIFwiaW5uZXIgc2Nyb2xsIGNvbnRhaW5lclwiIGhlaWdodCB0byBzaG93IGFsbCByb3dzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdoZW4gdXNpbmcgYSBmaXhlZCAocHgpIGhlaWdodCBmb3IgdGhlIGdyaWQsIGlmIHRoZSBoZWlnaHQgb2YgYWxsIGV4dGVybmFsIG9iamVjdHMgKyB0aGUgaGVpZ2h0IG9mIHRoZSBcImlubmVyIHNjcm9sbCBjb250YWluZXJcIiBpcyBncmVhdGVyIHRoZW5cbiAgICAgKiB0aGUgZ3JpZCdzIGhlaWdodCBhIHZlcnRpY2FsIHNjcm9sbCBiYXIgd2lsbCBzaG93LlxuICAgICAqIElmIHRoZSBcImlubmVyIHNjcm9sbCBjb250YWluZXJcInMgaGVpZ2h0IHdpbGwgYmUgbG93ZXIgdGhlbiBpdCdzIHJlbmRlcmVkIGNvbnRlbnQgaGVpZ2h0IGFuZCBhZGRpdGlvbmFsIHZlcnRpY2FsIHNjcm9sbCBiYXIgd2lsbCBhcHBlYXIsIHdoaWNoIGlzLCB1c3VhbGx5LCBub3QgZ29vZC5cbiAgICAgKlxuICAgICAqIFRvIGF2b2lkIHRoaXMsIGRvbid0IHVzZSBmYWxsYmFja01pbkhlaWdodCB0b2dldGhlciB3aXRoIGEgZml4ZWQgaGVpZ2h0IGZvciB0aGUgZ3JpZC4gSW5zdGVhZCB1c2UgZmFsbGJhY2tNaW5IZWlnaHQgdG9nZXRoZXIgd2l0aCBhIG1pbiBoZWlnaHQgZm9yIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGdldCBmYWxsYmFja01pbkhlaWdodCgpOiBudW1iZXI7XG4gICAgc2V0IGZhbGxiYWNrTWluSGVpZ2h0KHZhbHVlOiBudW1iZXIpO1xuICAgIHJvd0NsYXNzVXBkYXRlOiB1bmRlZmluZWQgfCAoKGNvbnRleHQ6IFBibE5ncmlkUm93Q29udGV4dDxUPikgPT4gKHN0cmluZyB8IHN0cmluZ1tdIHwgU2V0PHN0cmluZz4gfCB7XG4gICAgICAgIFtrbGFzczogc3RyaW5nXTogYW55O1xuICAgIH0pKTtcbiAgICByb3dDbGFzc1VwZGF0ZUZyZXE6ICdpdGVtJyB8ICduZ0RvQ2hlY2snIHwgJ25vbmUnO1xuICAgIHJvd0ZvY3VzOiAwIHwgJyc7XG4gICAgY2VsbEZvY3VzOiAwIHwgJyc7XG4gICAgcHJpdmF0ZSBfZmFsbGJhY2tNaW5IZWlnaHQ7XG4gICAgcHJpdmF0ZSBfZGF0YVNvdXJjZTtcbiAgICBfdmNSZWZCZWZvcmVUYWJsZTogVmlld0NvbnRhaW5lclJlZjtcbiAgICBfdmNSZWZCZWZvcmVDb250ZW50OiBWaWV3Q29udGFpbmVyUmVmO1xuICAgIF92Y1JlZkFmdGVyQ29udGVudDogVmlld0NvbnRhaW5lclJlZjtcbiAgICBfZmJUYWJsZUNlbGw6IFRlbXBsYXRlUmVmPFBibE5ncmlkQ2VsbENvbnRleHQ8VD4+O1xuICAgIF9mYkhlYWRlckNlbGw6IFRlbXBsYXRlUmVmPFBibE5ncmlkTWV0YUNlbGxDb250ZXh0PFQ+PjtcbiAgICBfZmJGb290ZXJDZWxsOiBUZW1wbGF0ZVJlZjxQYmxOZ3JpZE1ldGFDZWxsQ29udGV4dDxUPj47XG4gICAgX3RhYmxlUm93RGVmOiBDZGtSb3dEZWY8VD47XG4gICAgX2hlYWRlclJvd0RlZnM6IFF1ZXJ5TGlzdDxDZGtIZWFkZXJSb3dEZWY+O1xuICAgIF9mb290ZXJSb3dEZWZzOiBRdWVyeUxpc3Q8Q2RrRm9vdGVyUm93RGVmPjtcbiAgICBnZXQgbWV0YUNvbHVtbklkcygpOiBQYmxDb2x1bW5TdG9yZVsnbWV0YUNvbHVtbklkcyddO1xuICAgIGdldCBtZXRhQ29sdW1ucygpOiBQYmxDb2x1bW5TdG9yZVsnbWV0YUNvbHVtbnMnXTtcbiAgICBnZXQgY29sdW1uUm93RGVmKCk6IHtcbiAgICAgICAgaGVhZGVyOiBpbXBvcnQoXCIuL2NvbHVtbnNcIikuUGJsTWV0YVJvd0RlZmluaXRpb25zO1xuICAgICAgICBmb290ZXI6IGltcG9ydChcIi4vY29sdW1uc1wiKS5QYmxNZXRhUm93RGVmaW5pdGlvbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsaXplZCAoYWZ0ZXIgQWZ0ZXJWaWV3SW5pdClcbiAgICAgKi9cbiAgICByZWFkb25seSBpc0luaXQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgY29sdW1uQXBpOiBDb2x1bW5BcGk8VD47XG4gICAgZ2V0IGNvbnRleHRBcGkoKTogUGJsTmdyaWRDb250ZXh0QXBpPFQ+O1xuICAgIGdldCB2aWV3cG9ydCgpOiBQYmxDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRDb21wb25lbnQgfCB1bmRlZmluZWQ7XG4gICAgX2Nka1RhYmxlOiBQYmxDZGtUYWJsZUNvbXBvbmVudDxUPjtcbiAgICBwcml2YXRlIF9zdG9yZTtcbiAgICBwcml2YXRlIF9oaWRlQ29sdW1uc0RpcnR5O1xuICAgIHByaXZhdGUgX2hpZGVDb2x1bW5zO1xuICAgIHByaXZhdGUgX2NvbEhpZGVEaWZmZXI7XG4gICAgcHJpdmF0ZSBfbm9EYXRlRW1iZWRkZWRWUmVmO1xuICAgIHByaXZhdGUgX3BhZ2luYXRvckVtYmVkZGVkVlJlZjtcbiAgICBwcml2YXRlIF9wYWdpbmF0aW9uO1xuICAgIHByaXZhdGUgX25vQ2FjaGVQYWdpbmF0b3I7XG4gICAgcHJpdmF0ZSBfbWluaW11bVJvd1dpZHRoO1xuICAgIHByaXZhdGUgX3ZpZXdwb3J0PztcbiAgICBwcml2YXRlIF9wbHVnaW47XG4gICAgcHJpdmF0ZSBfZXh0QXBpO1xuICAgIGNvbnN0cnVjdG9yKGluamVjdG9yOiBJbmplY3RvciwgdmNSZWY6IFZpZXdDb250YWluZXJSZWYsIGVsUmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBuZ1pvbmU6IE5nWm9uZSwgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgY29uZmlnOiBQYmxOZ3JpZENvbmZpZ1NlcnZpY2UsIHJlZ2lzdHJ5OiBQYmxOZ3JpZFJlZ2lzdHJ5U2VydmljZSwgaWQ6IHN0cmluZyk7XG4gICAgbmdEb0NoZWNrKCk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICB0cmFja0J5KGluZGV4OiBudW1iZXIsIGl0ZW06IFQpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGN1cnJlbnQgc29ydCBkZWZpbml0aW9ucy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIHByb3h5IHRvIGBQYmxEYXRhU291cmNlLnNldFNvcnRgLCBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgYFBibERhdGFTb3VyY2Uuc2V0U29ydGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBza2lwVXBkYXRlIFdoZW4gdHJ1ZSB3aWxsIG5vdCB1cGRhdGUgdGhlIGRhdGFzb3VyY2UsIHVzZSB0aGlzIHdoZW4gdGhlIGRhdGEgY29tZXMgc29ydGVkIGFuZCB5b3Ugd2FudCB0byBzeW5jIHRoZSBkZWZpbml0aW9ucyB3aXRoIHRoZSBjdXJyZW50IGRhdGEgc2V0LlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgc2V0U29ydChza2lwVXBkYXRlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb3J0aW5nIGRlZmluaXRpb24gZm9yIHRoZSBjdXJyZW50IGRhdGEgc2V0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYSBwcm94eSB0byBgUGJsRGF0YVNvdXJjZS5zZXRTb3J0YCB3aXRoIHRoZSBhZGRlZCBzdWdhciBvZiBwcm92aWRpbmcgY29sdW1uIGJ5IHN0cmluZyB0aGF0IG1hdGNoIHRoZSBgaWRgIG9yIGBzb3J0QWxpYXNgIHByb3BlcnRpZXMuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGBQYmxEYXRhU291cmNlLnNldFNvcnRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uT3JTb3J0QWxpYXMgQSBjb2x1bW4gaW5zdGFuY2Ugb3IgYSBzdHJpbmcgbWF0Y2hpbmcgYFBibENvbHVtbi5zb3J0QWxpYXNgIG9yIGBQYmxDb2x1bW4uaWRgLlxuICAgICAqIEBwYXJhbSBza2lwVXBkYXRlIFdoZW4gdHJ1ZSB3aWxsIG5vdCB1cGRhdGUgdGhlIGRhdGFzb3VyY2UsIHVzZSB0aGlzIHdoZW4gdGhlIGRhdGEgY29tZXMgc29ydGVkIGFuZCB5b3Ugd2FudCB0byBzeW5jIHRoZSBkZWZpbml0aW9ucyB3aXRoIHRoZSBjdXJyZW50IGRhdGEgc2V0LlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgc2V0U29ydChjb2x1bW5PclNvcnRBbGlhczogUGJsQ29sdW1uIHwgc3RyaW5nLCBzb3J0OiBQYmxOZ3JpZFNvcnREZWZpbml0aW9uLCBza2lwVXBkYXRlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGZpbHRlciBkZWZpbml0aW9uIGZvciB0aGUgY3VycmVudCBkYXRhIHNldC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgcHJveHkgdG8gYFBibERhdGFTb3VyY2Uuc2V0RmlsdGVyYCwgRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGBQYmxEYXRhU291cmNlLnNldEZpbHRlcmAuXG4gICAgICovXG4gICAgc2V0RmlsdGVyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWx0ZXIgZGVmaW5pdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGF0YSBzZXQgdXNpbmcgYSBmdW5jdGlvbiBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAqIFRoaXMgbWV0aG9kIGlzIGEgcHJveHkgdG8gYFBibERhdGFTb3VyY2Uuc2V0RmlsdGVyYCB3aXRoIHRoZSBhZGRlZCBzdWdhciBvZiBwcm92aWRpbmcgY29sdW1uIGJ5IHN0cmluZyB0aGF0IG1hdGNoIHRoZSBgaWRgIHByb3BlcnR5LlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBgUGJsRGF0YVNvdXJjZS5zZXRGaWx0ZXJgXG4gICAgICovXG4gICAgc2V0RmlsdGVyKHZhbHVlOiBEYXRhU291cmNlUHJlZGljYXRlLCBjb2x1bW5zPzogUGJsQ29sdW1uW10gfCBzdHJpbmdbXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWx0ZXIgZGVmaW5pdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGF0YSBzZXQgdXNpbmcgYSB2YWx1ZSB0byBjb21wYXJlIHdpdGggYW5kIGEgbGlzdCBvZiBjb2x1bW5zIHdpdGggdGhlIHZhbHVlcyB0byBjb21wYXJlIHRvLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYSBwcm94eSB0byBgUGJsRGF0YVNvdXJjZS5zZXRGaWx0ZXJgIHdpdGggdGhlIGFkZGVkIHN1Z2FyIG9mIHByb3ZpZGluZyBjb2x1bW4gYnkgc3RyaW5nIHRoYXQgbWF0Y2ggdGhlIGBpZGAgcHJvcGVydHkuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGBQYmxEYXRhU291cmNlLnNldEZpbHRlcmBcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXIodmFsdWU6IGFueSwgY29sdW1uczogUGJsQ29sdW1uW10gfCBzdHJpbmdbXSk6IHZvaWQ7XG4gICAgc2V0RGF0YVNvdXJjZSh2YWx1ZTogUGJsRGF0YVNvdXJjZTxUPik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgdGhlIGhlYWRlciwgaW5jbHVkaW5nIGEgZnVsbCByZWJ1aWxkIG9mIGNvbHVtbiBoZWFkZXJzXG4gICAgICovXG4gICAgaW52YWxpZGF0ZUNvbHVtbnMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb2x1bW4gc2l6ZXMgZm9yIGFsbCBjb2x1bW5zIGluIHRoZSBncmlkIGJhc2VkIG9uIHRoZSBjb2x1bW4gZGVmaW5pdGlvbiBtZXRhZGF0YSBmb3IgZWFjaCBjb2x1bW4uXG4gICAgICogVGhlIGZpbmFsIHdpZHRoIHJlcHJlc2VudCBhIHN0YXRpYyB3aWR0aCwgaXQgaXMgdGhlIHZhbHVlIGFzIHNldCBpbiB0aGUgZGVmaW5pdGlvbiAoZXhjZXB0IGNvbHVtbiB3aXRob3V0IHdpZHRoLCB3aGVyZSB0aGUgY2FsY3VsYXRlZCBnbG9iYWwgd2lkdGggaXMgc2V0KS5cbiAgICAgKi9cbiAgICByZXNldENvbHVtbnNXaWR0aCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiBhbGwgZ3JvdXAgY29sdW1ucyBpbiB0aGUgZ3JpZCBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGVpciB2aXNpYmxlIGNoaWxkcmVuIChub3QgaGlkZGVuKS5cbiAgICAgKiBAcGFyYW0gZHluYW1pY1dpZHRoTG9naWMgLSBPcHRpb25hbCBsb2dpYyBjb250YWluZXIsIGlmIG5vdCBzZXQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc3luY0NvbHVtbkdyb3Vwc1NpemUoZHluYW1pY1dpZHRoTG9naWM/OiBEeW5hbWljQ29sdW1uV2lkdGhMb2dpYyk6IHZvaWQ7XG4gICAgcmVzaXplQ29sdW1ucyhjb2x1bW5zPzogUGJsQ29sdW1uW10pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlbWJlZGRlZCB2aWV3IGJlZm9yZSBvciBhZnRlciB0aGUgdXNlciBwcm9qZWN0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3PEM+KGxvY2F0aW9uOiAnYmVmb3JlVGFibGUnIHwgJ2JlZm9yZUNvbnRlbnQnIHwgJ2FmdGVyQ29udGVudCcsIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxDPiwgY29udGV4dD86IEMsIGluZGV4PzogbnVtYmVyKTogRW1iZWRkZWRWaWV3UmVmPEM+O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhbHJlYWR5IGNyZWF0ZWQgZW1iZWRkZWQgdmlldy5cbiAgICAgKiBAcGFyYW0gdmlldyAtIFRoZSB2aWV3IHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiwgaWYgbm90IHNldCBkZWZhdWx0cyB0byBgYmVmb3JlYFxuICAgICAqIEByZXR1cm5zIHRydWUgd2hlbiBhIHZpZXcgd2FzIHJlbW92ZWQsIGZhbHNlIHdoZW4gbm90LiAoZGlkIG5vdCBleGlzdCBpbiB0aGUgdmlldyBjb250YWluZXIgZm9yIHRoZSBwcm92aWRlZCBsb2NhdGlvbilcbiAgICAgKi9cbiAgICByZW1vdmVWaWV3KHZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+LCBsb2NhdGlvbjogJ2JlZm9yZVRhYmxlJyB8ICdiZWZvcmVDb250ZW50JyB8ICdhZnRlckNvbnRlbnQnKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgYWxsIHZpc2libGUgY29sdW1ucyB0byBmaXQgY29udGVudCBvZiB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0gZm9yY2VGaXhlZFdpZHRoIC0gV2hlbiB0cnVlIHdpbGwgcmVzaXplIGFsbCBjb2x1bW5zIHdpdGggYWJzb2x1dGUgcGl4ZWwgdmFsdWVzLCBvdGhlcndpc2Ugd2lsbCBrZWVwIHRoZSBzYW1lIGZvcm1hdCBhcyBvcmlnaW5hbGx5IHNldCAoJSBvciBub25lKVxuICAgICAqL1xuICAgIGF1dG9TaXplQ29sdW1uVG9GaXQob3B0aW9ucz86IEF1dG9TaXplVG9GaXRPcHRpb25zKTogdm9pZDtcbiAgICBmaW5kSW5pdGlhbFJvd0hlaWdodCgpOiBudW1iZXI7XG4gICAgYWRkQ2xhc3MoLi4uY2xzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gICAgcmVtb3ZlQ2xhc3MoLi4uY2xzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBpbml0UGx1Z2lucztcbiAgICBwcml2YXRlIGxpc3RlblRvUmVzaXplO1xuICAgIHByaXZhdGUgb25SZXNpemU7XG4gICAgcHJpdmF0ZSBpbml0RXh0QXBpO1xuICAgIHByaXZhdGUgc2V0dXBOb0RhdGE7XG4gICAgcHJpdmF0ZSBnZXRJbnRlcm5hbFZjUmVmO1xuICAgIHByaXZhdGUgc2V0dXBQYWdpbmF0b3I7XG4gICAgcHJpdmF0ZSBhdHRhY2hDdXN0b21DZWxsVGVtcGxhdGVzO1xuICAgIHByaXZhdGUgYXR0YWNoQ3VzdG9tSGVhZGVyQ2VsbFRlbXBsYXRlcztcbiAgICBwcml2YXRlIHJlc2V0SGVhZGVyUm93RGVmcztcbiAgICBwcml2YXRlIHJlc2V0Rm9vdGVyUm93RGVmcztcbn1cbiJdfQ==