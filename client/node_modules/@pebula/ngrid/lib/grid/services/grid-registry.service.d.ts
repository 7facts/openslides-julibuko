import { Subject, Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { PblNgridCellDefDirective, PblNgridEditorCellDefDirective, PblNgridHeaderCellDefDirective, PblNgridFooterCellDefDirective, PblNgridMultiTemplateRegistry, PblNgridMultiComponentRegistry, PblNgridDataHeaderExtensionContext, PblNgridDataHeaderExtensionRef, PblNgridNoDataRefDirective, PblNgridPaginatorRefDirective } from '../directives';
import * as ɵngcc0 from '@angular/core';
export interface RegistryChangedEvent {
    op: 'add' | 'remove';
    type: keyof PblNgridMultiRegistryMap | keyof PblNgridSingleRegistryMap;
    value: any;
}
/**
 * A map of valid single-item value that can be registered, and their type.
 */
export interface PblNgridSingleRegistryMap {
    noData?: PblNgridNoDataRefDirective;
    paginator?: PblNgridPaginatorRefDirective;
}
/**
 * A map of valid multi-item value that can be registered, and their type (the single type, i.e. T in Array<T>)
 */
export interface PblNgridMultiRegistryMap {
    headerCell?: PblNgridHeaderCellDefDirective<any>;
    tableCell?: PblNgridCellDefDirective<any>;
    editorCell?: PblNgridEditorCellDefDirective<any>;
    footerCell?: PblNgridFooterCellDefDirective<any>;
    dataHeaderExtensions?: (PblNgridMultiTemplateRegistry<PblNgridDataHeaderExtensionContext, 'dataHeaderExtensions'> & PblNgridDataHeaderExtensionRef) | (PblNgridMultiComponentRegistry<any, 'dataHeaderExtensions'> & PblNgridDataHeaderExtensionRef);
}
/**
 * A Registry for templates of table parts.
 *
 * The registry is hierarchical, where each instance of a registry has a parent which allows cascading templates.
 * The hierarchy is manged by angular DI.
 *
 * > The root registry does not have a parent.
 *
 * Each instance of a registry (including root) is a hierarchy by itself, composed of 2 internal levels.
 * The first level (L1 below) is used for fixed templates, the second level (L2 below) is used for dynamic templates.
 *
 * - Root Registry
 *   - Child Registry
 *     - ChildOfChild Registry
 *
 * In the example above there are 3 registries: Root, Child and ChildOfChild.
 *
 * When searching for a template in `ChildOfChild` it will search in the following order (top to bottom):
 *   - ChildOfChild
 *   - Child
 *   - Root
 *
 * If a registry does not contain the template the search will move to the next one.
 */
export declare class PblNgridRegistryService implements OnDestroy {
    private _parent?;
    readonly changes: Observable<RegistryChangedEvent[]>;
    get parent(): PblNgridRegistryService | undefined;
    protected root: PblNgridRegistryService & {
        bufferedData?: RegistryChangedEvent[];
    };
    protected _multi: {
        [K in keyof PblNgridMultiRegistryMap]: Array<PblNgridMultiRegistryMap[K]>;
    };
    protected _multiDefaults: PblNgridMultiRegistryMap;
    protected _singles: PblNgridSingleRegistryMap;
    protected readonly changes$: Subject<RegistryChangedEvent[]>;
    constructor(_parent?: PblNgridRegistryService);
    getRoot(): PblNgridRegistryService;
    /**
     * Returns the registered value for the single `kind`.
     * If not found will try to search the parent.
     */
    getSingle<P extends keyof PblNgridSingleRegistryMap>(kind: P): PblNgridSingleRegistryMap[P] | undefined;
    setSingle<P extends keyof PblNgridSingleRegistryMap>(kind: P, value: PblNgridSingleRegistryMap[P] | undefined): void;
    /**
     * Returns the registered default value for the multi `kind`.
     * If not found will try to search the parent.
     */
    getMultiDefault<P extends keyof PblNgridMultiRegistryMap>(kind: P): PblNgridMultiRegistryMap[P] | undefined;
    setMultiDefault<P extends keyof PblNgridMultiRegistryMap>(kind: P, value: PblNgridMultiRegistryMap[P] | undefined): void;
    /**
     * Returns the registered values for the multi `kind`.
     * If not found WILL NOT search the parent.
     */
    getMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T): Array<PblNgridMultiRegistryMap[T]> | undefined;
    addMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T, cellDef: PblNgridMultiRegistryMap[T]): void;
    removeMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T, cellDef: PblNgridMultiRegistryMap[T]): void;
    /**
     * Iterate over all multi-registry value of the provided `kind` ascending order, starting from the last ancestor (this registry) up to
     * the root parent.
     *
     * Each time a collection for the `kind` is found the handler is invoked and then repeating the process on the parent.
     * If the `kind` does not exist the handler is not called moving on to the next parent.
     *
     * To bail out (stop the process and don't iterate to the next parent), return true from the handler.
     *
     * @returns The number of times that handler was invoked, i.e 0 means no matches.
     */
    forMulti<T extends keyof PblNgridMultiRegistryMap>(kind: T, handler: ((values: Array<PblNgridMultiRegistryMap[T]>) => boolean | void)): number;
    ngOnDestroy(): void;
    /**
     * Delay all notifications sent through `changes` and buffer then until next call to `bufferEnd()`.
     * When `bufferEnd()` is called it will flush all changes.
     *
     * > It's important to note that buffering does not freeze the registry, adding and removing templates will change the
     * registry and will effect queries. Buffering block the `changes` event stream and nothing more.
     */
    bufferStart(): void;
    bufferEnd(): void;
    private emitChanges;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridRegistryService, [{ optional: true; skipSelf: true; }]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1yZWdpc3RyeS5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImdyaWQtcmVnaXN0cnkuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGJsTmdyaWRDZWxsRGVmRGlyZWN0aXZlLCBQYmxOZ3JpZEVkaXRvckNlbGxEZWZEaXJlY3RpdmUsIFBibE5ncmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSwgUGJsTmdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlLCBQYmxOZ3JpZE11bHRpVGVtcGxhdGVSZWdpc3RyeSwgUGJsTmdyaWRNdWx0aUNvbXBvbmVudFJlZ2lzdHJ5LCBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LCBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25SZWYsIFBibE5ncmlkTm9EYXRhUmVmRGlyZWN0aXZlLCBQYmxOZ3JpZFBhZ2luYXRvclJlZkRpcmVjdGl2ZSB9IGZyb20gJy4uL2RpcmVjdGl2ZXMnO1xuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RyeUNoYW5nZWRFdmVudCB7XG4gICAgb3A6ICdhZGQnIHwgJ3JlbW92ZSc7XG4gICAgdHlwZToga2V5b2YgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwIHwga2V5b2YgUGJsTmdyaWRTaW5nbGVSZWdpc3RyeU1hcDtcbiAgICB2YWx1ZTogYW55O1xufVxuLyoqXG4gKiBBIG1hcCBvZiB2YWxpZCBzaW5nbGUtaXRlbSB2YWx1ZSB0aGF0IGNhbiBiZSByZWdpc3RlcmVkLCBhbmQgdGhlaXIgdHlwZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYmxOZ3JpZFNpbmdsZVJlZ2lzdHJ5TWFwIHtcbiAgICBub0RhdGE/OiBQYmxOZ3JpZE5vRGF0YVJlZkRpcmVjdGl2ZTtcbiAgICBwYWdpbmF0b3I/OiBQYmxOZ3JpZFBhZ2luYXRvclJlZkRpcmVjdGl2ZTtcbn1cbi8qKlxuICogQSBtYXAgb2YgdmFsaWQgbXVsdGktaXRlbSB2YWx1ZSB0aGF0IGNhbiBiZSByZWdpc3RlcmVkLCBhbmQgdGhlaXIgdHlwZSAodGhlIHNpbmdsZSB0eXBlLCBpLmUuIFQgaW4gQXJyYXk8VD4pXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwIHtcbiAgICBoZWFkZXJDZWxsPzogUGJsTmdyaWRIZWFkZXJDZWxsRGVmRGlyZWN0aXZlPGFueT47XG4gICAgdGFibGVDZWxsPzogUGJsTmdyaWRDZWxsRGVmRGlyZWN0aXZlPGFueT47XG4gICAgZWRpdG9yQ2VsbD86IFBibE5ncmlkRWRpdG9yQ2VsbERlZkRpcmVjdGl2ZTxhbnk+O1xuICAgIGZvb3RlckNlbGw/OiBQYmxOZ3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmU8YW55PjtcbiAgICBkYXRhSGVhZGVyRXh0ZW5zaW9ucz86IChQYmxOZ3JpZE11bHRpVGVtcGxhdGVSZWdpc3RyeTxQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LCAnZGF0YUhlYWRlckV4dGVuc2lvbnMnPiAmIFBibE5ncmlkRGF0YUhlYWRlckV4dGVuc2lvblJlZikgfCAoUGJsTmdyaWRNdWx0aUNvbXBvbmVudFJlZ2lzdHJ5PGFueSwgJ2RhdGFIZWFkZXJFeHRlbnNpb25zJz4gJiBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25SZWYpO1xufVxuLyoqXG4gKiBBIFJlZ2lzdHJ5IGZvciB0ZW1wbGF0ZXMgb2YgdGFibGUgcGFydHMuXG4gKlxuICogVGhlIHJlZ2lzdHJ5IGlzIGhpZXJhcmNoaWNhbCwgd2hlcmUgZWFjaCBpbnN0YW5jZSBvZiBhIHJlZ2lzdHJ5IGhhcyBhIHBhcmVudCB3aGljaCBhbGxvd3MgY2FzY2FkaW5nIHRlbXBsYXRlcy5cbiAqIFRoZSBoaWVyYXJjaHkgaXMgbWFuZ2VkIGJ5IGFuZ3VsYXIgREkuXG4gKlxuICogPiBUaGUgcm9vdCByZWdpc3RyeSBkb2VzIG5vdCBoYXZlIGEgcGFyZW50LlxuICpcbiAqIEVhY2ggaW5zdGFuY2Ugb2YgYSByZWdpc3RyeSAoaW5jbHVkaW5nIHJvb3QpIGlzIGEgaGllcmFyY2h5IGJ5IGl0c2VsZiwgY29tcG9zZWQgb2YgMiBpbnRlcm5hbCBsZXZlbHMuXG4gKiBUaGUgZmlyc3QgbGV2ZWwgKEwxIGJlbG93KSBpcyB1c2VkIGZvciBmaXhlZCB0ZW1wbGF0ZXMsIHRoZSBzZWNvbmQgbGV2ZWwgKEwyIGJlbG93KSBpcyB1c2VkIGZvciBkeW5hbWljIHRlbXBsYXRlcy5cbiAqXG4gKiAtIFJvb3QgUmVnaXN0cnlcbiAqICAgLSBDaGlsZCBSZWdpc3RyeVxuICogICAgIC0gQ2hpbGRPZkNoaWxkIFJlZ2lzdHJ5XG4gKlxuICogSW4gdGhlIGV4YW1wbGUgYWJvdmUgdGhlcmUgYXJlIDMgcmVnaXN0cmllczogUm9vdCwgQ2hpbGQgYW5kIENoaWxkT2ZDaGlsZC5cbiAqXG4gKiBXaGVuIHNlYXJjaGluZyBmb3IgYSB0ZW1wbGF0ZSBpbiBgQ2hpbGRPZkNoaWxkYCBpdCB3aWxsIHNlYXJjaCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyICh0b3AgdG8gYm90dG9tKTpcbiAqICAgLSBDaGlsZE9mQ2hpbGRcbiAqICAgLSBDaGlsZFxuICogICAtIFJvb3RcbiAqXG4gKiBJZiBhIHJlZ2lzdHJ5IGRvZXMgbm90IGNvbnRhaW4gdGhlIHRlbXBsYXRlIHRoZSBzZWFyY2ggd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IG9uZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGJsTmdyaWRSZWdpc3RyeVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX3BhcmVudD87XG4gICAgcmVhZG9ubHkgY2hhbmdlczogT2JzZXJ2YWJsZTxSZWdpc3RyeUNoYW5nZWRFdmVudFtdPjtcbiAgICBnZXQgcGFyZW50KCk6IFBibE5ncmlkUmVnaXN0cnlTZXJ2aWNlIHwgdW5kZWZpbmVkO1xuICAgIHByb3RlY3RlZCByb290OiBQYmxOZ3JpZFJlZ2lzdHJ5U2VydmljZSAmIHtcbiAgICAgICAgYnVmZmVyZWREYXRhPzogUmVnaXN0cnlDaGFuZ2VkRXZlbnRbXTtcbiAgICB9O1xuICAgIHByb3RlY3RlZCBfbXVsdGk6IHtcbiAgICAgICAgW0sgaW4ga2V5b2YgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwXTogQXJyYXk8UGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwW0tdPjtcbiAgICB9O1xuICAgIHByb3RlY3RlZCBfbXVsdGlEZWZhdWx0czogUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwO1xuICAgIHByb3RlY3RlZCBfc2luZ2xlczogUGJsTmdyaWRTaW5nbGVSZWdpc3RyeU1hcDtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgY2hhbmdlcyQ6IFN1YmplY3Q8UmVnaXN0cnlDaGFuZ2VkRXZlbnRbXT47XG4gICAgY29uc3RydWN0b3IoX3BhcmVudD86IFBibE5ncmlkUmVnaXN0cnlTZXJ2aWNlKTtcbiAgICBnZXRSb290KCk6IFBibE5ncmlkUmVnaXN0cnlTZXJ2aWNlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgdmFsdWUgZm9yIHRoZSBzaW5nbGUgYGtpbmRgLlxuICAgICAqIElmIG5vdCBmb3VuZCB3aWxsIHRyeSB0byBzZWFyY2ggdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBnZXRTaW5nbGU8UCBleHRlbmRzIGtleW9mIFBibE5ncmlkU2luZ2xlUmVnaXN0cnlNYXA+KGtpbmQ6IFApOiBQYmxOZ3JpZFNpbmdsZVJlZ2lzdHJ5TWFwW1BdIHwgdW5kZWZpbmVkO1xuICAgIHNldFNpbmdsZTxQIGV4dGVuZHMga2V5b2YgUGJsTmdyaWRTaW5nbGVSZWdpc3RyeU1hcD4oa2luZDogUCwgdmFsdWU6IFBibE5ncmlkU2luZ2xlUmVnaXN0cnlNYXBbUF0gfCB1bmRlZmluZWQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIG11bHRpIGBraW5kYC5cbiAgICAgKiBJZiBub3QgZm91bmQgd2lsbCB0cnkgdG8gc2VhcmNoIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgZ2V0TXVsdGlEZWZhdWx0PFAgZXh0ZW5kcyBrZXlvZiBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXA+KGtpbmQ6IFApOiBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXBbUF0gfCB1bmRlZmluZWQ7XG4gICAgc2V0TXVsdGlEZWZhdWx0PFAgZXh0ZW5kcyBrZXlvZiBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXA+KGtpbmQ6IFAsIHZhbHVlOiBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXBbUF0gfCB1bmRlZmluZWQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgdmFsdWVzIGZvciB0aGUgbXVsdGkgYGtpbmRgLlxuICAgICAqIElmIG5vdCBmb3VuZCBXSUxMIE5PVCBzZWFyY2ggdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBnZXRNdWx0aTxUIGV4dGVuZHMga2V5b2YgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwPihraW5kOiBUKTogQXJyYXk8UGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwW1RdPiB8IHVuZGVmaW5lZDtcbiAgICBhZGRNdWx0aTxUIGV4dGVuZHMga2V5b2YgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwPihraW5kOiBULCBjZWxsRGVmOiBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXBbVF0pOiB2b2lkO1xuICAgIHJlbW92ZU11bHRpPFQgZXh0ZW5kcyBrZXlvZiBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXA+KGtpbmQ6IFQsIGNlbGxEZWY6IFBibE5ncmlkTXVsdGlSZWdpc3RyeU1hcFtUXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIGFsbCBtdWx0aS1yZWdpc3RyeSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgYGtpbmRgIGFzY2VuZGluZyBvcmRlciwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBhbmNlc3RvciAodGhpcyByZWdpc3RyeSkgdXAgdG9cbiAgICAgKiB0aGUgcm9vdCBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBFYWNoIHRpbWUgYSBjb2xsZWN0aW9uIGZvciB0aGUgYGtpbmRgIGlzIGZvdW5kIHRoZSBoYW5kbGVyIGlzIGludm9rZWQgYW5kIHRoZW4gcmVwZWF0aW5nIHRoZSBwcm9jZXNzIG9uIHRoZSBwYXJlbnQuXG4gICAgICogSWYgdGhlIGBraW5kYCBkb2VzIG5vdCBleGlzdCB0aGUgaGFuZGxlciBpcyBub3QgY2FsbGVkIG1vdmluZyBvbiB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBUbyBiYWlsIG91dCAoc3RvcCB0aGUgcHJvY2VzcyBhbmQgZG9uJ3QgaXRlcmF0ZSB0byB0aGUgbmV4dCBwYXJlbnQpLCByZXR1cm4gdHJ1ZSBmcm9tIHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IGhhbmRsZXIgd2FzIGludm9rZWQsIGkuZSAwIG1lYW5zIG5vIG1hdGNoZXMuXG4gICAgICovXG4gICAgZm9yTXVsdGk8VCBleHRlbmRzIGtleW9mIFBibE5ncmlkTXVsdGlSZWdpc3RyeU1hcD4oa2luZDogVCwgaGFuZGxlcjogKCh2YWx1ZXM6IEFycmF5PFBibE5ncmlkTXVsdGlSZWdpc3RyeU1hcFtUXT4pID0+IGJvb2xlYW4gfCB2b2lkKSk6IG51bWJlcjtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERlbGF5IGFsbCBub3RpZmljYXRpb25zIHNlbnQgdGhyb3VnaCBgY2hhbmdlc2AgYW5kIGJ1ZmZlciB0aGVuIHVudGlsIG5leHQgY2FsbCB0byBgYnVmZmVyRW5kKClgLlxuICAgICAqIFdoZW4gYGJ1ZmZlckVuZCgpYCBpcyBjYWxsZWQgaXQgd2lsbCBmbHVzaCBhbGwgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqID4gSXQncyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IGJ1ZmZlcmluZyBkb2VzIG5vdCBmcmVlemUgdGhlIHJlZ2lzdHJ5LCBhZGRpbmcgYW5kIHJlbW92aW5nIHRlbXBsYXRlcyB3aWxsIGNoYW5nZSB0aGVcbiAgICAgKiByZWdpc3RyeSBhbmQgd2lsbCBlZmZlY3QgcXVlcmllcy4gQnVmZmVyaW5nIGJsb2NrIHRoZSBgY2hhbmdlc2AgZXZlbnQgc3RyZWFtIGFuZCBub3RoaW5nIG1vcmUuXG4gICAgICovXG4gICAgYnVmZmVyU3RhcnQoKTogdm9pZDtcbiAgICBidWZmZXJFbmQoKTogdm9pZDtcbiAgICBwcml2YXRlIGVtaXRDaGFuZ2VzO1xufVxuIl19