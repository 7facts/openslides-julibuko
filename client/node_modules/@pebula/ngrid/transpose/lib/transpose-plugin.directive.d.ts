import { OnDestroy } from '@angular/core';
import { PblNgridConfigService, PblColumnDefinition, PblNgridComponent, PblNgridPluginController } from '@pebula/ngrid';
import * as ɵngcc0 from '@angular/core';
declare module '@pebula/ngrid/lib/grid/services/config' {
    interface PblNgridConfig {
        transposePlugin?: {
            header?: Partial<PblColumnDefinition>;
            defaultCol?: Partial<PblColumnDefinition>;
            matchTemplates?: boolean;
        };
    }
}
declare module '@pebula/ngrid/lib/ext/types' {
    interface PblNgridPluginExtension {
        transpose?: PblNgridTransposePluginDirective;
    }
}
/**
 * Transpose plugin.
 *
 * This plugin will swaps around the rows and columns of the grid.
 *
 * A **regular grid** (not transposed) represents rows horizontally:
 *
 * - Each horizontal row represents an item in the collection.
 * - Each vertical column represents the same property of all rows in the collection.
 *
 * A **transposed** grid represents row vertically:
 *
 * - Each horizontal row represents the same property of all rows in the collection.
 * - Each vertical row represents an item in the collection.
 *
 * > Note that transposing a grid might not play nice with other plugins and/or features.
 * For example, using pagination with transpose make no sense.
 */
export declare class PblNgridTransposePluginDirective implements OnDestroy {
    private grid;
    private pluginCtrl;
    get transpose(): boolean;
    set transpose(value: boolean);
    /**
     * Column definitions for the new header column, this is the column the first column that
     * will display all the headers.
     *
     * This is an optional value, when not set a default column settings is used:
     *
     * ```js
     * {
     *  prop: '__transpose__',
     *  css: 'pbl-ngrid-header-cell pbl-ngrid-transposed-header-cell',
     * }
     * ```
     *
     * When set, the new column values will merge into the default definitions, overriding existing properties
     * set on the default column settings.
     *
     * > The header column behave like any other column and you can also provide define it in the `column` property on the grid.
     * When using this approach the column defined on the grid is used as is (no merging). Just make sure you use the right `prop` value for it.
     * e.g. if `header` is not set here its `__transpose__` otherwise, the actual `prop` value.
     */
    set header(value: Partial<PblColumnDefinition>);
    /**
     * Column definitions to be used as the base default definitions for the new transposed columns.
     * This is an optional value, when not set no default's are applied.
     */
    defaultCol: Partial<PblColumnDefinition>;
    /**
     * When true, will try to use the original template of the cell, i.e. the template that would have been used
     * if we did not transpose at all.
     *
     * Defaults to false.
     */
    matchTemplates: boolean;
    private enabled;
    private _header;
    private gridState;
    private columns;
    private selfColumn;
    private _removePlugin;
    constructor(grid: PblNgridComponent<any>, pluginCtrl: PblNgridPluginController, config: PblNgridConfigService);
    ngOnDestroy(): void;
    disable(updateTable: boolean): void;
    enable(refreshDataSource?: boolean): void;
    private updateState;
    private updateColumns;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridTransposePluginDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PblNgridTransposePluginDirective, "pbl-ngrid[transpose]", never, { "header": "transposeHeaderCol"; "defaultCol": "transposeDefaultCol"; "matchTemplates": "matchTemplates"; "transpose": "transpose"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNwb3NlLXBsdWdpbi5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsidHJhbnNwb3NlLXBsdWdpbi5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGJsTmdyaWRDb25maWdTZXJ2aWNlLCBQYmxDb2x1bW5EZWZpbml0aW9uLCBQYmxOZ3JpZENvbXBvbmVudCwgUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyIH0gZnJvbSAnQHBlYnVsYS9uZ3JpZCc7XG5kZWNsYXJlIG1vZHVsZSAnQHBlYnVsYS9uZ3JpZC9saWIvZ3JpZC9zZXJ2aWNlcy9jb25maWcnIHtcbiAgICBpbnRlcmZhY2UgUGJsTmdyaWRDb25maWcge1xuICAgICAgICB0cmFuc3Bvc2VQbHVnaW4/OiB7XG4gICAgICAgICAgICBoZWFkZXI/OiBQYXJ0aWFsPFBibENvbHVtbkRlZmluaXRpb24+O1xuICAgICAgICAgICAgZGVmYXVsdENvbD86IFBhcnRpYWw8UGJsQ29sdW1uRGVmaW5pdGlvbj47XG4gICAgICAgICAgICBtYXRjaFRlbXBsYXRlcz86IGJvb2xlYW47XG4gICAgICAgIH07XG4gICAgfVxufVxuZGVjbGFyZSBtb2R1bGUgJ0BwZWJ1bGEvbmdyaWQvbGliL2V4dC90eXBlcycge1xuICAgIGludGVyZmFjZSBQYmxOZ3JpZFBsdWdpbkV4dGVuc2lvbiB7XG4gICAgICAgIHRyYW5zcG9zZT86IFBibE5ncmlkVHJhbnNwb3NlUGx1Z2luRGlyZWN0aXZlO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNwb3NlIHBsdWdpbi5cbiAqXG4gKiBUaGlzIHBsdWdpbiB3aWxsIHN3YXBzIGFyb3VuZCB0aGUgcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgZ3JpZC5cbiAqXG4gKiBBICoqcmVndWxhciBncmlkKiogKG5vdCB0cmFuc3Bvc2VkKSByZXByZXNlbnRzIHJvd3MgaG9yaXpvbnRhbGx5OlxuICpcbiAqIC0gRWFjaCBob3Jpem9udGFsIHJvdyByZXByZXNlbnRzIGFuIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uXG4gKiAtIEVhY2ggdmVydGljYWwgY29sdW1uIHJlcHJlc2VudHMgdGhlIHNhbWUgcHJvcGVydHkgb2YgYWxsIHJvd3MgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQSAqKnRyYW5zcG9zZWQqKiBncmlkIHJlcHJlc2VudHMgcm93IHZlcnRpY2FsbHk6XG4gKlxuICogLSBFYWNoIGhvcml6b250YWwgcm93IHJlcHJlc2VudHMgdGhlIHNhbWUgcHJvcGVydHkgb2YgYWxsIHJvd3MgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKiAtIEVhY2ggdmVydGljYWwgcm93IHJlcHJlc2VudHMgYW4gaXRlbSBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiA+IE5vdGUgdGhhdCB0cmFuc3Bvc2luZyBhIGdyaWQgbWlnaHQgbm90IHBsYXkgbmljZSB3aXRoIG90aGVyIHBsdWdpbnMgYW5kL29yIGZlYXR1cmVzLlxuICogRm9yIGV4YW1wbGUsIHVzaW5nIHBhZ2luYXRpb24gd2l0aCB0cmFuc3Bvc2UgbWFrZSBubyBzZW5zZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGJsTmdyaWRUcmFuc3Bvc2VQbHVnaW5EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgZ3JpZDtcbiAgICBwcml2YXRlIHBsdWdpbkN0cmw7XG4gICAgZ2V0IHRyYW5zcG9zZSgpOiBib29sZWFuO1xuICAgIHNldCB0cmFuc3Bvc2UodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBkZWZpbml0aW9ucyBmb3IgdGhlIG5ldyBoZWFkZXIgY29sdW1uLCB0aGlzIGlzIHRoZSBjb2x1bW4gdGhlIGZpcnN0IGNvbHVtbiB0aGF0XG4gICAgICogd2lsbCBkaXNwbGF5IGFsbCB0aGUgaGVhZGVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIHdoZW4gbm90IHNldCBhIGRlZmF1bHQgY29sdW1uIHNldHRpbmdzIGlzIHVzZWQ6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHtcbiAgICAgKiAgcHJvcDogJ19fdHJhbnNwb3NlX18nLFxuICAgICAqICBjc3M6ICdwYmwtbmdyaWQtaGVhZGVyLWNlbGwgcGJsLW5ncmlkLXRyYW5zcG9zZWQtaGVhZGVyLWNlbGwnLFxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZW4gc2V0LCB0aGUgbmV3IGNvbHVtbiB2YWx1ZXMgd2lsbCBtZXJnZSBpbnRvIHRoZSBkZWZhdWx0IGRlZmluaXRpb25zLCBvdmVycmlkaW5nIGV4aXN0aW5nIHByb3BlcnRpZXNcbiAgICAgKiBzZXQgb24gdGhlIGRlZmF1bHQgY29sdW1uIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogPiBUaGUgaGVhZGVyIGNvbHVtbiBiZWhhdmUgbGlrZSBhbnkgb3RoZXIgY29sdW1uIGFuZCB5b3UgY2FuIGFsc28gcHJvdmlkZSBkZWZpbmUgaXQgaW4gdGhlIGBjb2x1bW5gIHByb3BlcnR5IG9uIHRoZSBncmlkLlxuICAgICAqIFdoZW4gdXNpbmcgdGhpcyBhcHByb2FjaCB0aGUgY29sdW1uIGRlZmluZWQgb24gdGhlIGdyaWQgaXMgdXNlZCBhcyBpcyAobm8gbWVyZ2luZykuIEp1c3QgbWFrZSBzdXJlIHlvdSB1c2UgdGhlIHJpZ2h0IGBwcm9wYCB2YWx1ZSBmb3IgaXQuXG4gICAgICogZS5nLiBpZiBgaGVhZGVyYCBpcyBub3Qgc2V0IGhlcmUgaXRzIGBfX3RyYW5zcG9zZV9fYCBvdGhlcndpc2UsIHRoZSBhY3R1YWwgYHByb3BgIHZhbHVlLlxuICAgICAqL1xuICAgIHNldCBoZWFkZXIodmFsdWU6IFBhcnRpYWw8UGJsQ29sdW1uRGVmaW5pdGlvbj4pO1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBkZWZpbml0aW9ucyB0byBiZSB1c2VkIGFzIHRoZSBiYXNlIGRlZmF1bHQgZGVmaW5pdGlvbnMgZm9yIHRoZSBuZXcgdHJhbnNwb3NlZCBjb2x1bW5zLlxuICAgICAqIFRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIHdoZW4gbm90IHNldCBubyBkZWZhdWx0J3MgYXJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgZGVmYXVsdENvbDogUGFydGlhbDxQYmxDb2x1bW5EZWZpbml0aW9uPjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHdpbGwgdHJ5IHRvIHVzZSB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgb2YgdGhlIGNlbGwsIGkuZS4gdGhlIHRlbXBsYXRlIHRoYXQgd291bGQgaGF2ZSBiZWVuIHVzZWRcbiAgICAgKiBpZiB3ZSBkaWQgbm90IHRyYW5zcG9zZSBhdCBhbGwuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBtYXRjaFRlbXBsYXRlczogYm9vbGVhbjtcbiAgICBwcml2YXRlIGVuYWJsZWQ7XG4gICAgcHJpdmF0ZSBfaGVhZGVyO1xuICAgIHByaXZhdGUgZ3JpZFN0YXRlO1xuICAgIHByaXZhdGUgY29sdW1ucztcbiAgICBwcml2YXRlIHNlbGZDb2x1bW47XG4gICAgcHJpdmF0ZSBfcmVtb3ZlUGx1Z2luO1xuICAgIGNvbnN0cnVjdG9yKGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50PGFueT4sIHBsdWdpbkN0cmw6IFBibE5ncmlkUGx1Z2luQ29udHJvbGxlciwgY29uZmlnOiBQYmxOZ3JpZENvbmZpZ1NlcnZpY2UpO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgZGlzYWJsZSh1cGRhdGVUYWJsZTogYm9vbGVhbik6IHZvaWQ7XG4gICAgZW5hYmxlKHJlZnJlc2hEYXRhU291cmNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHJpdmF0ZSB1cGRhdGVTdGF0ZTtcbiAgICBwcml2YXRlIHVwZGF0ZUNvbHVtbnM7XG59XG4iXX0=