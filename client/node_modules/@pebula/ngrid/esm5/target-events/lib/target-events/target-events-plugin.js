/**
 * @fileoverview added by tsickle
 * Generated from: lib/target-events/target-events-plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __assign, __decorate, __extends, __metadata, __values } from "tslib";
import { fromEvent, timer, ReplaySubject } from 'rxjs';
import { bufferWhen, debounce, map, filter, takeUntil } from 'rxjs/operators';
import { Directive, EventEmitter, Injector } from '@angular/core';
import { UnRx } from '@pebula/utils';
import { PblNgridComponent, PblNgridPluginController, PblColumn, NgridPlugin } from '@pebula/ngrid';
import { matrixRowFromRow, isRowContainer, findCellRenderIndex, findParentCell } from './utils';
import { handleFocusAndSelection } from './focus-and-selection';
/** @type {?} */
export var PLUGIN_KEY = 'targetEvents';
/**
 * @param {?} source
 * @return {?}
 */
function hasListeners(source) {
    return source.observers.length > 0;
}
/**
 * @param {?} source
 * @return {?}
 */
function findEventSource(source) {
    /** @type {?} */
    var cellTarget = findParentCell((/** @type {?} */ (source.target)));
    if (cellTarget) {
        return { type: 'cell', target: cellTarget };
    }
    else if (isRowContainer((/** @type {?} */ (source.target)))) {
        return { type: 'cell', target: (/** @type {?} */ (source.target)) };
    }
}
/**
 * @return {?}
 */
export function runOnce() {
    PblColumn.extendProperty('editable');
}
/**
 * @template T
 */
var PblNgridTargetEventsPlugin = /** @class */ (function () {
    function PblNgridTargetEventsPlugin(grid, injector, pluginCtrl) {
        var _this = this;
        this.grid = grid;
        this.injector = injector;
        this.pluginCtrl = pluginCtrl;
        this.rowClick = new EventEmitter();
        this.rowDblClick = new EventEmitter();
        this.rowEnter = new EventEmitter();
        this.rowLeave = new EventEmitter();
        this.cellClick = new EventEmitter();
        this.cellDblClick = new EventEmitter();
        this.cellEnter = new EventEmitter();
        this.cellLeave = new EventEmitter();
        this.mouseDown = new EventEmitter();
        this.mouseUp = new EventEmitter();
        this.keyUp = new EventEmitter();
        this.keyDown = new EventEmitter();
        this.destroyed = new ReplaySubject();
        this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, this);
        if (grid.isInit) {
            this.init();
        }
        else {
            /** @type {?} */
            var subscription_1 = pluginCtrl.events
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (event.kind === 'onInit') {
                    _this.init();
                    subscription_1.unsubscribe();
                    subscription_1 = undefined;
                }
            }));
        }
    }
    PblNgridTargetEventsPlugin_1 = PblNgridTargetEventsPlugin;
    Object.defineProperty(PblNgridTargetEventsPlugin.prototype, "table", {
        /** @deprecated use `gird` instead */
        get: /**
         * @deprecated use `gird` instead
         * @return {?}
         */
        function () { return this.grid; },
        enumerable: true,
        configurable: true
    });
    /**
     * @template T
     * @param {?} table
     * @param {?} injector
     * @return {?}
     */
    PblNgridTargetEventsPlugin.create = /**
     * @template T
     * @param {?} table
     * @param {?} injector
     * @return {?}
     */
    function (table, injector) {
        /** @type {?} */
        var pluginCtrl = PblNgridPluginController.find(table);
        return new PblNgridTargetEventsPlugin_1(table, injector, pluginCtrl);
    };
    /**
     * @private
     * @return {?}
     */
    PblNgridTargetEventsPlugin.prototype.init = /**
     * @private
     * @return {?}
     */
    function () {
        this.setupDomEvents();
        handleFocusAndSelection(this);
    };
    /**
     * @private
     * @return {?}
     */
    PblNgridTargetEventsPlugin.prototype.setupDomEvents = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var cdkTable = grid._cdkTable;
        /** @type {?} */
        var cdkTableElement = cdkTable['_element'];
        /** @type {?} */
        var createCellEvent = (/**
         * @template TEvent
         * @param {?} cellTarget
         * @param {?} source
         * @return {?}
         */
        function (cellTarget, source) {
            var e_1, _a;
            /** @type {?} */
            var rowTarget = cellTarget.parentElement;
            /** @type {?} */
            var matrixPoint = matrixRowFromRow(rowTarget, cdkTable._rowOutlet.viewContainer);
            if (matrixPoint) {
                /** @type {?} */
                var event_1 = (/** @type {?} */ (__assign(__assign({}, matrixPoint), { source: source, cellTarget: cellTarget, rowTarget: rowTarget })));
                if (matrixPoint.type === 'data') {
                    ((/** @type {?} */ (event_1))).row = grid.ds.renderedData[matrixPoint.rowIndex];
                }
                else if (event_1.subType === 'meta') {
                    // When multiple containers exists (fixed/sticky/row) the rowIndex we get is the one relative to the container..
                    // We need to find the rowIndex relative to the definitions:
                    var metaRowService = _this.pluginCtrl.extApi.metaRowService;
                    /** @type {?} */
                    var db = event_1.type === 'header' ? metaRowService.header : metaRowService.footer;
                    try {
                        for (var _b = __values([db.fixed, db.row, db.sticky]), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var coll = _c.value;
                            /** @type {?} */
                            var result = coll.find((/**
                             * @param {?} item
                             * @return {?}
                             */
                            function (item) { return item.el === event_1.rowTarget; }));
                            if (result) {
                                event_1.rowIndex = result.index;
                                break;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                /* `metadataFromElement()` does not provide column information nor the column itself. This will extend functionality to add the columnIndex and column.
                    The simple case is when `subType === 'data'`, in this case the column is always the data column for all types (header, data and footer)
        
                    If `subType !== 'data'` we need to get the proper column based type (type can only be `header` or `footer` at this point).
                    But that's not all, because `metadataFromElement()` does not handle `meta-group` subType we need to do it here...
                */
                event_1.colIndex = findCellRenderIndex(cellTarget);
                if (matrixPoint.subType === 'data') {
                    /** @type {?} */
                    var column = _this.grid.columnApi.findColumnAt(event_1.colIndex);
                    /** @type {?} */
                    var columnIndex = _this.grid.columnApi.indexOf(column);
                    event_1.column = column;
                    ((/** @type {?} */ (event_1))).context = _this.pluginCtrl.extApi.contextApi.getCell(event_1.rowIndex, columnIndex);
                }
                else {
                    /** @type {?} */
                    var store = _this.pluginCtrl.extApi.columnStore;
                    /** @type {?} */
                    var rowInfo = store.metaColumnIds[matrixPoint.type][event_1.rowIndex];
                    /** @type {?} */
                    var record = store.find(rowInfo.keys[event_1.colIndex]);
                    if (rowInfo.isGroup) {
                        event_1.subType = 'meta-group';
                        event_1.column = matrixPoint.type === 'header' ? record.headerGroup : record.footerGroup;
                    }
                    else {
                        event_1.column = matrixPoint.type === 'header' ? record.header : record.footer;
                    }
                }
                return event_1;
            }
        });
        /** @type {?} */
        var createRowEvent = (/**
         * @template TEvent
         * @param {?} rowTarget
         * @param {?} source
         * @param {?=} root
         * @return {?}
         */
        function (rowTarget, source, root) {
            if (root) {
                /** @type {?} */
                var event_2 = (/** @type {?} */ ({
                    source: source,
                    rowTarget: rowTarget,
                    type: root.type,
                    subType: root.subType,
                    rowIndex: root.rowIndex,
                    root: root
                }));
                if (root.type === 'data') {
                    ((/** @type {?} */ (event_2))).row = root.row;
                    ((/** @type {?} */ (event_2))).context = root.context.rowContext;
                }
                return event_2;
            }
            else {
                /** @type {?} */
                var matrixPoint = matrixRowFromRow(rowTarget, cdkTable._rowOutlet.viewContainer);
                if (matrixPoint) {
                    /** @type {?} */
                    var event_3 = (/** @type {?} */ (__assign(__assign({}, matrixPoint), { source: source, rowTarget: rowTarget })));
                    if (matrixPoint.type === 'data') {
                        ((/** @type {?} */ (event_3))).context = _this.pluginCtrl.extApi.contextApi.getRow(matrixPoint.rowIndex);
                        ((/** @type {?} */ (event_3))).row = ((/** @type {?} */ (event_3))).context.$implicit;
                    }
                    /*  If `subType !== 'data'` it can only be `meta` because `metadataFromElement()` does not handle `meta-group` subType.
                        We need to extend this missing part, we don't have columns here so we will try to infer it using the first column.
          
                        It's similar to how it's handled in cell clicks, but here we don't need to extends the column info.
                        We only need to change the `subType` when the row is a group row, getting a specific column is irrelevant.
                        We just need A column because group columns don't mix with regular meta columns.
          
                        NOTE: When subType is not 'data' the ype can only be `header` or `footer`.
                    */
                    if (matrixPoint.subType !== 'data') {
                        /** @type {?} */
                        var rowInfo = _this.pluginCtrl.extApi.columnStore.metaColumnIds[matrixPoint.type][event_3.rowIndex];
                        if (rowInfo.isGroup) {
                            event_3.subType = 'meta-group';
                        }
                    }
                    return event_3;
                }
            }
        });
        /** @type {?} */
        var lastCellEnterEvent;
        /** @type {?} */
        var lastRowEnterEvent;
        /** @type {?} */
        var emitCellLeave = (/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            if (lastCellEnterEvent) {
                /** @type {?} */
                var lastCellEnterEventTemp = lastCellEnterEvent;
                _this.cellLeave.emit(Object.assign({}, lastCellEnterEventTemp, { source: source }));
                lastCellEnterEvent = undefined;
                return lastCellEnterEventTemp;
            }
        });
        /** @type {?} */
        var emitRowLeave = (/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            if (lastRowEnterEvent) {
                /** @type {?} */
                var lastRowEnterEventTemp = lastRowEnterEvent;
                _this.rowLeave.emit(Object.assign({}, lastRowEnterEventTemp, { source: source }));
                lastRowEnterEvent = undefined;
                return lastRowEnterEventTemp;
            }
        });
        /** @type {?} */
        var processEvent = (/**
         * @template TEvent
         * @param {?} e
         * @return {?}
         */
        function (e) {
            /** @type {?} */
            var result = findEventSource(e);
            if (result) {
                if (result.type === 'cell') {
                    /** @type {?} */
                    var event_4 = createCellEvent(result.target, e);
                    if (event_4) {
                        return {
                            type: result.type,
                            event: event_4,
                            waitTime: hasListeners(_this.cellDblClick) ? 250 : 1,
                        };
                    }
                }
                else if (result.type === 'row') {
                    /** @type {?} */
                    var event_5 = createRowEvent(result.target, e);
                    if (event_5) {
                        return {
                            type: result.type,
                            event: event_5,
                            waitTime: hasListeners(_this.rowDblClick) ? 250 : 1,
                        };
                    }
                }
            }
        });
        /**
         * Split the result of processEvent into cell and row events, if type is row only row event is returned, if cell then cell is returned and row is created along side.
         * @type {?}
         */
        var splitProcessedEvent = (/**
         * @template TEvent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var cellEvent = event.type === 'cell' ? (/** @type {?} */ (event.event)) : undefined;
            /** @type {?} */
            var rowEvent = cellEvent
                ? createRowEvent(cellEvent.rowTarget, cellEvent.source, cellEvent)
                : (/** @type {?} */ (event.event));
            return { cellEvent: cellEvent, rowEvent: rowEvent };
        });
        /** @type {?} */
        var registerUpDownEvents = (/**
         * @template TEvent
         * @param {?} eventName
         * @param {?} emitter
         * @return {?}
         */
        function (eventName, emitter) {
            fromEvent(cdkTableElement, eventName)
                .pipe(takeUntil(_this.destroyed), filter((/**
             * @param {?} source
             * @return {?}
             */
            function (source) { return hasListeners(emitter); })), map(processEvent), filter((/**
             * @param {?} result
             * @return {?}
             */
            function (result) { return !!result; })))
                .subscribe((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                var _a = splitProcessedEvent(result), cellEvent = _a.cellEvent, rowEvent = _a.rowEvent;
                emitter.emit(cellEvent || rowEvent);
                _this.syncRow(cellEvent || rowEvent);
            }));
        });
        registerUpDownEvents('mouseup', this.mouseUp);
        registerUpDownEvents('mousedown', this.mouseDown);
        registerUpDownEvents('keyup', this.keyUp);
        registerUpDownEvents('keydown', this.keyDown);
        /*
              Handling click stream for both click and double click events.
              We want to detect double clicks and clicks with minimal delays
              We check if a double click has listeners, if not we won't delay the click...
              TODO: on double click, don't wait the whole 250 ms if 2 clicks happen.
            */
        /** @type {?} */
        var clickStream = fromEvent(cdkTableElement, 'click').pipe(takeUntil(this.destroyed), filter((/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return hasListeners(_this.cellClick) || hasListeners(_this.cellDblClick) || hasListeners(_this.rowClick) || hasListeners(_this.rowDblClick); })), map(processEvent), filter((/**
         * @param {?} result
         * @return {?}
         */
        function (result) { return !!result; })));
        clickStream
            .pipe(bufferWhen((/**
         * @return {?}
         */
        function () { return clickStream.pipe(debounce((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return timer(e.waitTime); }))); })), filter((/**
         * @param {?} events
         * @return {?}
         */
        function (events) { return events.length > 0; })))
            .subscribe((/**
         * @param {?} events
         * @return {?}
         */
        function (events) {
            /** @type {?} */
            var event = events.shift();
            /** @type {?} */
            var isDoubleClick = events.length === 1;
            // if we have 2 events its double click, otherwise single.
            var _a = splitProcessedEvent(event), cellEvent = _a.cellEvent, rowEvent = _a.rowEvent;
            if (isDoubleClick) {
                if (cellEvent) {
                    _this.cellDblClick.emit(cellEvent);
                }
                _this.rowDblClick.emit(rowEvent);
            }
            else {
                if (cellEvent) {
                    _this.cellClick.emit(cellEvent);
                }
                _this.rowClick.emit(rowEvent);
            }
            _this.syncRow(cellEvent || rowEvent);
        }));
        fromEvent(cdkTableElement, 'mouseleave')
            .pipe(takeUntil(this.destroyed))
            .subscribe((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            /** @type {?} */
            var lastEvent = emitCellLeave(source);
            lastEvent = emitRowLeave(source) || lastEvent;
            if (lastEvent) {
                _this.syncRow(lastEvent);
            }
        }));
        fromEvent(cdkTableElement, 'mousemove')
            .pipe(takeUntil(this.destroyed))
            .subscribe((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            /** @type {?} */
            var cellTarget = findParentCell((/** @type {?} */ (source.target)));
            /** @type {?} */
            var lastCellTarget = lastCellEnterEvent && lastCellEnterEvent.cellTarget;
            /** @type {?} */
            var lastRowTarget = lastRowEnterEvent && lastRowEnterEvent.rowTarget;
            /** @type {?} */
            var cellEvent;
            /** @type {?} */
            var lastEvent;
            if (lastCellTarget !== cellTarget) {
                lastEvent = emitCellLeave(source) || lastEvent;
            }
            if (cellTarget) {
                if (lastCellTarget !== cellTarget) {
                    cellEvent = createCellEvent(cellTarget, source);
                    if (cellEvent) {
                        _this.cellEnter.emit(lastCellEnterEvent = cellEvent);
                    }
                }
                else {
                    return;
                }
            }
            /** @type {?} */
            var rowTarget = (cellEvent && cellEvent.rowTarget) || (isRowContainer((/** @type {?} */ (source.target))) && (/** @type {?} */ (source.target)));
            if (lastRowTarget !== rowTarget) {
                lastEvent = emitRowLeave(source) || lastEvent;
            }
            if (rowTarget) {
                if (lastRowTarget !== rowTarget) {
                    /** @type {?} */
                    var rowEvent = createRowEvent(rowTarget, source, cellEvent);
                    if (rowEvent) {
                        _this.rowEnter.emit(lastRowEnterEvent = rowEvent);
                    }
                }
            }
            if (lastEvent) {
                _this.syncRow(lastEvent);
            }
        }));
    };
    /**
     * @return {?}
     */
    PblNgridTargetEventsPlugin.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.destroyed.next();
        this.destroyed.complete();
        this._removePlugin(this.grid);
    };
    /**
     * @private
     * @template TEvent
     * @param {?} event
     * @return {?}
     */
    PblNgridTargetEventsPlugin.prototype.syncRow = /**
     * @private
     * @template TEvent
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.grid._cdkTable.syncRows(event.type, event.rowIndex);
    };
    var PblNgridTargetEventsPlugin_1;
    /**
     * @template T
     */
    PblNgridTargetEventsPlugin = PblNgridTargetEventsPlugin_1 = __decorate([
        NgridPlugin({ id: PLUGIN_KEY, factory: 'create', runOnce: runOnce }),
        __metadata("design:paramtypes", [PblNgridComponent,
            Injector,
            PblNgridPluginController])
    ], PblNgridTargetEventsPlugin);
    return PblNgridTargetEventsPlugin;
}());
export { PblNgridTargetEventsPlugin };
if (false) {
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.rowClick;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.rowDblClick;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.rowEnter;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.rowLeave;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.cellClick;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.cellDblClick;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.cellEnter;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.cellLeave;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.mouseDown;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.mouseUp;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.keyUp;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.keyDown;
    /**
     * @type {?}
     * @protected
     */
    PblNgridTargetEventsPlugin.prototype.destroyed;
    /**
     * @type {?}
     * @private
     */
    PblNgridTargetEventsPlugin.prototype._removePlugin;
    /** @type {?} */
    PblNgridTargetEventsPlugin.prototype.grid;
    /**
     * @type {?}
     * @protected
     */
    PblNgridTargetEventsPlugin.prototype.injector;
    /**
     * @type {?}
     * @protected
     */
    PblNgridTargetEventsPlugin.prototype.pluginCtrl;
}
/**
 * @template T
 */
var PblNgridTargetEventsPluginDirective = /** @class */ (function (_super) {
    __extends(PblNgridTargetEventsPluginDirective, _super);
    function PblNgridTargetEventsPluginDirective(table, injector, pluginCtrl) {
        return _super.call(this, table, injector, pluginCtrl) || this;
    }
    /**
     * @return {?}
     */
    PblNgridTargetEventsPluginDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    PblNgridTargetEventsPluginDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'pbl-ngrid[targetEvents], pbl-ngrid[rowClick], pbl-ngrid[rowDblClick], pbl-ngrid[rowEnter], pbl-ngrid[rowLeave], pbl-ngrid[cellClick], pbl-ngrid[cellDblClick], pbl-ngrid[cellEnter], pbl-ngrid[cellLeave], pbl-ngrid[keyDown], pbl-ngrid[keyUp]',
                    // tslint:disable-next-line:use-output-property-decorator
                    outputs: ['rowClick', 'rowDblClick', 'rowEnter', 'rowLeave', 'cellClick', 'cellDblClick', 'cellEnter', 'cellLeave', 'keyDown', 'keyUp']
                },] }
    ];
    /** @nocollapse */
    PblNgridTargetEventsPluginDirective.ctorParameters = function () { return [
        { type: PblNgridComponent },
        { type: Injector },
        { type: PblNgridPluginController }
    ]; };
    /**
     * @template T
     */
    PblNgridTargetEventsPluginDirective = __decorate([
        UnRx(),
        __metadata("design:paramtypes", [PblNgridComponent, Injector, PblNgridPluginController])
    ], PblNgridTargetEventsPluginDirective);
    return PblNgridTargetEventsPluginDirective;
}(PblNgridTargetEventsPlugin));
export { PblNgridTargetEventsPluginDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LWV2ZW50cy1wbHVnaW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcGVidWxhL25ncmlkL3RhcmdldC1ldmVudHMvIiwic291cmNlcyI6WyJsaWIvdGFyZ2V0LWV2ZW50cy90YXJnZXQtZXZlbnRzLXBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBWSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBZ0MsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWhHLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLHdCQUF3QixFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHcEcsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxtQkFBbUIsRUFBRSxjQUFjLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDaEcsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7O0FBb0JoRSxNQUFNLEtBQU8sVUFBVSxHQUFtQixjQUFjOzs7OztBQUV4RCxTQUFTLFlBQVksQ0FBQyxNQUFzQztJQUMxRCxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNyQyxDQUFDOzs7OztBQUVELFNBQVMsZUFBZSxDQUFDLE1BQWE7O1FBQzlCLFVBQVUsR0FBRyxjQUFjLENBQUMsbUJBQUEsTUFBTSxDQUFDLE1BQU0sRUFBTyxDQUFDO0lBQ3ZELElBQUksVUFBVSxFQUFFO1FBQ2QsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFF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QVMsU0FBQzs7b0JBRVQsUUFBUSxFQUFFLGlQQUFpUDs7b0JBRTNQLE9BQU8sRUFBRSxDQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBRTtpQkFDMUk7Ozs7Z0JBNVhRLGlCQUFpQjtnQkFIc0MsUUFBUTtnQkFHNUMsd0JBQXdCOzs7OztJQThYdkMsbUNBQW1DO1FBRC9DLElBQUksRUFBRTt5Q0FHYyxpQkFBaUIsRUFBaUIsUUFBUSxFQUFjLHdCQUF3QjtPQUZ4RixtQ0FBbUMsQ0FVL0M7SUFBRCwwQ0FBQztDQUFBLENBVjJELDBCQUEwQixHQVVyRjtTQVZZLG1DQUFtQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyb21FdmVudCwgdGltZXIsIE9ic2VydmVyLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBidWZmZXJXaGVuLCBkZWJvdW5jZSwgbWFwLCBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIENoYW5nZURldGVjdG9yUmVmLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBVblJ4IH0gZnJvbSAnQHBlYnVsYS91dGlscyc7XG5pbXBvcnQgeyBQYmxOZ3JpZENvbXBvbmVudCwgUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyLCBQYmxDb2x1bW4sIE5ncmlkUGx1Z2luIH0gZnJvbSAnQHBlYnVsYS9uZ3JpZCc7XG5cbmltcG9ydCAqIGFzIEV2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgeyBtYXRyaXhSb3dGcm9tUm93LCBpc1Jvd0NvbnRhaW5lciwgZmluZENlbGxSZW5kZXJJbmRleCwgZmluZFBhcmVudENlbGwgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGhhbmRsZUZvY3VzQW5kU2VsZWN0aW9uIH0gZnJvbSAnLi9mb2N1cy1hbmQtc2VsZWN0aW9uJztcblxuZGVjbGFyZSBtb2R1bGUgJ0BwZWJ1bGEvbmdyaWQvbGliL2dyaWQvc2VydmljZXMvY29uZmlnJyB7XG4gIGludGVyZmFjZSBQYmxOZ3JpZENvbmZpZyB7XG4gICAgdGFyZ2V0RXZlbnRzPzoge1xuICAgICAgLyoqIFdoZW4gc2V0IHRvIHRydWUgd2lsbCBlbmFibGUgdGhlIHRhcmdldCBldmVudHMgcGx1Z2luIG9uIGFsbCB0YWJsZSBpbnN0YW5jZXMgYnkgZGVmYXVsdC4gKi9cbiAgICAgIGF1dG9FbmFibGU/OiBib29sZWFuO1xuICAgIH07XG4gIH1cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0BwZWJ1bGEvbmdyaWQvbGliL2V4dC90eXBlcycge1xuICBpbnRlcmZhY2UgUGJsTmdyaWRQbHVnaW5FeHRlbnNpb24ge1xuICAgIHRhcmdldEV2ZW50cz86IFBibE5ncmlkVGFyZ2V0RXZlbnRzUGx1Z2luO1xuICB9XG4gIGludGVyZmFjZSBQYmxOZ3JpZFBsdWdpbkV4dGVuc2lvbkZhY3RvcmllcyB7XG4gICAgdGFyZ2V0RXZlbnRzOiBrZXlvZiB0eXBlb2YgUGJsTmdyaWRUYXJnZXRFdmVudHNQbHVnaW47XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBMVUdJTl9LRVk6ICd0YXJnZXRFdmVudHMnID0gJ3RhcmdldEV2ZW50cyc7XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyhzb3VyY2U6IHsgb2JzZXJ2ZXJzOiBPYnNlcnZlcjxhbnk+W10gfSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc291cmNlLm9ic2VydmVycy5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBmaW5kRXZlbnRTb3VyY2Uoc291cmNlOiBFdmVudCk6IHsgdHlwZTogJ3JvdycgfCAnY2VsbCcsIHRhcmdldDogSFRNTEVsZW1lbnQgfSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGNlbGxUYXJnZXQgPSBmaW5kUGFyZW50Q2VsbChzb3VyY2UudGFyZ2V0IGFzIGFueSk7XG4gIGlmIChjZWxsVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHsgdHlwZTogJ2NlbGwnLCB0YXJnZXQ6IGNlbGxUYXJnZXQgfTtcbiAgfSBlbHNlIGlmIChpc1Jvd0NvbnRhaW5lcihzb3VyY2UudGFyZ2V0IGFzIGFueSkpIHtcbiAgICByZXR1cm4geyB0eXBlOiAnY2VsbCcsIHRhcmdldDogc291cmNlLnRhcmdldCBhcyBhbnkgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuT25jZSgpOiB2b2lkIHtcbiAgUGJsQ29sdW1uLmV4dGVuZFByb3BlcnR5KCdlZGl0YWJsZScpO1xufVxuXG5ATmdyaWRQbHVnaW4oeyBpZDogUExVR0lOX0tFWSwgZmFjdG9yeTogJ2NyZWF0ZScsIHJ1bk9uY2UgfSlcbmV4cG9ydCBjbGFzcyBQYmxOZ3JpZFRhcmdldEV2ZW50c1BsdWdpbjxUID0gYW55PiB7XG4gIHJvd0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPj4oKTtcbiAgcm93RGJsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+PigpO1xuICByb3dFbnRlciA9IG5ldyBFdmVudEVtaXR0ZXI8RXZlbnRzLlBibE5ncmlkUm93RXZlbnQ8VD4+KCk7XG4gIHJvd0xlYXZlID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPj4oKTtcblxuICBjZWxsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBNb3VzZUV2ZW50Pj4oKTtcbiAgY2VsbERibENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudHMuUGJsTmdyaWRDZWxsRXZlbnQ8VCwgTW91c2VFdmVudD4+KCk7XG4gIGNlbGxFbnRlciA9IG5ldyBFdmVudEVtaXR0ZXI8RXZlbnRzLlBibE5ncmlkQ2VsbEV2ZW50PFQsIE1vdXNlRXZlbnQ+PigpO1xuICBjZWxsTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBNb3VzZUV2ZW50Pj4oKTtcblxuICBtb3VzZURvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBNb3VzZUV2ZW50PiB8IEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+PigpO1xuICBtb3VzZVVwID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudHMuUGJsTmdyaWRDZWxsRXZlbnQ8VCwgTW91c2VFdmVudD4gfCBFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPj4oKTtcbiAga2V5VXAgPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBLZXlib2FyZEV2ZW50PiB8IEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+PigpO1xuICBrZXlEb3duID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudHMuUGJsTmdyaWRDZWxsRXZlbnQ8VCwgS2V5Ym9hcmRFdmVudD4gfCBFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPj4oKTtcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBnaXJkYCBpbnN0ZWFkICovXG4gIGdldCB0YWJsZSgpOiBQYmxOZ3JpZENvbXBvbmVudDxhbnk+IHsgcmV0dXJuIHRoaXMuZ3JpZDsgfVxuXG4gIHByb3RlY3RlZCByZWFkb25seSBkZXN0cm95ZWQgPSBuZXcgUmVwbGF5U3ViamVjdDx2b2lkPigpO1xuXG4gIHByaXZhdGUgX3JlbW92ZVBsdWdpbjogKHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxhbnk+KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBncmlkOiBQYmxOZ3JpZENvbXBvbmVudDxhbnk+LFxuICAgICAgICAgICAgICBwcm90ZWN0ZWQgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGx1Z2luQ3RybDogUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyKSB7XG4gICAgdGhpcy5fcmVtb3ZlUGx1Z2luID0gcGx1Z2luQ3RybC5zZXRQbHVnaW4oUExVR0lOX0tFWSwgdGhpcyk7XG4gICAgaWYgKGdyaWQuaXNJbml0KSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHBsdWdpbkN0cmwuZXZlbnRzXG4gICAgICAgIC5zdWJzY3JpYmUoIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQua2luZCA9PT0gJ29uSW5pdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPFQgPSBhbnk+KHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxhbnk+LCBpbmplY3RvcjogSW5qZWN0b3IpOiBQYmxOZ3JpZFRhcmdldEV2ZW50c1BsdWdpbjxUPiB7XG4gICAgY29uc3QgcGx1Z2luQ3RybCA9IFBibE5ncmlkUGx1Z2luQ29udHJvbGxlci5maW5kKHRhYmxlKTtcbiAgICByZXR1cm4gbmV3IFBibE5ncmlkVGFyZ2V0RXZlbnRzUGx1Z2luPFQ+KHRhYmxlLCBpbmplY3RvciwgcGx1Z2luQ3RybCk7XG4gIH1cblxuICBwcml2YXRlIGluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zZXR1cERvbUV2ZW50cygpO1xuICAgIGhhbmRsZUZvY3VzQW5kU2VsZWN0aW9uKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cERvbUV2ZW50cygpOiB2b2lkIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5ncmlkO1xuICAgIGNvbnN0IGNka1RhYmxlID0gZ3JpZC5fY2RrVGFibGU7XG4gICAgY29uc3QgY2RrVGFibGVFbGVtZW50OiBIVE1MRWxlbWVudCA9IGNka1RhYmxlWydfZWxlbWVudCddO1xuXG4gICAgY29uc3QgY3JlYXRlQ2VsbEV2ZW50ID0gPFRFdmVudCBleHRlbmRzIEV2ZW50PihjZWxsVGFyZ2V0OiBIVE1MRWxlbWVudCwgc291cmNlOiBURXZlbnQpOiBFdmVudHMuUGJsTmdyaWRDZWxsRXZlbnQ8VCwgVEV2ZW50PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBjb25zdCByb3dUYXJnZXQgPSBjZWxsVGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBtYXRyaXhQb2ludCA9IG1hdHJpeFJvd0Zyb21Sb3cocm93VGFyZ2V0LCBjZGtUYWJsZS5fcm93T3V0bGV0LnZpZXdDb250YWluZXIpO1xuICAgICAgaWYgKG1hdHJpeFBvaW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50OiBFdmVudHMuUGJsTmdyaWRDZWxsRXZlbnQ8VCwgVEV2ZW50PiA9IHsgLi4ubWF0cml4UG9pbnQsIHNvdXJjZSwgY2VsbFRhcmdldCwgcm93VGFyZ2V0IH0gYXMgYW55O1xuICAgICAgICBpZiAobWF0cml4UG9pbnQudHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgKGV2ZW50IGFzIEV2ZW50cy5QYmxOZ3JpZERhdGFNYXRyaXhQb2ludDxUPikucm93ID0gZ3JpZC5kcy5yZW5kZXJlZERhdGFbbWF0cml4UG9pbnQucm93SW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnN1YlR5cGUgPT09ICdtZXRhJykge1xuICAgICAgICAgIC8vIFdoZW4gbXVsdGlwbGUgY29udGFpbmVycyBleGlzdHMgKGZpeGVkL3N0aWNreS9yb3cpIHRoZSByb3dJbmRleCB3ZSBnZXQgaXMgdGhlIG9uZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyLi5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgdGhlIHJvd0luZGV4IHJlbGF0aXZlIHRvIHRoZSBkZWZpbml0aW9uczpcbiAgICAgICAgICBjb25zdCB7IG1ldGFSb3dTZXJ2aWNlIH0gPSB0aGlzLnBsdWdpbkN0cmwuZXh0QXBpO1xuICAgICAgICAgIGNvbnN0IGRiID0gZXZlbnQudHlwZSA9PT0gJ2hlYWRlcicgPyBtZXRhUm93U2VydmljZS5oZWFkZXIgOiBtZXRhUm93U2VydmljZS5mb290ZXI7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGNvbGwgb2YgW2RiLmZpeGVkLCBkYi5yb3csIGRiLnN0aWNreV0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbGwuZmluZCggaXRlbSA9PiBpdGVtLmVsID09PSBldmVudC5yb3dUYXJnZXQgKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgZXZlbnQucm93SW5kZXggPSByZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGBtZXRhZGF0YUZyb21FbGVtZW50KClgIGRvZXMgbm90IHByb3ZpZGUgY29sdW1uIGluZm9ybWF0aW9uIG5vciB0aGUgY29sdW1uIGl0c2VsZi4gVGhpcyB3aWxsIGV4dGVuZCBmdW5jdGlvbmFsaXR5IHRvIGFkZCB0aGUgY29sdW1uSW5kZXggYW5kIGNvbHVtbi5cbiAgICAgICAgICAgIFRoZSBzaW1wbGUgY2FzZSBpcyB3aGVuIGBzdWJUeXBlID09PSAnZGF0YSdgLCBpbiB0aGlzIGNhc2UgdGhlIGNvbHVtbiBpcyBhbHdheXMgdGhlIGRhdGEgY29sdW1uIGZvciBhbGwgdHlwZXMgKGhlYWRlciwgZGF0YSBhbmQgZm9vdGVyKVxuXG4gICAgICAgICAgICBJZiBgc3ViVHlwZSAhPT0gJ2RhdGEnYCB3ZSBuZWVkIHRvIGdldCB0aGUgcHJvcGVyIGNvbHVtbiBiYXNlZCB0eXBlICh0eXBlIGNhbiBvbmx5IGJlIGBoZWFkZXJgIG9yIGBmb290ZXJgIGF0IHRoaXMgcG9pbnQpLlxuICAgICAgICAgICAgQnV0IHRoYXQncyBub3QgYWxsLCBiZWNhdXNlIGBtZXRhZGF0YUZyb21FbGVtZW50KClgIGRvZXMgbm90IGhhbmRsZSBgbWV0YS1ncm91cGAgc3ViVHlwZSB3ZSBuZWVkIHRvIGRvIGl0IGhlcmUuLi5cbiAgICAgICAgKi9cbiAgICAgICAgZXZlbnQuY29sSW5kZXggPSBmaW5kQ2VsbFJlbmRlckluZGV4KGNlbGxUYXJnZXQpO1xuICAgICAgICBpZiAobWF0cml4UG9pbnQuc3ViVHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkFwaS5maW5kQ29sdW1uQXQoZXZlbnQuY29sSW5kZXgpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gdGhpcy5ncmlkLmNvbHVtbkFwaS5pbmRleE9mKGNvbHVtbik7XG4gICAgICAgICAgZXZlbnQuY29sdW1uID0gY29sdW1uO1xuICAgICAgICAgIChldmVudCBhcyBFdmVudHMuUGJsTmdyaWREYXRhTWF0cml4UG9pbnQ8VD4pLmNvbnRleHQgPSB0aGlzLnBsdWdpbkN0cmwuZXh0QXBpLmNvbnRleHRBcGkuZ2V0Q2VsbChldmVudC5yb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5wbHVnaW5DdHJsLmV4dEFwaS5jb2x1bW5TdG9yZTtcbiAgICAgICAgICBjb25zdCByb3dJbmZvID0gc3RvcmUubWV0YUNvbHVtbklkc1ttYXRyaXhQb2ludC50eXBlXVtldmVudC5yb3dJbmRleF07XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0gc3RvcmUuZmluZChyb3dJbmZvLmtleXNbZXZlbnQuY29sSW5kZXhdKTtcbiAgICAgICAgICBpZiAocm93SW5mby5pc0dyb3VwKSB7XG4gICAgICAgICAgICBldmVudC5zdWJUeXBlID0gJ21ldGEtZ3JvdXAnO1xuICAgICAgICAgICAgZXZlbnQuY29sdW1uID0gbWF0cml4UG9pbnQudHlwZSA9PT0gJ2hlYWRlcicgPyByZWNvcmQuaGVhZGVyR3JvdXAgOiByZWNvcmQuZm9vdGVyR3JvdXA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LmNvbHVtbiA9IG1hdHJpeFBvaW50LnR5cGUgPT09ICdoZWFkZXInID8gcmVjb3JkLmhlYWRlciA6IHJlY29yZC5mb290ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjcmVhdGVSb3dFdmVudCA9IDxURXZlbnQgZXh0ZW5kcyBFdmVudD4ocm93VGFyZ2V0OiBIVE1MRWxlbWVudCwgc291cmNlOiBURXZlbnQsIHJvb3Q/OiBFdmVudHMuUGJsTmdyaWRDZWxsRXZlbnQ8VCwgVEV2ZW50Pik6IEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+IHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50OiBFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPiA9IHtcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgcm93VGFyZ2V0LFxuICAgICAgICAgIHR5cGU6IHJvb3QudHlwZSxcbiAgICAgICAgICBzdWJUeXBlOiByb290LnN1YlR5cGUsXG4gICAgICAgICAgcm93SW5kZXg6IHJvb3Qucm93SW5kZXgsXG4gICAgICAgICAgcm9vdFxuICAgICAgICB9IGFzIGFueTtcbiAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgKGV2ZW50IGFzIEV2ZW50cy5QYmxOZ3JpZERhdGFNYXRyaXhSb3c8VD4pLnJvdyA9IHJvb3Qucm93O1xuICAgICAgICAgIChldmVudCBhcyBFdmVudHMuUGJsTmdyaWREYXRhTWF0cml4Um93PFQ+KS5jb250ZXh0ID0gcm9vdC5jb250ZXh0LnJvd0NvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0cml4UG9pbnQgPSBtYXRyaXhSb3dGcm9tUm93KHJvd1RhcmdldCwgY2RrVGFibGUuX3Jvd091dGxldC52aWV3Q29udGFpbmVyKTtcbiAgICAgICAgaWYgKG1hdHJpeFBvaW50KSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQ6IEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+ID0geyAuLi5tYXRyaXhQb2ludCwgc291cmNlLCByb3dUYXJnZXQgfSBhcyBhbnk7XG4gICAgICAgICAgaWYgKG1hdHJpeFBvaW50LnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgKGV2ZW50IGFzIEV2ZW50cy5QYmxOZ3JpZERhdGFNYXRyaXhSb3c8VD4pLmNvbnRleHQgPSB0aGlzLnBsdWdpbkN0cmwuZXh0QXBpLmNvbnRleHRBcGkuZ2V0Um93KG1hdHJpeFBvaW50LnJvd0luZGV4KTtcbiAgICAgICAgICAgIChldmVudCBhcyBFdmVudHMuUGJsTmdyaWREYXRhTWF0cml4Um93PFQ+KS5yb3cgPSAoZXZlbnQgYXMgRXZlbnRzLlBibE5ncmlkRGF0YU1hdHJpeFJvdzxUPikuY29udGV4dC4kaW1wbGljaXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogIElmIGBzdWJUeXBlICE9PSAnZGF0YSdgIGl0IGNhbiBvbmx5IGJlIGBtZXRhYCBiZWNhdXNlIGBtZXRhZGF0YUZyb21FbGVtZW50KClgIGRvZXMgbm90IGhhbmRsZSBgbWV0YS1ncm91cGAgc3ViVHlwZS5cbiAgICAgICAgICAgICAgV2UgbmVlZCB0byBleHRlbmQgdGhpcyBtaXNzaW5nIHBhcnQsIHdlIGRvbid0IGhhdmUgY29sdW1ucyBoZXJlIHNvIHdlIHdpbGwgdHJ5IHRvIGluZmVyIGl0IHVzaW5nIHRoZSBmaXJzdCBjb2x1bW4uXG5cbiAgICAgICAgICAgICAgSXQncyBzaW1pbGFyIHRvIGhvdyBpdCdzIGhhbmRsZWQgaW4gY2VsbCBjbGlja3MsIGJ1dCBoZXJlIHdlIGRvbid0IG5lZWQgdG8gZXh0ZW5kcyB0aGUgY29sdW1uIGluZm8uXG4gICAgICAgICAgICAgIFdlIG9ubHkgbmVlZCB0byBjaGFuZ2UgdGhlIGBzdWJUeXBlYCB3aGVuIHRoZSByb3cgaXMgYSBncm91cCByb3csIGdldHRpbmcgYSBzcGVjaWZpYyBjb2x1bW4gaXMgaXJyZWxldmFudC5cbiAgICAgICAgICAgICAgV2UganVzdCBuZWVkIEEgY29sdW1uIGJlY2F1c2UgZ3JvdXAgY29sdW1ucyBkb24ndCBtaXggd2l0aCByZWd1bGFyIG1ldGEgY29sdW1ucy5cblxuICAgICAgICAgICAgICBOT1RFOiBXaGVuIHN1YlR5cGUgaXMgbm90ICdkYXRhJyB0aGUgeXBlIGNhbiBvbmx5IGJlIGBoZWFkZXJgIG9yIGBmb290ZXJgLlxuICAgICAgICAgICovXG4gICAgICAgICAgaWYgKG1hdHJpeFBvaW50LnN1YlR5cGUgIT09ICdkYXRhJykge1xuICAgICAgICAgICAgY29uc3Qgcm93SW5mbyA9IHRoaXMucGx1Z2luQ3RybC5leHRBcGkuY29sdW1uU3RvcmUubWV0YUNvbHVtbklkc1ttYXRyaXhQb2ludC50eXBlXVtldmVudC5yb3dJbmRleF07XG4gICAgICAgICAgICBpZiAocm93SW5mby5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnN1YlR5cGUgPSAnbWV0YS1ncm91cCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBsYXN0Q2VsbEVudGVyRXZlbnQ6IEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBNb3VzZUV2ZW50PjtcbiAgICBsZXQgbGFzdFJvd0VudGVyRXZlbnQ6IEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+O1xuICAgIGNvbnN0IGVtaXRDZWxsTGVhdmUgPSAoc291cmNlOiBNb3VzZUV2ZW50KTogRXZlbnRzLlBibE5ncmlkQ2VsbEV2ZW50PFQ+IHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGlmIChsYXN0Q2VsbEVudGVyRXZlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdENlbGxFbnRlckV2ZW50VGVtcCA9IGxhc3RDZWxsRW50ZXJFdmVudDtcbiAgICAgICAgdGhpcy5jZWxsTGVhdmUuZW1pdChPYmplY3QuYXNzaWduKHt9LCBsYXN0Q2VsbEVudGVyRXZlbnRUZW1wLCB7IHNvdXJjZSB9KSk7XG4gICAgICAgIGxhc3RDZWxsRW50ZXJFdmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGxhc3RDZWxsRW50ZXJFdmVudFRlbXA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVtaXRSb3dMZWF2ZSA9IChzb3VyY2U6IE1vdXNlRXZlbnQpOiBFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBpZiAobGFzdFJvd0VudGVyRXZlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdFJvd0VudGVyRXZlbnRUZW1wID0gbGFzdFJvd0VudGVyRXZlbnQ7XG4gICAgICAgIHRoaXMucm93TGVhdmUuZW1pdChPYmplY3QuYXNzaWduKHt9LCBsYXN0Um93RW50ZXJFdmVudFRlbXAsIHsgc291cmNlIH0pKTtcbiAgICAgICAgbGFzdFJvd0VudGVyRXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBsYXN0Um93RW50ZXJFdmVudFRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvY2Vzc0V2ZW50ID0gPFRFdmVudCBleHRlbmRzIEV2ZW50PihlOiBURXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbmRFdmVudFNvdXJjZShlKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnY2VsbCcpIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNlbGxFdmVudDxURXZlbnQ+KHJlc3VsdC50YXJnZXQsIGUpO1xuICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogcmVzdWx0LnR5cGUsXG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICB3YWl0VGltZTogaGFzTGlzdGVuZXJzKHRoaXMuY2VsbERibENsaWNrKSA/IDI1MCA6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQudHlwZSA9PT0gJ3JvdycpIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVJvd0V2ZW50KHJlc3VsdC50YXJnZXQsIGUpO1xuICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogcmVzdWx0LnR5cGUsXG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICB3YWl0VGltZTogaGFzTGlzdGVuZXJzKHRoaXMucm93RGJsQ2xpY2spID8gMjUwIDogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBTcGxpdCB0aGUgcmVzdWx0IG9mIHByb2Nlc3NFdmVudCBpbnRvIGNlbGwgYW5kIHJvdyBldmVudHMsIGlmIHR5cGUgaXMgcm93IG9ubHkgcm93IGV2ZW50IGlzIHJldHVybmVkLCBpZiBjZWxsIHRoZW4gY2VsbCBpcyByZXR1cm5lZCBhbmQgcm93IGlzIGNyZWF0ZWQgYWxvbmcgc2lkZS4gKi9cbiAgICBjb25zdCBzcGxpdFByb2Nlc3NlZEV2ZW50ID0gPFRFdmVudCBleHRlbmRzIEV2ZW50PihldmVudDogUmV0dXJuVHlwZTx0eXBlb2YgcHJvY2Vzc0V2ZW50PikgPT4ge1xuICAgICAgY29uc3QgY2VsbEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2NlbGwnID8gZXZlbnQuZXZlbnQgYXMgRXZlbnRzLlBibE5ncmlkQ2VsbEV2ZW50PFQsIFRFdmVudD4gOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCByb3dFdmVudCA9IGNlbGxFdmVudFxuICAgICAgICA/IGNyZWF0ZVJvd0V2ZW50PFRFdmVudD4oY2VsbEV2ZW50LnJvd1RhcmdldCwgY2VsbEV2ZW50LnNvdXJjZSwgY2VsbEV2ZW50KVxuICAgICAgICA6IGV2ZW50LmV2ZW50IGFzIEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+XG4gICAgICA7XG4gICAgICByZXR1cm4geyBjZWxsRXZlbnQsIHJvd0V2ZW50IH07XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyVXBEb3duRXZlbnRzID0gPFRFdmVudCBleHRlbmRzIEV2ZW50PihldmVudE5hbWU6IHN0cmluZywgZW1pdHRlcjogRXZlbnRFbWl0dGVyPEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBURXZlbnQ+IHwgRXZlbnRzLlBibE5ncmlkUm93RXZlbnQ8VD4+KSA9PiB7XG4gICAgICBmcm9tRXZlbnQoY2RrVGFibGVFbGVtZW50LCBldmVudE5hbWUpXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCksXG4gICAgICAgICAgZmlsdGVyKCBzb3VyY2UgPT4gaGFzTGlzdGVuZXJzKGVtaXR0ZXIpICksXG4gICAgICAgICAgbWFwKHByb2Nlc3NFdmVudCksXG4gICAgICAgICAgZmlsdGVyKCByZXN1bHQgPT4gISFyZXN1bHQgKSxcbiAgICAgICAgKVxuICAgICAgICAuc3Vic2NyaWJlKCByZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY2VsbEV2ZW50LCByb3dFdmVudCB9ID0gc3BsaXRQcm9jZXNzZWRFdmVudDxURXZlbnQ+KHJlc3VsdCk7XG4gICAgICAgICAgZW1pdHRlci5lbWl0KGNlbGxFdmVudCB8fCByb3dFdmVudCk7XG4gICAgICAgICAgdGhpcy5zeW5jUm93KGNlbGxFdmVudCB8fCByb3dFdmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyVXBEb3duRXZlbnRzPE1vdXNlRXZlbnQ+KCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwKTtcbiAgICByZWdpc3RlclVwRG93bkV2ZW50czxNb3VzZUV2ZW50PignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd24pO1xuICAgIHJlZ2lzdGVyVXBEb3duRXZlbnRzPEtleWJvYXJkRXZlbnQ+KCdrZXl1cCcsIHRoaXMua2V5VXApO1xuICAgIHJlZ2lzdGVyVXBEb3duRXZlbnRzPEtleWJvYXJkRXZlbnQ+KCdrZXlkb3duJywgdGhpcy5rZXlEb3duKTtcblxuICAgIC8qXG4gICAgICBIYW5kbGluZyBjbGljayBzdHJlYW0gZm9yIGJvdGggY2xpY2sgYW5kIGRvdWJsZSBjbGljayBldmVudHMuXG4gICAgICBXZSB3YW50IHRvIGRldGVjdCBkb3VibGUgY2xpY2tzIGFuZCBjbGlja3Mgd2l0aCBtaW5pbWFsIGRlbGF5c1xuICAgICAgV2UgY2hlY2sgaWYgYSBkb3VibGUgY2xpY2sgaGFzIGxpc3RlbmVycywgaWYgbm90IHdlIHdvbid0IGRlbGF5IHRoZSBjbGljay4uLlxuICAgICAgVE9ETzogb24gZG91YmxlIGNsaWNrLCBkb24ndCB3YWl0IHRoZSB3aG9sZSAyNTAgbXMgaWYgMiBjbGlja3MgaGFwcGVuLlxuICAgICovXG4gICAgY29uc3QgY2xpY2tTdHJlYW0gPSBmcm9tRXZlbnQoY2RrVGFibGVFbGVtZW50LCAnY2xpY2snKS5waXBlKFxuICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkKSxcbiAgICAgIGZpbHRlciggc291cmNlID0+IGhhc0xpc3RlbmVycyh0aGlzLmNlbGxDbGljaykgfHwgaGFzTGlzdGVuZXJzKHRoaXMuY2VsbERibENsaWNrKSB8fCBoYXNMaXN0ZW5lcnModGhpcy5yb3dDbGljaykgfHwgaGFzTGlzdGVuZXJzKHRoaXMucm93RGJsQ2xpY2spICksXG4gICAgICBtYXAocHJvY2Vzc0V2ZW50KSxcbiAgICAgIGZpbHRlciggcmVzdWx0ID0+ICEhcmVzdWx0ICksXG4gICAgKTtcblxuICAgIGNsaWNrU3RyZWFtXG4gICAgICAucGlwZShcbiAgICAgICAgYnVmZmVyV2hlbiggKCkgPT4gY2xpY2tTdHJlYW0ucGlwZSggZGVib3VuY2UoIGUgPT4gdGltZXIoZS53YWl0VGltZSkgKSApICksXG4gICAgICAgIGZpbHRlciggZXZlbnRzID0+IGV2ZW50cy5sZW5ndGggPiAwICksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCBldmVudHMgPT4ge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50cy5zaGlmdCgpO1xuICAgICAgICBjb25zdCBpc0RvdWJsZUNsaWNrID0gZXZlbnRzLmxlbmd0aCA9PT0gMTsgLy8gaWYgd2UgaGF2ZSAyIGV2ZW50cyBpdHMgZG91YmxlIGNsaWNrLCBvdGhlcndpc2Ugc2luZ2xlLlxuICAgICAgICBjb25zdCB7IGNlbGxFdmVudCwgcm93RXZlbnQgfSA9IHNwbGl0UHJvY2Vzc2VkRXZlbnQ8TW91c2VFdmVudD4oZXZlbnQpO1xuICAgICAgICBpZiAoaXNEb3VibGVDbGljaykge1xuICAgICAgICAgIGlmIChjZWxsRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbERibENsaWNrLmVtaXQoY2VsbEV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yb3dEYmxDbGljay5lbWl0KHJvd0V2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2VsbEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxDbGljay5lbWl0KGNlbGxFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucm93Q2xpY2suZW1pdChyb3dFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jUm93KGNlbGxFdmVudCB8fCByb3dFdmVudCk7XG4gICAgICB9KTtcblxuXG4gICAgZnJvbUV2ZW50KGNka1RhYmxlRWxlbWVudCwgJ21vdXNlbGVhdmUnKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCAoc291cmNlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQ6IEV2ZW50cy5QYmxOZ3JpZFJvd0V2ZW50PFQ+IHwgRXZlbnRzLlBibE5ncmlkQ2VsbEV2ZW50PFQ+ID0gZW1pdENlbGxMZWF2ZShzb3VyY2UpO1xuICAgICAgICBsYXN0RXZlbnQgPSBlbWl0Um93TGVhdmUoc291cmNlKSB8fCBsYXN0RXZlbnQ7XG4gICAgICAgIGlmIChsYXN0RXZlbnQpIHtcbiAgICAgICAgICB0aGlzLnN5bmNSb3cobGFzdEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBmcm9tRXZlbnQoY2RrVGFibGVFbGVtZW50LCAnbW91c2Vtb3ZlJylcbiAgICAgIC5waXBlKFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSggKHNvdXJjZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsVGFyZ2V0OiBIVE1MRWxlbWVudCA9IGZpbmRQYXJlbnRDZWxsKHNvdXJjZS50YXJnZXQgYXMgYW55KTtcbiAgICAgICAgY29uc3QgbGFzdENlbGxUYXJnZXQgPSBsYXN0Q2VsbEVudGVyRXZlbnQgJiYgbGFzdENlbGxFbnRlckV2ZW50LmNlbGxUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGxhc3RSb3dUYXJnZXQgPSBsYXN0Um93RW50ZXJFdmVudCAmJiBsYXN0Um93RW50ZXJFdmVudC5yb3dUYXJnZXQ7XG5cbiAgICAgICAgbGV0IGNlbGxFdmVudDogRXZlbnRzLlBibE5ncmlkQ2VsbEV2ZW50PFQsIE1vdXNlRXZlbnQ+O1xuICAgICAgICBsZXQgbGFzdEV2ZW50OiBFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPiB8IEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxUPjtcblxuICAgICAgICBpZiAobGFzdENlbGxUYXJnZXQgIT09IGNlbGxUYXJnZXQpIHtcbiAgICAgICAgICBsYXN0RXZlbnQgPSBlbWl0Q2VsbExlYXZlKHNvdXJjZSkgfHwgbGFzdEV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlbGxUYXJnZXQpIHtcbiAgICAgICAgICBpZiAobGFzdENlbGxUYXJnZXQgIT09IGNlbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IGNyZWF0ZUNlbGxFdmVudChjZWxsVGFyZ2V0LCBzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGNlbGxFdmVudCkge1xuICAgICAgICAgICAgICB0aGlzLmNlbGxFbnRlci5lbWl0KGxhc3RDZWxsRW50ZXJFdmVudCA9IGNlbGxFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dUYXJnZXQgPSAoY2VsbEV2ZW50ICYmIGNlbGxFdmVudC5yb3dUYXJnZXQpIHx8IChpc1Jvd0NvbnRhaW5lcihzb3VyY2UudGFyZ2V0IGFzIGFueSkgJiYgc291cmNlLnRhcmdldCBhcyBhbnkpO1xuXG4gICAgICAgIGlmIChsYXN0Um93VGFyZ2V0ICE9PSByb3dUYXJnZXQpIHtcbiAgICAgICAgICBsYXN0RXZlbnQgPSBlbWl0Um93TGVhdmUoc291cmNlKSB8fCBsYXN0RXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93VGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKGxhc3RSb3dUYXJnZXQgIT09IHJvd1RhcmdldCkge1xuICAgICAgICAgICAgY29uc3Qgcm93RXZlbnQgPSBjcmVhdGVSb3dFdmVudChyb3dUYXJnZXQsIHNvdXJjZSwgY2VsbEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChyb3dFdmVudCkge1xuICAgICAgICAgICAgICB0aGlzLnJvd0VudGVyLmVtaXQobGFzdFJvd0VudGVyRXZlbnQgPSByb3dFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RFdmVudCkge1xuICAgICAgICAgIHRoaXMuc3luY1JvdyhsYXN0RXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95ZWQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fcmVtb3ZlUGx1Z2luKHRoaXMuZ3JpZCk7XG4gIH1cblxuICBwcml2YXRlIHN5bmNSb3c8VEV2ZW50IGV4dGVuZHMgRXZlbnQ+KGV2ZW50OiBFdmVudHMuUGJsTmdyaWRSb3dFdmVudDxUPiB8IEV2ZW50cy5QYmxOZ3JpZENlbGxFdmVudDxULCBURXZlbnQ+KTogdm9pZCB7XG4gICAgdGhpcy5ncmlkLl9jZGtUYWJsZS5zeW5jUm93cyhldmVudC50eXBlLCBldmVudC5yb3dJbmRleCk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdwYmwtbmdyaWRbdGFyZ2V0RXZlbnRzXSwgcGJsLW5ncmlkW3Jvd0NsaWNrXSwgcGJsLW5ncmlkW3Jvd0RibENsaWNrXSwgcGJsLW5ncmlkW3Jvd0VudGVyXSwgcGJsLW5ncmlkW3Jvd0xlYXZlXSwgcGJsLW5ncmlkW2NlbGxDbGlja10sIHBibC1uZ3JpZFtjZWxsRGJsQ2xpY2tdLCBwYmwtbmdyaWRbY2VsbEVudGVyXSwgcGJsLW5ncmlkW2NlbGxMZWF2ZV0sIHBibC1uZ3JpZFtrZXlEb3duXSwgcGJsLW5ncmlkW2tleVVwXScsXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1c2Utb3V0cHV0LXByb3BlcnR5LWRlY29yYXRvclxuICBvdXRwdXRzOiBbICdyb3dDbGljaycsICdyb3dEYmxDbGljaycsICdyb3dFbnRlcicsICdyb3dMZWF2ZScsICdjZWxsQ2xpY2snLCAnY2VsbERibENsaWNrJywgJ2NlbGxFbnRlcicsICdjZWxsTGVhdmUnLCAna2V5RG93bicsICdrZXlVcCcgXVxufSlcbkBVblJ4KClcbmV4cG9ydCBjbGFzcyBQYmxOZ3JpZFRhcmdldEV2ZW50c1BsdWdpbkRpcmVjdGl2ZTxUPiBleHRlbmRzIFBibE5ncmlkVGFyZ2V0RXZlbnRzUGx1Z2luPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBjb25zdHJ1Y3Rvcih0YWJsZTogUGJsTmdyaWRDb21wb25lbnQ8YW55PiwgaW5qZWN0b3I6IEluamVjdG9yLCBwbHVnaW5DdHJsOiBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXIpIHtcbiAgICBzdXBlcih0YWJsZSwgaW5qZWN0b3IsIHBsdWdpbkN0cmwpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cblxufVxuIl19