/**
 * @fileoverview added by tsickle
 * Generated from: lib/drag-and-drop/column/column-reorder-plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __decorate, __extends, __metadata, __read, __spread, __values } from "tslib";
// tslint:disable:no-output-rename
import { BehaviorSubject } from 'rxjs';
import { ChangeDetectorRef, Directive, ElementRef, Input, Inject, SkipSelf, Output, Optional, ViewContainerRef, NgZone, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DragDrop, CdkDrag, CDK_DROP_LIST, CdkDropListGroup, CdkDropList, CDK_DRAG_CONFIG, } from '@angular/cdk/drag-drop';
import { PblNgridComponent, NgridPlugin, PblNgridPluginController } from '@pebula/ngrid';
import { PblDragDrop } from '../core/drag-drop';
import { CdkLazyDropList, CdkLazyDrag } from '../core/lazy-drag-drop';
import { extendGrid } from './extend-grid';
/** @type {?} */
export var PLUGIN_KEY = 'columnReorder';
/** @type {?} */
var _uniqueIdCounter = 0;
/**
 * @template T
 */
var PblNgridColumnReorderPluginDirective = /** @class */ (function (_super) {
    __extends(PblNgridColumnReorderPluginDirective, _super);
    function PblNgridColumnReorderPluginDirective(table, pluginCtrl, element, dragDrop, changeDetectorRef, dir, group) {
        var _this = _super.call(this, element, dragDrop, changeDetectorRef, dir, group) || this;
        _this.table = table;
        _this.id = "pbl-ngrid-column-reorder-list-" + _uniqueIdCounter++;
        _this.orientation = 'horizontal';
        _this.dragging = new BehaviorSubject(false);
        _this._columnReorder = false;
        _this._manualOverride = false;
        _this._draggablesSet = new Set();
        _this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, _this);
        _this.directContainerElement = '.pbl-ngrid-header-row-main';
        _this.dropped.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!_this.manualOverride) {
                _this.table.columnApi.moveColumn(((/** @type {?} */ (event.item))).column, event.currentIndex);
            }
        }));
        _this.dragging.subscribe((/**
         * @param {?} isDragging
         * @return {?}
         */
        function (isDragging) {
            /** @type {?} */
            var el = element.nativeElement;
            if (isDragging) {
                el.classList.add('pbl-ngrid-column-list-dragging');
            }
            else {
                el.classList.remove('pbl-ngrid-column-list-dragging');
            }
            _this.lastSwap = undefined;
        }));
        _this.monkeyPatchDropListRef();
        return _this;
    }
    PblNgridColumnReorderPluginDirective_1 = PblNgridColumnReorderPluginDirective;
    Object.defineProperty(PblNgridColumnReorderPluginDirective.prototype, "columnReorder", {
        get: /**
         * @return {?}
         */
        function () { return this._columnReorder; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = coerceBooleanProperty(value);
            this._columnReorder = value;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PblNgridColumnReorderPluginDirective.prototype, "manualOverride", {
        /**
         * When true, will not move the column on drop.
         * Instead you need to handle the dropped event.
         */
        get: /**
         * When true, will not move the column on drop.
         * Instead you need to handle the dropped event.
         * @return {?}
         */
        function () { return this._manualOverride; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._manualOverride = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PblNgridColumnReorderPluginDirective.prototype, "pblGetItemIndexFromPointerPosition", {
        // Stuff to workaround encapsulation in CdkDropList
        get: 
        // Stuff to workaround encapsulation in CdkDropList
        /**
         * @private
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this._dropListRef)))._getItemIndexFromPointerPosition.bind(this._dropListRef);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PblNgridColumnReorderPluginDirective.prototype, "pblGetPositionCacheItems", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this._dropListRef)))._itemPositions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PblNgridColumnReorderPluginDirective.prototype, "pblDropListRef", {
        get: /**
         * @return {?}
         */
        function () { return (/** @type {?} */ (this._dropListRef)); },
        enumerable: true,
        configurable: true
    });
    // ngOnInit(): void { CdkLazyDropList.prototype.ngOnInit.call(this); }
    // ngOnInit(): void { CdkLazyDropList.prototype.ngOnInit.call(this); }
    /**
     * @param {?} drag
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.addDrag = 
    // ngOnInit(): void { CdkLazyDropList.prototype.ngOnInit.call(this); }
    /**
     * @param {?} drag
     * @return {?}
     */
    function (drag) { return CdkLazyDropList.prototype.addDrag.call(this, drag); };
    /**
     * @param {?} drag
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.removeDrag = /**
     * @param {?} drag
     * @return {?}
     */
    function (drag) { return CdkLazyDropList.prototype.removeDrag.call(this, drag); };
    // beforeStarted(): void { CdkLazyDropList.prototype.beforeStarted.call(this); }
    /* CdkLazyDropList end */
    // beforeStarted(): void { CdkLazyDropList.prototype.beforeStarted.call(this); }
    /* CdkLazyDropList end */
    /**
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.ngOnInit = 
    // beforeStarted(): void { CdkLazyDropList.prototype.beforeStarted.call(this); }
    /* CdkLazyDropList end */
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        CdkLazyDropList.prototype.ngOnInit.call(this); // super.ngOnInit();
        this.dropped.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this._pblReset(); }));
        this.pblDropListRef.beforeExit.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this._pblReset(); }));
    };
    /**
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        this._removePlugin(this.table);
    };
    /* protected */ /* protected */ /**
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.beforeStarted = /* protected */ /**
     * @return {?}
     */
    function () {
        CdkLazyDropList.prototype.beforeStarted.call(this); // super.beforeStarted();
        this.lastSorted = undefined;
        this.dragging.next(true);
    };
    /**
     * @private
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype._pblReset = /**
     * @private
     * @return {?}
     */
    function () {
        this.dragging.next(false);
        /** @type {?} */
        var siblings = this.pblGetPositionCacheItems;
        siblings.forEach((/**
         * @param {?} sibling
         * @param {?} index
         * @return {?}
         */
        function (sibling, index) {
            var e_1, _a;
            try {
                for (var _b = __values(sibling.drag.data.getCells()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var c = _c.value;
                    c.style.transform = "";
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.monkeyPatchDropListRef = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        var _a = this._dropListRef, _sortItem = _a._sortItem, enter = _a.enter;
        this.pblDropListRef.enter = (/**
         * @param {?} item
         * @param {?} pointerX
         * @param {?} pointerY
         * @return {?}
         */
        function (item, pointerX, pointerY) {
            /** @type {?} */
            var lastSorted = _this.lastSorted;
            _this.lastSorted = undefined;
            if (lastSorted && lastSorted.drag === item) {
                /** @type {?} */
                var isHorizontal = _this.orientation === 'horizontal';
                pointerX = lastSorted.clientRect.left + 1 - (isHorizontal ? lastSorted.offset : 0);
                pointerY = lastSorted.clientRect.top + 1 - (!isHorizontal ? lastSorted.offset : 0);
            }
            enter.call(_this._dropListRef, item, pointerX, pointerY);
        });
        this.pblDropListRef._sortItem = (/**
         * @param {?} item
         * @param {?} pointerX
         * @param {?} pointerY
         * @param {?} pointerDelta
         * @return {?}
         */
        function (item, pointerX, pointerY, pointerDelta) {
            var e_2, _a;
            /** @type {?} */
            var siblings = _this.pblGetPositionCacheItems;
            _this.lastSorted = siblings.find((/**
             * @param {?} s
             * @return {?}
             */
            function (s) { return s.drag === item; }));
            /** @type {?} */
            var newIndex = _this.pblGetItemIndexFromPointerPosition((/** @type {?} */ (item)), pointerX, pointerY, pointerDelta);
            if (newIndex === -1 && siblings.length > 0) {
                return;
            }
            /** @type {?} */
            var oldOrder = siblings.slice();
            /** @type {?} */
            var isHorizontal = _this.orientation === 'horizontal';
            /** @type {?} */
            var siblingAtNewPosition = siblings[newIndex];
            if (siblingAtNewPosition.drag.data.column.wontBudge) {
                return;
            }
            // we now need to find if between current and new position there are items with `wontBudge`
            /** @type {?} */
            var itemAtOriginalPosition = _this.lastSwap ? _this.lastSwap : item;
            /** @type {?} */
            var currentIndex = siblings.findIndex((/**
             * @param {?} currentItem
             * @return {?}
             */
            function (currentItem) { return currentItem.drag === itemAtOriginalPosition; }));
            /** @type {?} */
            var start = Math.min(newIndex, currentIndex);
            /** @type {?} */
            var itemsDraggedOver = siblings.slice(start, Math.abs(newIndex - currentIndex) + start);
            try {
                for (var itemsDraggedOver_1 = __values(itemsDraggedOver), itemsDraggedOver_1_1 = itemsDraggedOver_1.next(); !itemsDraggedOver_1_1.done; itemsDraggedOver_1_1 = itemsDraggedOver_1.next()) {
                    var dragItem = itemsDraggedOver_1_1.value;
                    if (dragItem.drag.data.column.wontBudge && dragItem.drag !== item) {
                        return;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (itemsDraggedOver_1_1 && !itemsDraggedOver_1_1.done && (_a = itemsDraggedOver_1.return)) _a.call(itemsDraggedOver_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // check if we move the item outside of locked group OR into a locked group... both are invalid.
            if (!item.data.column.checkGroupLockConstraint(siblingAtNewPosition.drag.data.column)) {
                return;
            }
            _sortItem.call(_this._dropListRef, item, pointerX, pointerY, pointerDelta);
            _this.lastSwap = siblingAtNewPosition.drag;
            if (isHorizontal) {
                siblings.forEach((/**
                 * @param {?} sibling
                 * @param {?} index
                 * @return {?}
                 */
                function (sibling, index) {
                    var e_3, _a;
                    // Don't do anything if the position hasn't changed.
                    if (oldOrder[index] === sibling) {
                        return;
                    }
                    try {
                        for (var _b = __values(sibling.drag.data.getCells()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var c = _c.value;
                            c.style.transform = "translate3d(" + sibling.offset + "px, 0, 0)";
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }));
            }
        });
    };
    var PblNgridColumnReorderPluginDirective_1;
    PblNgridColumnReorderPluginDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'pbl-ngrid[columnReorder]',
                    exportAs: 'pblNgridColumnReorder',
                    inputs: [
                        'directContainerElement:cdkDropListDirectContainerElement'
                    ],
                    host: {
                        // tslint:disable-line:use-host-property-decorator
                        'class': 'cdk-drop-list',
                        '[id]': 'id',
                        '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',
                        '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',
                    },
                    providers: [
                        { provide: DragDrop, useExisting: PblDragDrop },
                        { provide: CDK_DROP_LIST, useExisting: PblNgridColumnReorderPluginDirective_1 },
                    ],
                },] }
    ];
    /** @nocollapse */
    PblNgridColumnReorderPluginDirective.ctorParameters = function () { return [
        { type: PblNgridComponent },
        { type: PblNgridPluginController },
        { type: ElementRef },
        { type: DragDrop },
        { type: ChangeDetectorRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    PblNgridColumnReorderPluginDirective.propDecorators = {
        columnReorder: [{ type: Input }],
        manualOverride: [{ type: Input }],
        dragging: [{ type: Output, args: ['cdkDropDragging',] }]
    };
    /**
     * @template T
     */
    PblNgridColumnReorderPluginDirective = PblNgridColumnReorderPluginDirective_1 = __decorate([
        NgridPlugin({ id: PLUGIN_KEY, runOnce: extendGrid }),
        __metadata("design:paramtypes", [PblNgridComponent,
            PblNgridPluginController,
            ElementRef,
            DragDrop,
            ChangeDetectorRef,
            Directionality,
            CdkDropListGroup])
    ], PblNgridColumnReorderPluginDirective);
    return PblNgridColumnReorderPluginDirective;
}(CdkDropList));
export { PblNgridColumnReorderPluginDirective };
if (false) {
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.id;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.orientation;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.dragging;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype._draggables;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype._columnReorder;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype._manualOverride;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype._removePlugin;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype.lastSwap;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype.lastSorted;
    /**
     * Selector that will be used to determine the direct container element, starting from
     * the `cdkDropList` element and going down the DOM. Passing an alternate direct container element
     * is useful when the `cdkDropList` is not the direct parent (i.e. ancestor but not father)
     * of the draggable elements.
     * @type {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.directContainerElement;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.originalElement;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype._draggablesSet;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.table;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
/**
 * @template T
 */
var PblNgridColumnDragDirective = /** @class */ (function (_super) {
    __extends(PblNgridColumnDragDirective, _super);
    // CTOR IS REQUIRED OR IT WONT WORK IN AOT
    // TODO: Try to remove when supporting IVY
    function PblNgridColumnDragDirective(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {
        var _this = _super.call(this, element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) || this;
        _this.rootElementSelector = 'pbl-ngrid-header-cell';
        _this._hostNotRoot = false;
        return _this;
    }
    Object.defineProperty(PblNgridColumnDragDirective.prototype, "context", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._context = value;
            this.column = value && value.col;
            /** @type {?} */
            var pluginCtrl = this.pluginCtrl = value && PblNgridPluginController.find(value.grid);
            /** @type {?} */
            var plugin = pluginCtrl && pluginCtrl.getPlugin(PLUGIN_KEY);
            this.cdkDropList = plugin || undefined;
            this.disabled = this.column && this.column.reorder ? false : true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PblNgridColumnDragDirective.prototype, "rootElementSelectorClass", {
        /* CdkLazyDrag start */
        /**
         * A class to set when the root element is not the host element. (i.e. when `cdkDragRootElement` is used).
         */
        set: /* CdkLazyDrag start */
        /**
         * A class to set when the root element is not the host element. (i.e. when `cdkDragRootElement` is used).
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _a, _b;
            if (value !== this._rootClass && this._hostNotRoot) {
                if (this._rootClass) {
                    (_a = this.getRootElement().classList).remove.apply(_a, __spread(this._rootClass.split(' ')));
                }
                if (value) {
                    (_b = this.getRootElement().classList).add.apply(_b, __spread(value.split(' ')));
                }
            }
            this._rootClass = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PblNgridColumnDragDirective.prototype, "pblDragRef", {
        get: /**
         * @return {?}
         */
        function () { return (/** @type {?} */ (this._dragRef)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PblNgridColumnDragDirective.prototype, "cdkDropList", {
        get: /**
         * @return {?}
         */
        function () { return (/** @type {?} */ (this.dropContainer)); },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // TO SUPPORT `cdkDropList` via string input (ID) we need a reactive registry...
            if (this.cdkDropList) {
                this.cdkDropList.removeDrag(this);
            }
            this.dropContainer = value;
            if (value) {
                this._dragRef._withDropContainer(value._dropListRef);
                value.addDrag(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PblNgridColumnDragDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { CdkLazyDrag.prototype.ngOnInit.call(this); };
    // ngAfterViewInit(): void { CdkLazyDrag.prototype.ngAfterViewInit.call(this); super.ngAfterViewInit(); }
    // ngAfterViewInit(): void { CdkLazyDrag.prototype.ngAfterViewInit.call(this); super.ngAfterViewInit(); }
    /**
     * @return {?}
     */
    PblNgridColumnDragDirective.prototype.ngOnDestroy = 
    // ngAfterViewInit(): void { CdkLazyDrag.prototype.ngAfterViewInit.call(this); super.ngAfterViewInit(); }
    /**
     * @return {?}
     */
    function () { CdkLazyDrag.prototype.ngOnDestroy.call(this); _super.prototype.ngOnDestroy.call(this); };
    /* CdkLazyDrag end */
    /* CdkLazyDrag end */
    /**
     * @return {?}
     */
    PblNgridColumnDragDirective.prototype.ngAfterViewInit = /* CdkLazyDrag end */
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        CdkLazyDrag.prototype.ngAfterViewInit.call(this);
        _super.prototype.ngAfterViewInit.call(this);
        this._dragRef.beforeStarted.subscribe((/**
         * @return {?}
         */
        function () {
            var cdkDropList = _this.cdkDropList;
            if (cdkDropList && cdkDropList.columnReorder && _this._context.col.reorder) {
                // we don't allow a new dragging session before the previous ends.
                // this sound impossible, but due to animation transitions its actually is.
                // if the `transitionend` is long enough, a new drag can start...
                //
                // the `disabled` state is checked by pointerDown AFTER calling before start so we can cancel the start...
                if (cdkDropList._dropListRef.isDragging()) {
                    return _this.disabled = true;
                }
            }
        }));
        this.started.subscribe((/**
         * @return {?}
         */
        function () { return _this._context.col.columnDef.isDragging = true; }));
        this.ended.subscribe((/**
         * @return {?}
         */
        function () { return _this._context.col.columnDef.isDragging = false; }));
    };
    /**
     * @return {?}
     */
    PblNgridColumnDragDirective.prototype.getCells = /**
     * @return {?}
     */
    function () {
        if (!this.cache) {
            this.cache = this._context.col.columnDef.queryCellElements('table');
        }
        return this.cache;
    };
    /**
     * @return {?}
     */
    PblNgridColumnDragDirective.prototype.reset = /**
     * @return {?}
     */
    function () {
        var e_4, _a;
        _super.prototype.reset.call(this);
        if (this.cache) {
            try {
                for (var _b = __values(this.cache), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var el = _c.value;
                    el.style.transform = "";
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this.cache = undefined;
        }
    };
    PblNgridColumnDragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[pblNgridColumnDrag]',
                    exportAs: 'pblNgridColumnDrag',
                    host: {
                        // tslint:disable-line:use-host-property-decorator
                        'class': 'cdk-drag',
                        '[class.cdk-drag-dragging]': '_dragRef.isDragging()',
                    },
                    providers: [
                        { provide: DragDrop, useExisting: PblDragDrop },
                        { provide: CdkDrag, useExisting: PblNgridColumnDragDirective }
                    ]
                },] }
    ];
    /** @nocollapse */
    PblNgridColumnDragDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: CdkDropList, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone },
        { type: ViewContainerRef },
        { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },
        { type: Directionality },
        { type: DragDrop },
        { type: ChangeDetectorRef }
    ]; };
    PblNgridColumnDragDirective.propDecorators = {
        context: [{ type: Input, args: ['pblNgridColumnDrag',] }],
        rootElementSelectorClass: [{ type: Input, args: ['cdkDragRootElementClass',] }],
        cdkDropList: [{ type: Input }]
    };
    return PblNgridColumnDragDirective;
}(CdkDrag));
export { PblNgridColumnDragDirective };
if (false) {
    /** @type {?} */
    PblNgridColumnDragDirective.prototype.rootElementSelector;
    /** @type {?} */
    PblNgridColumnDragDirective.prototype.column;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnDragDirective.prototype._context;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnDragDirective.prototype.pluginCtrl;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnDragDirective.prototype.cache;
    /** @type {?} */
    PblNgridColumnDragDirective.prototype._rootClass;
    /** @type {?} */
    PblNgridColumnDragDirective.prototype._hostNotRoot;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLXJlb3JkZXItcGx1Z2luLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBlYnVsYS9uZ3JpZC9kcmFnLyIsInNvdXJjZXMiOlsibGliL2RyYWctYW5kLWRyb3AvY29sdW1uL2NvbHVtbi1yZW9yZGVyLXBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0EsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUV2QyxPQUFPLEVBRUwsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsS0FBSyxFQUNMLE1BQU0sRUFDTixRQUFRLEVBQ1IsTUFBTSxFQUVOLFFBQVEsRUFFUixnQkFBZ0IsRUFDaEIsTUFBTSxHQUVQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUzQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUNMLFFBQVEsRUFDUixPQUFPLEVBRVAsYUFBYSxFQUViLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsZUFBZSxHQUVoQixNQUFNLHdCQUF3QixDQUFDO0FBRWhDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQWEsd0JBQXdCLEVBQXVCLE1BQU0sZUFBZSxDQUFDO0FBQ3pILE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBR3RFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBUTNDLE1BQU0sS0FBTyxVQUFVLEdBQW9CLGVBQWU7O0lBRXRELGdCQUFnQixHQUFHLENBQUM7Ozs7O0lBb0IyQyx3REFBYztJQW1DL0UsOENBQW1CLEtBQTJCLEVBQ2xDLFVBQW9DLEVBQ3BD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VCxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRTt3QkFDL0MsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSwyQkFBMkIsRUFBRTtxQkFDL0Q7aUJBQ0Y7Ozs7Z0JBeFBDLFVBQVU7Z0JBdUJWLFdBQVcsdUJBdVBFLE1BQU0sU0FBQyxhQUFhLGNBQUcsUUFBUSxZQUFJLFFBQVE7Z0RBQzNDLE1BQU0sU0FBQyxRQUFRO2dCQXRRNUIsTUFBTTtnQkFETixnQkFBZ0I7Z0RBMFFILE1BQU0sU0FBQyxlQUFlO2dCQXBRNUIsY0FBYztnQkFHckIsUUFBUTtnQkFuQlIsaUJBQWlCOzs7MEJBZ1FoQixLQUFLLFNBQUMsb0JBQW9COzJDQXlDMUIsS0FBSyxTQUFDLHlCQUF5Qjs4QkFjL0IsS0FBSzs7SUF5RFIsa0NBQUM7Q0FBQSxBQWpJRCxDQVkwRCxPQUFPLEdBcUhoRTtTQXJIWSwyQkFBMkI7OztJQUN0QywwREFBOEM7O0lBRTlDLDZDQUFrQjs7Ozs7SUFXbEIsK0NBQXVIOzs7OztJQUN2SCxpREFBNkM7Ozs7O0lBQzdDLDRDQUE2Qjs7SUF5RDdCLGlEQUFtQjs7SUFDbkIsbURBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tb3V0cHV0LXJlbmFtZVxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBJbmplY3QsXG4gIFNraXBTZWxmLFxuICBPdXRwdXQsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE9uSW5pdCxcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgTmdab25lLFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1xuICBEcmFnRHJvcCxcbiAgQ2RrRHJhZyxcbiAgQ2RrRHJhZ0Ryb3AsXG4gIENES19EUk9QX0xJU1QsXG4gIERyYWdSZWYsXG4gIENka0Ryb3BMaXN0R3JvdXAsXG4gIENka0Ryb3BMaXN0LFxuICBDREtfRFJBR19DT05GSUcsXG4gIERyYWdSZWZDb25maWcsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9kcmFnLWRyb3AnO1xuXG5pbXBvcnQgeyBQYmxOZ3JpZENvbXBvbmVudCwgTmdyaWRQbHVnaW4sIFBibENvbHVtbiwgUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyLCBQYmxOZ3JpZENlbGxDb250ZXh0IH0gZnJvbSAnQHBlYnVsYS9uZ3JpZCc7XG5pbXBvcnQgeyBQYmxEcmFnRHJvcCB9IGZyb20gJy4uL2NvcmUvZHJhZy1kcm9wJztcbmltcG9ydCB7IENka0xhenlEcm9wTGlzdCwgQ2RrTGF6eURyYWcgfSBmcm9tICcuLi9jb3JlL2xhenktZHJhZy1kcm9wJztcbmltcG9ydCB7IFBibERyb3BMaXN0UmVmIH0gZnJvbSAnLi4vY29yZS9kcm9wLWxpc3QtcmVmJztcbmltcG9ydCB7IFBibERyYWdSZWYgfSBmcm9tICcuLi9jb3JlL2RyYWctcmVmJztcbmltcG9ydCB7IGV4dGVuZEdyaWQgfSBmcm9tICcuL2V4dGVuZC1ncmlkJztcblxuZGVjbGFyZSBtb2R1bGUgJ0BwZWJ1bGEvbmdyaWQvbGliL2V4dC90eXBlcycge1xuICBpbnRlcmZhY2UgUGJsTmdyaWRQbHVnaW5FeHRlbnNpb24ge1xuICAgIGNvbHVtblJlb3JkZXI/OiBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBMVUdJTl9LRVk6ICdjb2x1bW5SZW9yZGVyJyA9ICdjb2x1bW5SZW9yZGVyJztcblxubGV0IF91bmlxdWVJZENvdW50ZXIgPSAwO1xuXG5ATmdyaWRQbHVnaW4oeyBpZDogUExVR0lOX0tFWSwgcnVuT25jZTogZXh0ZW5kR3JpZCB9KVxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAncGJsLW5ncmlkW2NvbHVtblJlb3JkZXJdJyxcbiAgZXhwb3J0QXM6ICdwYmxOZ3JpZENvbHVtblJlb3JkZXInLFxuICBpbnB1dHM6IFtcbiAgICAnZGlyZWN0Q29udGFpbmVyRWxlbWVudDpjZGtEcm9wTGlzdERpcmVjdENvbnRhaW5lckVsZW1lbnQnXG4gIF0sXG4gIGhvc3Q6IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTp1c2UtaG9zdC1wcm9wZXJ0eS1kZWNvcmF0b3JcbiAgICAnY2xhc3MnOiAnY2RrLWRyb3AtbGlzdCcsXG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgICdbY2xhc3MuY2RrLWRyb3AtbGlzdC1kcmFnZ2luZ10nOiAnX2Ryb3BMaXN0UmVmLmlzRHJhZ2dpbmcoKScsXG4gICAgJ1tjbGFzcy5jZGstZHJvcC1saXN0LXJlY2VpdmluZ10nOiAnX2Ryb3BMaXN0UmVmLmlzUmVjZWl2aW5nKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IERyYWdEcm9wLCB1c2VFeGlzdGluZzogUGJsRHJhZ0Ryb3AgfSxcbiAgICB7IHByb3ZpZGU6IENES19EUk9QX0xJU1QsIHVzZUV4aXN0aW5nOiBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmUgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgUGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlPFQgPSBhbnk+IGV4dGVuZHMgQ2RrRHJvcExpc3Q8VD4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQ2RrTGF6eURyb3BMaXN0PFQsIFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPj4ge1xuICBpZCA9IGBwYmwtbmdyaWQtY29sdW1uLXJlb3JkZXItbGlzdC0ke191bmlxdWVJZENvdW50ZXIrK31gO1xuICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyA9ICdob3Jpem9udGFsJztcblxuICBASW5wdXQoKSBnZXQgY29sdW1uUmVvcmRlcigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2NvbHVtblJlb3JkZXI7IH07XG4gIHNldCBjb2x1bW5SZW9yZGVyKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIHRoaXMuX2NvbHVtblJlb3JkZXIgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHdpbGwgbm90IG1vdmUgdGhlIGNvbHVtbiBvbiBkcm9wLlxuICAgKiBJbnN0ZWFkIHlvdSBuZWVkIHRvIGhhbmRsZSB0aGUgZHJvcHBlZCBldmVudC5cbiAgICovXG4gIEBJbnB1dCgpIGdldCBtYW51YWxPdmVycmlkZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX21hbnVhbE92ZXJyaWRlOyB9O1xuICBzZXQgbWFudWFsT3ZlcnJpZGUodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fbWFudWFsT3ZlcnJpZGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgQE91dHB1dCgnY2RrRHJvcERyYWdnaW5nJykgZHJhZ2dpbmc6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIF9kcmFnZ2FibGVzOiBRdWVyeUxpc3Q8Q2RrRHJhZz47XG5cbiAgcHJpdmF0ZSBfY29sdW1uUmVvcmRlciA9IGZhbHNlO1xuICBwcml2YXRlIF9tYW51YWxPdmVycmlkZSA9IGZhbHNlO1xuICBwcml2YXRlIF9yZW1vdmVQbHVnaW46ICh0YWJsZTogUGJsTmdyaWRDb21wb25lbnQ8YW55PikgPT4gdm9pZDtcbiAgcHJpdmF0ZSBsYXN0U3dhcDogRHJhZ1JlZjxQYmxOZ3JpZENvbHVtbkRyYWdEaXJlY3RpdmU8VD4+O1xuICBwcml2YXRlIGxhc3RTb3J0ZWQ6IHsgZHJhZzogRHJhZ1JlZjxQYmxOZ3JpZENvbHVtbkRyYWdEaXJlY3RpdmU8VD4+OyBvZmZzZXQ6IG51bWJlcjsgY2xpZW50UmVjdDogQ2xpZW50UmVjdDsgfTtcblxuICAvLyBTdHVmZiB0byB3b3JrYXJvdW5kIGVuY2Fwc3VsYXRpb24gaW4gQ2RrRHJvcExpc3RcbiAgcHJpdmF0ZSBnZXQgcGJsR2V0SXRlbUluZGV4RnJvbVBvaW50ZXJQb3NpdGlvbigpOiAoaXRlbTogRHJhZ1JlZjxQYmxOZ3JpZENvbHVtbkRyYWdEaXJlY3RpdmU8VD4+LCBwb2ludGVyWDogbnVtYmVyLCBwb2ludGVyWTogbnVtYmVyLCBkZWx0YT86IHt4OiBudW1iZXIsIHk6IG51bWJlcn0pID0+IG51bWJlciB7XG4gICAgcmV0dXJuICh0aGlzLl9kcm9wTGlzdFJlZiBhcyBhbnkpLl9nZXRJdGVtSW5kZXhGcm9tUG9pbnRlclBvc2l0aW9uLmJpbmQodGhpcy5fZHJvcExpc3RSZWYpO1xuICB9XG4gIHByaXZhdGUgZ2V0IHBibEdldFBvc2l0aW9uQ2FjaGVJdGVtcygpOiB7IGRyYWc6IERyYWdSZWY8UGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+Pjsgb2Zmc2V0OiBudW1iZXI7IGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7IH1bXSB7XG4gICAgcmV0dXJuICh0aGlzLl9kcm9wTGlzdFJlZiBhcyBhbnkpLl9pdGVtUG9zaXRpb25zO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHVibGljIHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxUPixcbiAgICAgICAgICAgICAgcGx1Z2luQ3RybDogUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyLFxuICAgICAgICAgICAgICBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgICAgICAgZHJhZ0Ryb3A6IERyYWdEcm9wLFxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIGRpcj86IERpcmVjdGlvbmFsaXR5LFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBncm91cD86IENka0Ryb3BMaXN0R3JvdXA8Q2RrRHJvcExpc3Q+KSB7XG4gICAgc3VwZXIoZWxlbWVudCwgZHJhZ0Ryb3AsIGNoYW5nZURldGVjdG9yUmVmLCBkaXIsIGdyb3VwKTtcbiAgICB0aGlzLl9yZW1vdmVQbHVnaW4gPSBwbHVnaW5DdHJsLnNldFBsdWdpbihQTFVHSU5fS0VZLCB0aGlzKTtcblxuICAgIHRoaXMuZGlyZWN0Q29udGFpbmVyRWxlbWVudCA9ICcucGJsLW5ncmlkLWhlYWRlci1yb3ctbWFpbic7XG4gICAgdGhpcy5kcm9wcGVkLnN1YnNjcmliZSggKGV2ZW50OiBDZGtEcmFnRHJvcDxULCBhbnk+KSA9PiB7XG4gICAgICBpZiAoIXRoaXMubWFudWFsT3ZlcnJpZGUpIHtcbiAgICAgICAgdGhpcy50YWJsZS5jb2x1bW5BcGkubW92ZUNvbHVtbigoZXZlbnQuaXRlbSBhcyBQYmxOZ3JpZENvbHVtbkRyYWdEaXJlY3RpdmU8VD4pLmNvbHVtbiwgZXZlbnQuY3VycmVudEluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZHJhZ2dpbmcuc3Vic2NyaWJlKCBpc0RyYWdnaW5nID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgncGJsLW5ncmlkLWNvbHVtbi1saXN0LWRyYWdnaW5nJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdwYmwtbmdyaWQtY29sdW1uLWxpc3QtZHJhZ2dpbmcnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFN3YXAgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vbmtleVBhdGNoRHJvcExpc3RSZWYoKTtcbiAgfVxuXG4gIC8qIENka0xhenlEcm9wTGlzdCBzdGFydCAqL1xuICAvKipcbiAgICogU2VsZWN0b3IgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkaXJlY3QgY29udGFpbmVyIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb21cbiAgICogdGhlIGBjZGtEcm9wTGlzdGAgZWxlbWVudCBhbmQgZ29pbmcgZG93biB0aGUgRE9NLiBQYXNzaW5nIGFuIGFsdGVybmF0ZSBkaXJlY3QgY29udGFpbmVyIGVsZW1lbnRcbiAgICogaXMgdXNlZnVsIHdoZW4gdGhlIGBjZGtEcm9wTGlzdGAgaXMgbm90IHRoZSBkaXJlY3QgcGFyZW50IChpLmUuIGFuY2VzdG9yIGJ1dCBub3QgZmF0aGVyKVxuICAgKiBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnRzLlxuICAgKi9cbiAgZGlyZWN0Q29udGFpbmVyRWxlbWVudDogc3RyaW5nO1xuICBnZXQgcGJsRHJvcExpc3RSZWYoKTogUGJsRHJvcExpc3RSZWY8UGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlPFQ+PiB7IHJldHVybiB0aGlzLl9kcm9wTGlzdFJlZiBhcyBhbnk7IH1cbiAgb3JpZ2luYWxFbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcbiAgX2RyYWdnYWJsZXNTZXQgPSBuZXcgU2V0PENka0RyYWc+KCk7XG4gIC8vIG5nT25Jbml0KCk6IHZvaWQgeyBDZGtMYXp5RHJvcExpc3QucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7IH1cbiAgYWRkRHJhZyhkcmFnOiBDZGtEcmFnKTogdm9pZCB7IHJldHVybiBDZGtMYXp5RHJvcExpc3QucHJvdG90eXBlLmFkZERyYWcuY2FsbCh0aGlzLCBkcmFnKTsgfVxuICByZW1vdmVEcmFnKGRyYWc6IENka0RyYWcpOiBib29sZWFuIHsgcmV0dXJuIENka0xhenlEcm9wTGlzdC5wcm90b3R5cGUucmVtb3ZlRHJhZy5jYWxsKHRoaXMsIGRyYWcpOyB9XG4gIC8vIGJlZm9yZVN0YXJ0ZWQoKTogdm9pZCB7IENka0xhenlEcm9wTGlzdC5wcm90b3R5cGUuYmVmb3JlU3RhcnRlZC5jYWxsKHRoaXMpOyB9XG4gIC8qIENka0xhenlEcm9wTGlzdCBlbmQgKi9cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBDZGtMYXp5RHJvcExpc3QucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7IC8vIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgdGhpcy5kcm9wcGVkLnN1YnNjcmliZSggZSA9PiB0aGlzLl9wYmxSZXNldCgpICk7XG4gICAgdGhpcy5wYmxEcm9wTGlzdFJlZi5iZWZvcmVFeGl0LnN1YnNjcmliZSggZSA9PiB0aGlzLl9wYmxSZXNldCgpICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIHRoaXMuX3JlbW92ZVBsdWdpbih0aGlzLnRhYmxlKTtcbiAgfVxuXG4gIC8qIHByb3RlY3RlZCAqLyBiZWZvcmVTdGFydGVkKCk6IHZvaWQge1xuICAgIENka0xhenlEcm9wTGlzdC5wcm90b3R5cGUuYmVmb3JlU3RhcnRlZC5jYWxsKHRoaXMpOyAvLyBzdXBlci5iZWZvcmVTdGFydGVkKCk7XG4gICAgdGhpcy5sYXN0U29ydGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhZ2dpbmcubmV4dCh0cnVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX3BibFJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuZHJhZ2dpbmcubmV4dChmYWxzZSk7XG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLnBibEdldFBvc2l0aW9uQ2FjaGVJdGVtcztcbiAgICBzaWJsaW5ncy5mb3JFYWNoKChzaWJsaW5nLCBpbmRleCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIHNpYmxpbmcuZHJhZy5kYXRhLmdldENlbGxzKCkpIHtcbiAgICAgICAgYy5zdHlsZS50cmFuc2Zvcm0gPSBgYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbW9ua2V5UGF0Y2hEcm9wTGlzdFJlZigpOiB2b2lkIHtcbiAgICBjb25zdCB7IF9zb3J0SXRlbSwgZW50ZXIgfSA9IHRoaXMuX2Ryb3BMaXN0UmVmO1xuXG4gICAgdGhpcy5wYmxEcm9wTGlzdFJlZi5lbnRlciA9IChpdGVtOiBQYXJhbWV0ZXJzPHR5cGVvZiBlbnRlcj5bMF0sIHBvaW50ZXJYOiBudW1iZXIsIHBvaW50ZXJZOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTb3J0ZWQgPSB0aGlzLmxhc3RTb3J0ZWRcbiAgICAgIHRoaXMubGFzdFNvcnRlZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChsYXN0U29ydGVkICYmIGxhc3RTb3J0ZWQuZHJhZyA9PT0gaXRlbSkge1xuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIHBvaW50ZXJYID0gbGFzdFNvcnRlZC5jbGllbnRSZWN0LmxlZnQgKyAxIC0gKGlzSG9yaXpvbnRhbCA/IGxhc3RTb3J0ZWQub2Zmc2V0IDogMCk7XG4gICAgICAgIHBvaW50ZXJZID0gbGFzdFNvcnRlZC5jbGllbnRSZWN0LnRvcCArIDEgLSAoIWlzSG9yaXpvbnRhbCA/IGxhc3RTb3J0ZWQub2Zmc2V0IDogMCk7XG4gICAgICB9XG4gICAgICBlbnRlci5jYWxsKHRoaXMuX2Ryb3BMaXN0UmVmLCBpdGVtLCBwb2ludGVyWCwgcG9pbnRlclkpO1xuICAgIH07XG5cbiAgICB0aGlzLnBibERyb3BMaXN0UmVmLl9zb3J0SXRlbSA9IChpdGVtOiBQYXJhbWV0ZXJzPHR5cGVvZiBlbnRlcj5bMF0sIHBvaW50ZXJYOiBudW1iZXIsIHBvaW50ZXJZOiBudW1iZXIsIHBvaW50ZXJEZWx0YToge3g6IG51bWJlciwgeTogbnVtYmVyfSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLnBibEdldFBvc2l0aW9uQ2FjaGVJdGVtcztcbiAgICAgIHRoaXMubGFzdFNvcnRlZCA9IHNpYmxpbmdzLmZpbmQoIHMgPT4gcy5kcmFnID09PSBpdGVtICk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMucGJsR2V0SXRlbUluZGV4RnJvbVBvaW50ZXJQb3NpdGlvbihpdGVtIGFzIERyYWdSZWY8UGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+PiwgcG9pbnRlclgsIHBvaW50ZXJZLCBwb2ludGVyRGVsdGEpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSAtMSAmJiBzaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZE9yZGVyID0gc2libGluZ3Muc2xpY2UoKTtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgIGNvbnN0IHNpYmxpbmdBdE5ld1Bvc2l0aW9uID0gc2libGluZ3NbbmV3SW5kZXhdO1xuXG4gICAgICBpZiAoc2libGluZ0F0TmV3UG9zaXRpb24uZHJhZy5kYXRhLmNvbHVtbi53b250QnVkZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBub3cgbmVlZCB0byBmaW5kIGlmIGJldHdlZW4gY3VycmVudCBhbmQgbmV3IHBvc2l0aW9uIHRoZXJlIGFyZSBpdGVtcyB3aXRoIGB3b250QnVkZ2VgXG4gICAgICBjb25zdCBpdGVtQXRPcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5sYXN0U3dhcCA/IHRoaXMubGFzdFN3YXAgOiBpdGVtO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gc2libGluZ3MuZmluZEluZGV4KCBjdXJyZW50SXRlbSA9PiBjdXJyZW50SXRlbS5kcmFnID09PSBpdGVtQXRPcmlnaW5hbFBvc2l0aW9uICk7XG4gICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKG5ld0luZGV4LCBjdXJyZW50SW5kZXgpXG4gICAgICBjb25zdCBpdGVtc0RyYWdnZWRPdmVyID0gc2libGluZ3Muc2xpY2Uoc3RhcnQsIE1hdGguYWJzKG5ld0luZGV4IC0gY3VycmVudEluZGV4KSArIHN0YXJ0KTtcbiAgICAgIGZvciAoY29uc3QgZHJhZ0l0ZW0gb2YgaXRlbXNEcmFnZ2VkT3Zlcikge1xuICAgICAgICBpZiAoZHJhZ0l0ZW0uZHJhZy5kYXRhLmNvbHVtbi53b250QnVkZ2UgJiYgZHJhZ0l0ZW0uZHJhZyAhPT0gaXRlbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBtb3ZlIHRoZSBpdGVtIG91dHNpZGUgb2YgbG9ja2VkIGdyb3VwIE9SIGludG8gYSBsb2NrZWQgZ3JvdXAuLi4gYm90aCBhcmUgaW52YWxpZC5cbiAgICAgIGlmICghaXRlbS5kYXRhLmNvbHVtbi5jaGVja0dyb3VwTG9ja0NvbnN0cmFpbnQoc2libGluZ0F0TmV3UG9zaXRpb24uZHJhZy5kYXRhLmNvbHVtbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfc29ydEl0ZW0uY2FsbCh0aGlzLl9kcm9wTGlzdFJlZiwgaXRlbSwgcG9pbnRlclgsIHBvaW50ZXJZLCBwb2ludGVyRGVsdGEpO1xuXG4gICAgICB0aGlzLmxhc3RTd2FwID0gc2libGluZ0F0TmV3UG9zaXRpb24uZHJhZztcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBzaWJsaW5ncy5mb3JFYWNoKChzaWJsaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSBwb3NpdGlvbiBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgICAgICBpZiAob2xkT3JkZXJbaW5kZXhdID09PSBzaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCBjIG9mIHNpYmxpbmcuZHJhZy5kYXRhLmdldENlbGxzKCkpIHtcbiAgICAgICAgICAgIGMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7c2libGluZy5vZmZzZXR9cHgsIDAsIDApYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3BibE5ncmlkQ29sdW1uRHJhZ10nLFxuICBleHBvcnRBczogJ3BibE5ncmlkQ29sdW1uRHJhZycsXG4gIGhvc3Q6IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTp1c2UtaG9zdC1wcm9wZXJ0eS1kZWNvcmF0b3JcbiAgICAnY2xhc3MnOiAnY2RrLWRyYWcnLFxuICAgICdbY2xhc3MuY2RrLWRyYWctZHJhZ2dpbmddJzogJ19kcmFnUmVmLmlzRHJhZ2dpbmcoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW1xuICAgIHsgcHJvdmlkZTogRHJhZ0Ryb3AsIHVzZUV4aXN0aW5nOiBQYmxEcmFnRHJvcCB9LFxuICAgIHsgcHJvdmlkZTogQ2RrRHJhZywgdXNlRXhpc3Rpbmc6IFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZSB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgUGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQgPSBhbnk+IGV4dGVuZHMgQ2RrRHJhZzxUPiBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIENka0xhenlEcmFnPFQsIFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPiwgUGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+PiB7XG4gIHJvb3RFbGVtZW50U2VsZWN0b3IgPSAncGJsLW5ncmlkLWhlYWRlci1jZWxsJztcblxuICBjb2x1bW46IFBibENvbHVtbjtcblxuICBASW5wdXQoJ3BibE5ncmlkQ29sdW1uRHJhZycpIHNldCBjb250ZXh0KHZhbHVlOiBQaWNrPFBibE5ncmlkQ2VsbENvbnRleHQ8VD4sICdjb2wnIHwgJ2dyaWQnPiAmIFBhcnRpYWw8UGljazxQYmxOZ3JpZENlbGxDb250ZXh0PFQ+LCAncm93JyB8ICd2YWx1ZSc+Pikge1xuICAgIHRoaXMuX2NvbnRleHQgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbHVtbiA9IHZhbHVlICYmIHZhbHVlLmNvbDtcbiAgICBjb25zdCBwbHVnaW5DdHJsID0gdGhpcy5wbHVnaW5DdHJsID0gdmFsdWUgJiYgUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyLmZpbmQodmFsdWUuZ3JpZCk7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luQ3RybCAmJiBwbHVnaW5DdHJsLmdldFBsdWdpbihQTFVHSU5fS0VZKTtcbiAgICB0aGlzLmNka0Ryb3BMaXN0ID0gcGx1Z2luIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRpc2FibGVkID0gdGhpcy5jb2x1bW4gJiYgdGhpcy5jb2x1bW4ucmVvcmRlciA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbnRleHQ6IFBpY2s8UGJsTmdyaWRDZWxsQ29udGV4dDxUPiwgJ2NvbCcgfCAnZ3JpZCc+ICYgUGFydGlhbDxQaWNrPFBibE5ncmlkQ2VsbENvbnRleHQ8VD4sICdyb3cnIHwgJ3ZhbHVlJz4+XG4gIHByaXZhdGUgcGx1Z2luQ3RybDogUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyO1xuICBwcml2YXRlIGNhY2hlOiBIVE1MRWxlbWVudFtdO1xuXG4gIC8vIENUT1IgSVMgUkVRVUlSRUQgT1IgSVQgV09OVCBXT1JLIElOIEFPVFxuICAvLyBUT0RPOiBUcnkgdG8gcmVtb3ZlIHdoZW4gc3VwcG9ydGluZyBJVllcbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgICAgICAgIEBJbmplY3QoQ0RLX0RST1BfTElTVCkgQE9wdGlvbmFsKCkgQFNraXBTZWxmKCkgZHJvcENvbnRhaW5lcjogQ2RrRHJvcExpc3QsXG4gICAgICAgICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIF9kb2N1bWVudDogYW55LFxuICAgICAgICAgICAgICBfbmdab25lOiBOZ1pvbmUsXG4gICAgICAgICAgICAgIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICBASW5qZWN0KENES19EUkFHX0NPTkZJRykgY29uZmlnOiBEcmFnUmVmQ29uZmlnLFxuICAgICAgICAgICAgICBfZGlyOiBEaXJlY3Rpb25hbGl0eSxcbiAgICAgICAgICAgICAgZHJhZ0Ryb3A6IERyYWdEcm9wLFxuICAgICAgICAgICAgICBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgc3VwZXIoXG4gICAgICBlbGVtZW50LFxuICAgICAgZHJvcENvbnRhaW5lcixcbiAgICAgIF9kb2N1bWVudCxcbiAgICAgIF9uZ1pvbmUsXG4gICAgICBfdmlld0NvbnRhaW5lclJlZixcbiAgICAgIGNvbmZpZyxcbiAgICAgIF9kaXIsXG4gICAgICBkcmFnRHJvcCxcbiAgICAgIF9jaGFuZ2VEZXRlY3RvclJlZixcbiAgICApO1xuICB9XG5cbiAgLyogQ2RrTGF6eURyYWcgc3RhcnQgKi9cbiAgLyoqXG4gICAqIEEgY2xhc3MgdG8gc2V0IHdoZW4gdGhlIHJvb3QgZWxlbWVudCBpcyBub3QgdGhlIGhvc3QgZWxlbWVudC4gKGkuZS4gd2hlbiBgY2RrRHJhZ1Jvb3RFbGVtZW50YCBpcyB1c2VkKS5cbiAgICovXG4gIEBJbnB1dCgnY2RrRHJhZ1Jvb3RFbGVtZW50Q2xhc3MnKSBzZXQgcm9vdEVsZW1lbnRTZWxlY3RvckNsYXNzKHZhbHVlOiBzdHJpbmcpIHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Jvb3RDbGFzcyAmJiB0aGlzLl9ob3N0Tm90Um9vdCkge1xuICAgICAgaWYgKHRoaXMuX3Jvb3RDbGFzcykge1xuICAgICAgICB0aGlzLmdldFJvb3RFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9yb290Q2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRSb290RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoLi4udmFsdWUuc3BsaXQoJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3Jvb3RDbGFzcyA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHBibERyYWdSZWYoKTogUGJsRHJhZ1JlZjxQYmxOZ3JpZENvbHVtbkRyYWdEaXJlY3RpdmU8VD4+IHsgcmV0dXJuIHRoaXMuX2RyYWdSZWYgYXMgYW55OyB9XG5cbiAgQElucHV0KCkgZ2V0IGNka0Ryb3BMaXN0KCk6IFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPiB7IHJldHVybiB0aGlzLmRyb3BDb250YWluZXIgYXMgUGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlPFQ+OyB9XG4gIHNldCBjZGtEcm9wTGlzdCh2YWx1ZTogUGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlPFQ+KSB7XG4gICAgLy8gVE8gU1VQUE9SVCBgY2RrRHJvcExpc3RgIHZpYSBzdHJpbmcgaW5wdXQgKElEKSB3ZSBuZWVkIGEgcmVhY3RpdmUgcmVnaXN0cnkuLi5cbiAgICBpZiAodGhpcy5jZGtEcm9wTGlzdCkge1xuICAgICAgdGhpcy5jZGtEcm9wTGlzdC5yZW1vdmVEcmFnKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmRyb3BDb250YWluZXIgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX2RyYWdSZWYuX3dpdGhEcm9wQ29udGFpbmVyKHZhbHVlLl9kcm9wTGlzdFJlZik7XG4gICAgICB2YWx1ZS5hZGREcmFnKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9yb290Q2xhc3M6IHN0cmluZztcbiAgX2hvc3ROb3RSb290ID0gZmFsc2U7XG4gIG5nT25Jbml0KCk6IHZvaWQgeyBDZGtMYXp5RHJhZy5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTsgfVxuICAvLyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7IENka0xhenlEcmFnLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTsgc3VwZXIubmdBZnRlclZpZXdJbml0KCk7IH1cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7IENka0xhenlEcmFnLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpOyAgc3VwZXIubmdPbkRlc3Ryb3koKTsgfVxuICAvKiBDZGtMYXp5RHJhZyBlbmQgKi9cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgQ2RrTGF6eURyYWcucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuXG4gICAgdGhpcy5fZHJhZ1JlZi5iZWZvcmVTdGFydGVkLnN1YnNjcmliZSggKCkgPT4ge1xuICAgICAgY29uc3QgeyBjZGtEcm9wTGlzdCB9ID0gdGhpcztcbiAgICAgIGlmIChjZGtEcm9wTGlzdCAmJiBjZGtEcm9wTGlzdC5jb2x1bW5SZW9yZGVyICYmIHRoaXMuX2NvbnRleHQuY29sLnJlb3JkZXIpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYWxsb3cgYSBuZXcgZHJhZ2dpbmcgc2Vzc2lvbiBiZWZvcmUgdGhlIHByZXZpb3VzIGVuZHMuXG4gICAgICAgIC8vIHRoaXMgc291bmQgaW1wb3NzaWJsZSwgYnV0IGR1ZSB0byBhbmltYXRpb24gdHJhbnNpdGlvbnMgaXRzIGFjdHVhbGx5IGlzLlxuICAgICAgICAvLyBpZiB0aGUgYHRyYW5zaXRpb25lbmRgIGlzIGxvbmcgZW5vdWdoLCBhIG5ldyBkcmFnIGNhbiBzdGFydC4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyB0aGUgYGRpc2FibGVkYCBzdGF0ZSBpcyBjaGVja2VkIGJ5IHBvaW50ZXJEb3duIEFGVEVSIGNhbGxpbmcgYmVmb3JlIHN0YXJ0IHNvIHdlIGNhbiBjYW5jZWwgdGhlIHN0YXJ0Li4uXG4gICAgICAgIGlmIChjZGtEcm9wTGlzdC5fZHJvcExpc3RSZWYuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGFydGVkLnN1YnNjcmliZSggKCkgPT4gdGhpcy5fY29udGV4dC5jb2wuY29sdW1uRGVmLmlzRHJhZ2dpbmcgPSB0cnVlICk7XG4gICAgdGhpcy5lbmRlZC5zdWJzY3JpYmUoICgpID0+IHRoaXMuX2NvbnRleHQuY29sLmNvbHVtbkRlZi5pc0RyYWdnaW5nID0gZmFsc2UgKTtcbiAgfVxuXG4gIGdldENlbGxzKCk6IEhUTUxFbGVtZW50W10ge1xuICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuX2NvbnRleHQuY29sLmNvbHVtbkRlZi5xdWVyeUNlbGxFbGVtZW50cygndGFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gYGA7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIl19