/**
 * @fileoverview added by tsickle
 * Generated from: lib/grid/directives/cell.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __decorate, __extends, __metadata, __values } from "tslib";
// tslint:disable:use-host-property-decorator
// tslint:disable:directive-selector
import { first, filter } from 'rxjs/operators';
import { Component, Directive, ElementRef, ChangeDetectionStrategy, ViewEncapsulation, ViewContainerRef, ViewChild, NgZone, Input, } from '@angular/core';
import { CdkHeaderCell, CdkCell, CdkFooterCell } from '@angular/cdk/table';
import { UnRx } from '@pebula/utils';
import { PblNgridComponent } from '../ngrid.component';
import { uniqueColumnCss, uniqueColumnTypeCss, COLUMN_EDITABLE_CELL_CLASS } from '../circular-dep-bridge';
import { isPblColumn, isPblColumnGroup } from '../columns';
import { MetaCellContext, PblRowContext } from '../context/index';
import { PblNgridColumnDef } from './column-def';
import { PblNgridDataHeaderExtensionContext, PblNgridMultiComponentRegistry, PblNgridMultiTemplateRegistry } from './registry.directives';
/** @type {?} */
var HEADER_GROUP_CSS = "pbl-header-group-cell";
/** @type {?} */
var HEADER_GROUP_PLACE_HOLDER_CSS = "pbl-header-group-cell-placeholder";
/**
 * @param {?} el
 * @param {?} column
 * @return {?}
 */
function initCellElement(el, column) {
    var e_1, _a;
    el.classList.add(uniqueColumnCss(column.columnDef));
    if (column.type) {
        el.classList.add(uniqueColumnTypeCss(column.type));
    }
    if (column.css) {
        /** @type {?} */
        var css = column.css.split(' ');
        try {
            for (var css_1 = __values(css), css_1_1 = css_1.next(); !css_1_1.done; css_1_1 = css_1.next()) {
                var c = css_1_1.value;
                el.classList.add(c);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (css_1_1 && !css_1_1.done && (_a = css_1.return)) _a.call(css_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}
/**
 * @param {?} el
 * @param {?} column
 * @return {?}
 */
function initDataCellElement(el, column) {
    if (column.editable && column.editorTpl) {
        el.classList.add(COLUMN_EDITABLE_CELL_CLASS);
    }
}
/** @type {?} */
var lastDataHeaderExtensions = new Map();
/**
 * @this {?}
 * @return {?}
 */
function applyWidth() {
    this.columnDef.applyWidth(this.el);
}
/**
 * @this {?}
 * @return {?}
 */
function applySourceWidth() {
    this.columnDef.applySourceWidth(this.el);
}
/**
 * Header cell component.
 * The header cell component will render the header cell template and add the proper classes and role.
 *
 * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.
 * These extensions add features to the cells either as a template instance or as a component instance.
 * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...
 * @template T
 */
var PblNgridHeaderCellComponent = /** @class */ (function (_super) {
    __extends(PblNgridHeaderCellComponent, _super);
    function PblNgridHeaderCellComponent(columnDef, grid, elementRef, zone) {
        var _this = _super.call(this, columnDef, elementRef) || this;
        _this.columnDef = columnDef;
        _this.grid = grid;
        _this.elementRef = elementRef;
        _this.zone = zone;
        _this.table = grid;
        /** @type {?} */
        var column = columnDef.column;
        /** @type {?} */
        var el = _this.el = elementRef.nativeElement;
        if (isPblColumnGroup(column)) {
            el.classList.add(HEADER_GROUP_CSS);
            if (column.placeholder) {
                el.classList.add(HEADER_GROUP_PLACE_HOLDER_CSS);
            }
        }
        return _this;
    }
    /**
     * @return {?}
     */
    PblNgridHeaderCellComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var col = this.columnDef.column;
        /** @type {?} */
        var predicate;
        /** @type {?} */
        var view;
        /** @type {?} */
        var widthUpdater;
        if (isPblColumn(col)) {
            /** @type {?} */
            var gridWidthRow_1 = this.el.parentElement.hasAttribute('gridWidthRow');
            widthUpdater = gridWidthRow_1 ? applySourceWidth : applyWidth;
            predicate = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return (!gridWidthRow_1 && event.reason !== 'update') || (gridWidthRow_1 && event.reason !== 'resize'); });
            view = !gridWidthRow_1 ? this.initMainHeaderColumnView(col) : undefined;
        }
        else {
            widthUpdater = applySourceWidth;
            predicate = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return event.reason !== 'resize'; });
            view = this.initMetaHeaderColumnView(col);
        }
        this.columnDef.widthChange
            .pipe(filter(predicate), UnRx(this))
            .subscribe(widthUpdater.bind(this));
        view && view.detectChanges();
        widthUpdater.call(this);
        initCellElement(this.el, col);
    };
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    PblNgridHeaderCellComponent.prototype.initMainHeaderColumnView = /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    function (col) {
        var _this = this;
        this.cellCtx = PblNgridDataHeaderExtensionContext.createDateHeaderCtx((/** @type {?} */ (this)), this.vcRef.injector);
        /** @type {?} */
        var context = (/** @type {?} */ (this.cellCtx));
        /** @type {?} */
        var view = this.vcRef.createEmbeddedView(col.headerCellTpl, context);
        this.zone.onStable
            .pipe(first())
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this.runHeaderExtensions(context, (/** @type {?} */ (view)));
            /** @type {?} */
            var v = _this.vcRef.get(0);
            // at this point the view might get destroyed, its possible...
            if (!v.destroyed) {
                v.detectChanges();
            }
        }));
        return view;
    };
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    PblNgridHeaderCellComponent.prototype.initMetaHeaderColumnView = /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    function (col) {
        this.cellCtx = MetaCellContext.create(col, this.grid);
        return this.vcRef.createEmbeddedView(col.template, this.cellCtx);
    };
    /**
     * @protected
     * @param {?} context
     * @param {?} view
     * @return {?}
     */
    PblNgridHeaderCellComponent.prototype.runHeaderExtensions = /**
     * @protected
     * @param {?} context
     * @param {?} view
     * @return {?}
     */
    function (context, view) {
        var e_2, _a;
        var _this = this;
        // we collect the first header extension for each unique name only once per grid instance
        /** @type {?} */
        var extensions = lastDataHeaderExtensions.get(this.grid);
        if (!extensions) {
            /** @type {?} */
            var dataHeaderExtensions_1 = new Map();
            this.grid.registry.forMulti('dataHeaderExtensions', (/**
             * @param {?} values
             * @return {?}
             */
            function (values) {
                var e_3, _a;
                try {
                    for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                        var value = values_1_1.value;
                        if (!dataHeaderExtensions_1.has(value.name)) {
                            dataHeaderExtensions_1.set(value.name, value);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }));
            extensions = Array.from(dataHeaderExtensions_1.values());
            lastDataHeaderExtensions.set(this.grid, extensions);
            // destroy it on the next turn, we know all cells will render on the same turn.
            this.zone.onStable.pipe(first()).subscribe((/**
             * @return {?}
             */
            function () { return lastDataHeaderExtensions.delete(_this.grid); }));
        }
        var rootNodes = view.rootNodes;
        try {
            for (var extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {
                var ext = extensions_1_1.value;
                if (!ext.shouldRender || ext.shouldRender(context)) {
                    if (ext instanceof PblNgridMultiTemplateRegistry) {
                        /** @type {?} */
                        var extView = this.vcRef.createEmbeddedView(ext.tRef, context);
                        extView.markForCheck();
                    }
                    else if (ext instanceof PblNgridMultiComponentRegistry) {
                        rootNodes = this.createComponent(ext, context, rootNodes);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * @protected
     * @param {?} ext
     * @param {?} context
     * @param {?} rootNodes
     * @return {?}
     */
    PblNgridHeaderCellComponent.prototype.createComponent = /**
     * @protected
     * @param {?} ext
     * @param {?} context
     * @param {?} rootNodes
     * @return {?}
     */
    function (ext, context, rootNodes) {
        /** @type {?} */
        var factory = ext.getFactory(context);
        /** @type {?} */
        var projectedContent = [];
        if (ext.projectContent) {
            projectedContent.push(rootNodes);
        }
        /** @type {?} */
        var cmpRef = this.vcRef.createComponent(factory, this.vcRef.length, null, projectedContent);
        if (ext.projectContent) {
            rootNodes = [cmpRef.location.nativeElement];
        }
        if (ext.onCreated) {
            ext.onCreated(context, cmpRef);
        }
        return rootNodes;
    };
    PblNgridHeaderCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'pbl-ngrid-header-cell',
                    host: {
                        class: 'pbl-ngrid-header-cell',
                        role: 'columnheader',
                    },
                    exportAs: 'ngridHeaderCell',
                    template: "<ng-container #vcRef></ng-container>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    /** @nocollapse */
    PblNgridHeaderCellComponent.ctorParameters = function () { return [
        { type: PblNgridColumnDef },
        { type: PblNgridComponent },
        { type: ElementRef },
        { type: NgZone }
    ]; };
    PblNgridHeaderCellComponent.propDecorators = {
        vcRef: [{ type: ViewChild, args: ['vcRef', { read: ViewContainerRef, static: true },] }]
    };
    /**
     * Header cell component.
     * The header cell component will render the header cell template and add the proper classes and role.
     *
     * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.
     * These extensions add features to the cells either as a template instance or as a component instance.
     * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...
     * @template T
     */
    PblNgridHeaderCellComponent = __decorate([
        UnRx(),
        __metadata("design:paramtypes", [PblNgridColumnDef,
            PblNgridComponent,
            ElementRef,
            NgZone])
    ], PblNgridHeaderCellComponent);
    return PblNgridHeaderCellComponent;
}(CdkHeaderCell));
export { PblNgridHeaderCellComponent };
if (false) {
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.vcRef;
    /**
     * @type {?}
     * @private
     */
    PblNgridHeaderCellComponent.prototype.el;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.cellCtx;
    /**
     * @deprecated use grid instead
     * @type {?}
     */
    PblNgridHeaderCellComponent.prototype.table;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.columnDef;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.grid;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    PblNgridHeaderCellComponent.prototype.zone;
}
/**
 * Cell template container that adds the right classes and role.
 */
var PblNgridCellDirective = /** @class */ (function (_super) {
    __extends(PblNgridCellDirective, _super);
    function PblNgridCellDirective(colDef, elementRef) {
        var _this = _super.call(this, colDef, elementRef) || this;
        _this.colDef = colDef;
        _this.focused = false;
        _this.selected = false;
        _this.colIndex = _this.colDef.grid.columnApi.indexOf((/** @type {?} */ (colDef.column)));
        _this.el = elementRef.nativeElement;
        colDef.applyWidth(_this.el);
        initCellElement(_this.el, colDef.column);
        initDataCellElement(_this.el, colDef.column);
        /*  Apply width changes to this data cell
            We don't update "update" events because they are followed by a resize event which will update the absolute value (px) */
        colDef.widthChange
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.reason !== 'update'; })), UnRx(_this))
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.colDef.applyWidth(_this.el); }));
        return _this;
    }
    Object.defineProperty(PblNgridCellDirective.prototype, "rowCtx", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._rowCtx) {
                this._rowCtx = value;
                this.ngDoCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PblNgridCellDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this._rowCtx) {
            /** @type {?} */
            var cellContext = this.cellCtx = this._rowCtx.cell(this.colIndex);
            if (cellContext.focused !== this.focused) {
                if (this.focused = cellContext.focused) {
                    this.el.classList.add('pbl-ngrid-cell-focused');
                }
                else {
                    this.el.classList.remove('pbl-ngrid-cell-focused');
                }
            }
            if (this.cellCtx.selected !== this.selected) {
                if (this.selected = cellContext.selected) {
                    this.el.classList.add('pbl-ngrid-cell-selected');
                }
                else {
                    this.el.classList.remove('pbl-ngrid-cell-selected');
                }
            }
        }
    };
    PblNgridCellDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'pbl-ngrid-cell',
                    host: {
                        'class': 'pbl-ngrid-cell',
                        'role': 'gridcell',
                    },
                    exportAs: 'pblNgridCell',
                },] }
    ];
    /** @nocollapse */
    PblNgridCellDirective.ctorParameters = function () { return [
        { type: PblNgridColumnDef },
        { type: ElementRef }
    ]; };
    PblNgridCellDirective.propDecorators = {
        rowCtx: [{ type: Input }]
    };
    /**
     * Cell template container that adds the right classes and role.
     */
    PblNgridCellDirective = __decorate([
        UnRx(),
        __metadata("design:paramtypes", [PblNgridColumnDef, ElementRef])
    ], PblNgridCellDirective);
    return PblNgridCellDirective;
}(CdkCell));
export { PblNgridCellDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype._rowCtx;
    /** @type {?} */
    PblNgridCellDirective.prototype.cellCtx;
    /**
     * The position of the column def among all columns regardless of visibility.
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.colIndex;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.focused;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.selected;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.colDef;
}
var PblNgridFooterCellDirective = /** @class */ (function (_super) {
    __extends(PblNgridFooterCellDirective, _super);
    function PblNgridFooterCellDirective(columnDef, grid, elementRef) {
        var _this = _super.call(this, columnDef, elementRef) || this;
        _this.columnDef = columnDef;
        _this.grid = grid;
        _this.table = grid;
        _this.el = elementRef.nativeElement;
        /** @type {?} */
        var column = columnDef.column;
        applyWidth.call(_this);
        initCellElement(_this.el, column);
        columnDef.widthChange
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.reason !== 'update'; })), UnRx(_this))
            .subscribe(applyWidth.bind(_this));
        return _this;
    }
    /**
     * @return {?}
     */
    PblNgridFooterCellDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.cellCtx = MetaCellContext.create(this.columnDef.column, this.grid);
    };
    PblNgridFooterCellDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'pbl-ngrid-footer-cell',
                    host: {
                        'class': 'pbl-ngrid-footer-cell',
                        'role': 'gridcell',
                    },
                    exportAs: 'ngridFooterCell',
                },] }
    ];
    /** @nocollapse */
    PblNgridFooterCellDirective.ctorParameters = function () { return [
        { type: PblNgridColumnDef },
        { type: PblNgridComponent },
        { type: ElementRef }
    ]; };
    PblNgridFooterCellDirective = __decorate([
        UnRx(),
        __metadata("design:paramtypes", [PblNgridColumnDef,
            PblNgridComponent,
            ElementRef])
    ], PblNgridFooterCellDirective);
    return PblNgridFooterCellDirective;
}(CdkFooterCell));
export { PblNgridFooterCellDirective };
if (false) {
    /** @type {?} */
    PblNgridFooterCellDirective.prototype.cellCtx;
    /**
     * @deprecated use grid instead
     * @type {?}
     */
    PblNgridFooterCellDirective.prototype.table;
    /**
     * @type {?}
     * @private
     */
    PblNgridFooterCellDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    PblNgridFooterCellDirective.prototype.columnDef;
    /** @type {?} */
    PblNgridFooterCellDirective.prototype.grid;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BwZWJ1bGEvbmdyaWQvIiwic291cmNlcyI6WyJsaWIvZ3JpZC9kaXJlY3RpdmVzL2NlbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9DLE9BQU8sRUFFTCxTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFFVix1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQixTQUFTLEVBQ1QsTUFBTSxFQUVOLEtBQUssR0FDTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXJDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxlQUFlLEVBQUUsbUJBQW1CLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRyxPQUFPLEVBQW9ELFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUM3RyxPQUFPLEVBQUUsZUFBZSxFQUEyQixhQUFhLEVBQWtCLE1BQU0sa0JBQWtCLENBQUM7QUFFM0csT0FBTyxFQUFFLGlCQUFpQixFQUFvQixNQUFNLGNBQWMsQ0FBQztBQUNuRSxPQUFPLEVBQUUsa0NBQWtDLEVBQUUsOEJBQThCLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7SUFFcEksZ0JBQWdCLEdBQUcsdUJBQXVCOztJQUMxQyw2QkFBNkIsR0FBRyxtQ0FBbUM7Ozs7OztBQUV6RSxTQUFTLGVBQWUsQ0FBQyxFQUFlLEVBQUUsTUFBYzs7SUFDdEQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLE1B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QXlCLEVBQUMsRUFDM0MsSUFBSSxDQUFDLEtBQUksQ0FBQyxDQUNYO2FBQ0EsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLENBQUMsQ0FBQzs7SUFDdEMsQ0FBQzs7OztJQUVELDhDQUFROzs7SUFBUjtRQUNFLElBQUksQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUUsQ0FBQzs7Z0JBbkNGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO29CQUNqQyxJQUFJLEVBQUU7d0JBQ0osT0FBTyxFQUFFLHVCQUF1Qjt3QkFDaEMsTUFBTSxFQUFFLFVBQVU7cUJBQ25CO29CQUNELFFBQVEsRUFBRSxpQkFBaUI7aUJBQzNCOzs7O2dCQTFRTyxpQkFBaUI7Z0JBTGpCLGlCQUFpQjtnQkFieEIsVUFBVTs7SUE4UkMsMkJBQTJCO1FBRHRDLElBQUksRUFBRTt5Q0FPeUIsaUJBQWlCO1lBQ3ZCLGlCQUFpQjtZQUNsQixVQUFVO09BUnZCLDJCQUEyQixDQTJCdkM7SUFBRCxrQ0FBQztDQUFBLENBM0JnRCxhQUFhLEdBMkI3RDtTQTNCWSwyQkFBMkI7OztJQUN0Qyw4Q0FBeUI7Ozs7O0lBRXpCLDRDQUFrQzs7Ozs7SUFFbEMseUNBQXdCOzs7OztJQUNaLGdEQUFvRTs7SUFDcEUsMkNBQThCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6dXNlLWhvc3QtcHJvcGVydHktZGVjb3JhdG9yXG4vLyB0c2xpbnQ6ZGlzYWJsZTpkaXJlY3RpdmUtc2VsZWN0b3JcbmltcG9ydCB7IGZpcnN0LCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBPbkluaXQsXG4gIENvbXBvbmVudCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBEb0NoZWNrLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFZpZXdDaGlsZCxcbiAgTmdab25lLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIElucHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENka0hlYWRlckNlbGwsIENka0NlbGwsIENka0Zvb3RlckNlbGwgfSBmcm9tICdAYW5ndWxhci9jZGsvdGFibGUnO1xuaW1wb3J0IHsgVW5SeCB9IGZyb20gJ0BwZWJ1bGEvdXRpbHMnO1xuXG5pbXBvcnQgeyBQYmxOZ3JpZENvbXBvbmVudCB9IGZyb20gJy4uL25ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyB1bmlxdWVDb2x1bW5Dc3MsIHVuaXF1ZUNvbHVtblR5cGVDc3MsIENPTFVNTl9FRElUQUJMRV9DRUxMX0NMQVNTIH0gZnJvbSAnLi4vY2lyY3VsYXItZGVwLWJyaWRnZSc7XG5pbXBvcnQgeyBDT0xVTU4sIFBibE1ldGFDb2x1bW4sIFBibENvbHVtbiwgUGJsQ29sdW1uR3JvdXAsIGlzUGJsQ29sdW1uLCBpc1BibENvbHVtbkdyb3VwIH0gZnJvbSAnLi4vY29sdW1ucyc7XG5pbXBvcnQgeyBNZXRhQ2VsbENvbnRleHQsIFBibE5ncmlkTWV0YUNlbGxDb250ZXh0LCBQYmxSb3dDb250ZXh0LCBQYmxDZWxsQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvaW5kZXgnO1xuaW1wb3J0IHsgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwIH0gZnJvbSAnLi4vc2VydmljZXMvZ3JpZC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7IFBibE5ncmlkQ29sdW1uRGVmLCBXaWR0aENoYW5nZUV2ZW50IH0gZnJvbSAnLi9jb2x1bW4tZGVmJztcbmltcG9ydCB7IFBibE5ncmlkRGF0YUhlYWRlckV4dGVuc2lvbkNvbnRleHQsIFBibE5ncmlkTXVsdGlDb21wb25lbnRSZWdpc3RyeSwgUGJsTmdyaWRNdWx0aVRlbXBsYXRlUmVnaXN0cnkgfSBmcm9tICcuL3JlZ2lzdHJ5LmRpcmVjdGl2ZXMnO1xuXG5jb25zdCBIRUFERVJfR1JPVVBfQ1NTID0gYHBibC1oZWFkZXItZ3JvdXAtY2VsbGA7XG5jb25zdCBIRUFERVJfR1JPVVBfUExBQ0VfSE9MREVSX0NTUyA9IGBwYmwtaGVhZGVyLWdyb3VwLWNlbGwtcGxhY2Vob2xkZXJgO1xuXG5mdW5jdGlvbiBpbml0Q2VsbEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50LCBjb2x1bW46IENPTFVNTik6IHZvaWQge1xuICBlbC5jbGFzc0xpc3QuYWRkKHVuaXF1ZUNvbHVtbkNzcyhjb2x1bW4uY29sdW1uRGVmKSk7XG4gIGlmIChjb2x1bW4udHlwZSkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQodW5pcXVlQ29sdW1uVHlwZUNzcyhjb2x1bW4udHlwZSkpO1xuICB9XG4gIGlmIChjb2x1bW4uY3NzKSB7XG4gICAgY29uc3QgY3NzID0gY29sdW1uLmNzcy5zcGxpdCgnICcpO1xuICAgIGZvciAoY29uc3QgYyBvZiBjc3MpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhQ2VsbEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50LCBjb2x1bW46IFBibENvbHVtbik6IHZvaWQge1xuICBpZiAoY29sdW1uLmVkaXRhYmxlICYmIGNvbHVtbi5lZGl0b3JUcGwpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKENPTFVNTl9FRElUQUJMRV9DRUxMX0NMQVNTKTtcbiAgfVxufVxuXG5jb25zdCBsYXN0RGF0YUhlYWRlckV4dGVuc2lvbnMgPSBuZXcgTWFwPFBibE5ncmlkQ29tcG9uZW50PGFueT4sIFBibE5ncmlkTXVsdGlSZWdpc3RyeU1hcFsnZGF0YUhlYWRlckV4dGVuc2lvbnMnXVtdPigpO1xuXG5mdW5jdGlvbiBhcHBseVdpZHRoKHRoaXM6IHsgY29sdW1uRGVmOiBQYmxOZ3JpZENvbHVtbkRlZjsgZWw6IEhUTUxFbGVtZW50IH0pIHtcbiAgdGhpcy5jb2x1bW5EZWYuYXBwbHlXaWR0aCh0aGlzLmVsKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlTb3VyY2VXaWR0aCh0aGlzOiB7IGNvbHVtbkRlZjogUGJsTmdyaWRDb2x1bW5EZWY7IGVsOiBIVE1MRWxlbWVudCB9KSB7XG4gIHRoaXMuY29sdW1uRGVmLmFwcGx5U291cmNlV2lkdGgodGhpcy5lbCk7XG59XG5cbi8qKlxuICogSGVhZGVyIGNlbGwgY29tcG9uZW50LlxuICogVGhlIGhlYWRlciBjZWxsIGNvbXBvbmVudCB3aWxsIHJlbmRlciB0aGUgaGVhZGVyIGNlbGwgdGVtcGxhdGUgYW5kIGFkZCB0aGUgcHJvcGVyIGNsYXNzZXMgYW5kIHJvbGUuXG4gKlxuICogSXQgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIG1hbmFnaW5nIHRoZSBhbnkgYGRhdGFIZWFkZXJFeHRlbnNpb25zYCByZWdpc3RlcmVkIGluIHRoZSByZWdpc3RyeS5cbiAqIFRoZXNlIGV4dGVuc2lvbnMgYWRkIGZlYXR1cmVzIHRvIHRoZSBjZWxscyBlaXRoZXIgYXMgYSB0ZW1wbGF0ZSBpbnN0YW5jZSBvciBhcyBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEV4YW1wbGVzOiBTb3J0aW5nIGJlaGF2aW9yLCBkcmFnJmRyb3AvcmVzaXplIGhhbmRsZXJzLCBtZW51cyBldGMuLi5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAncGJsLW5ncmlkLWhlYWRlci1jZWxsJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAncGJsLW5ncmlkLWhlYWRlci1jZWxsJyxcbiAgICByb2xlOiAnY29sdW1uaGVhZGVyJyxcbiAgfSxcbiAgZXhwb3J0QXM6ICduZ3JpZEhlYWRlckNlbGwnLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgI3ZjUmVmPjwvbmctY29udGFpbmVyPmAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxufSlcbkBVblJ4KClcbmV4cG9ydCBjbGFzcyBQYmxOZ3JpZEhlYWRlckNlbGxDb21wb25lbnQ8VCBleHRlbmRzIENPTFVNTiA9IENPTFVNTj4gZXh0ZW5kcyBDZGtIZWFkZXJDZWxsIGltcGxlbWVudHMgT25Jbml0IHtcbiAgQFZpZXdDaGlsZCgndmNSZWYnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZSB9KSB2Y1JlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICBwcml2YXRlIGVsOiBIVE1MRWxlbWVudDtcblxuICBjZWxsQ3R4OiBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0IHwgTWV0YUNlbGxDb250ZXh0O1xuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgZ3JpZCBpbnN0ZWFkICovXG4gIHJlYWRvbmx5IHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxUPjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgY29sdW1uRGVmOiBQYmxOZ3JpZENvbHVtbkRlZjxUPixcbiAgICAgICAgICAgICAgcHVibGljIHJlYWRvbmx5IGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50PGFueT4sXG4gICAgICAgICAgICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIHpvbmU6IE5nWm9uZSkge1xuICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgdGhpcy50YWJsZSA9IGdyaWQ7XG5cbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5EZWYuY29sdW1uO1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgIGlmIChpc1BibENvbHVtbkdyb3VwKGNvbHVtbikpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoSEVBREVSX0dST1VQX0NTUyk7XG4gICAgICBpZiAoY29sdW1uLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoSEVBREVSX0dST1VQX1BMQUNFX0hPTERFUl9DU1MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbDogQ09MVU1OID0gdGhpcy5jb2x1bW5EZWYuY29sdW1uO1xuICAgIGxldCBwcmVkaWNhdGU6IChldmVudDogV2lkdGhDaGFuZ2VFdmVudCkgPT4gYm9vbGVhbjtcbiAgICBsZXQgdmlldzogRW1iZWRkZWRWaWV3UmVmPFBibE5ncmlkTWV0YUNlbGxDb250ZXh0PGFueSwgUGJsTWV0YUNvbHVtbiB8IFBibENvbHVtbj4+XG4gICAgbGV0IHdpZHRoVXBkYXRlcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuXG4gICAgaWYgKGlzUGJsQ29sdW1uKGNvbCkpIHtcbiAgICAgIGNvbnN0IGdyaWRXaWR0aFJvdyA9IHRoaXMuZWwucGFyZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2dyaWRXaWR0aFJvdycpO1xuICAgICAgd2lkdGhVcGRhdGVyID0gZ3JpZFdpZHRoUm93ID8gYXBwbHlTb3VyY2VXaWR0aCA6IGFwcGx5V2lkdGg7XG4gICAgICBwcmVkaWNhdGUgPSBldmVudCA9PiAoIWdyaWRXaWR0aFJvdyAmJiBldmVudC5yZWFzb24gIT09ICd1cGRhdGUnKSB8fCAoZ3JpZFdpZHRoUm93ICYmIGV2ZW50LnJlYXNvbiAhPT0gJ3Jlc2l6ZScpO1xuICAgICAgdmlldyA9ICFncmlkV2lkdGhSb3cgPyB0aGlzLmluaXRNYWluSGVhZGVyQ29sdW1uVmlldyhjb2wpIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aFVwZGF0ZXIgPSBhcHBseVNvdXJjZVdpZHRoO1xuICAgICAgcHJlZGljYXRlID0gZXZlbnQgPT4gZXZlbnQucmVhc29uICE9PSAncmVzaXplJztcbiAgICAgIHZpZXcgPSB0aGlzLmluaXRNZXRhSGVhZGVyQ29sdW1uVmlldyhjb2wpO1xuICAgIH1cblxuICAgIHRoaXMuY29sdW1uRGVmLndpZHRoQ2hhbmdlXG4gICAgICAucGlwZShmaWx0ZXIocHJlZGljYXRlKSwgVW5SeCh0aGlzKSlcbiAgICAgIC5zdWJzY3JpYmUod2lkdGhVcGRhdGVyLmJpbmQodGhpcykpO1xuXG4gICAgdmlldyAmJiB2aWV3LmRldGVjdENoYW5nZXMoKTtcbiAgICB3aWR0aFVwZGF0ZXIuY2FsbCh0aGlzKTtcbiAgICBpbml0Q2VsbEVsZW1lbnQodGhpcy5lbCwgY29sKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbml0TWFpbkhlYWRlckNvbHVtblZpZXcoY29sOiBQYmxDb2x1bW4pIHtcbiAgICB0aGlzLmNlbGxDdHggPSBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LmNyZWF0ZURhdGVIZWFkZXJDdHgodGhpcyBhcyBQYmxOZ3JpZEhlYWRlckNlbGxDb21wb25lbnQ8UGJsQ29sdW1uPiwgdGhpcy52Y1JlZi5pbmplY3Rvcik7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY2VsbEN0eCBhcyBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0O1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZjUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhjb2wuaGVhZGVyQ2VsbFRwbCwgY29udGV4dCk7XG4gICAgdGhpcy56b25lLm9uU3RhYmxlXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSggKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkhlYWRlckV4dGVuc2lvbnMoY29udGV4dCwgdmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8UGJsTmdyaWRNZXRhQ2VsbENvbnRleHQ8YW55LCBQYmxDb2x1bW4+Pik7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnZjUmVmLmdldCgwKTtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgdmlldyBtaWdodCBnZXQgZGVzdHJveWVkLCBpdHMgcG9zc2libGUuLi5cbiAgICAgICAgaWYgKCF2LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gdmlldztcbiAgfVxuXG4gIHByb3RlY3RlZCBpbml0TWV0YUhlYWRlckNvbHVtblZpZXcoY29sOiBQYmxNZXRhQ29sdW1uIHwgUGJsQ29sdW1uR3JvdXApIHtcbiAgICB0aGlzLmNlbGxDdHggPSBNZXRhQ2VsbENvbnRleHQuY3JlYXRlKGNvbCwgdGhpcy5ncmlkKTtcbiAgICByZXR1cm4gdGhpcy52Y1JlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29sLnRlbXBsYXRlLCB0aGlzLmNlbGxDdHgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJ1bkhlYWRlckV4dGVuc2lvbnMoY29udGV4dDogUGJsTmdyaWREYXRhSGVhZGVyRXh0ZW5zaW9uQ29udGV4dCwgdmlldzogRW1iZWRkZWRWaWV3UmVmPFBibE5ncmlkTWV0YUNlbGxDb250ZXh0PGFueSwgUGJsQ29sdW1uPj4pOiB2b2lkIHtcbiAgICAvLyB3ZSBjb2xsZWN0IHRoZSBmaXJzdCBoZWFkZXIgZXh0ZW5zaW9uIGZvciBlYWNoIHVuaXF1ZSBuYW1lIG9ubHkgb25jZSBwZXIgZ3JpZCBpbnN0YW5jZVxuICAgIGxldCBleHRlbnNpb25zID0gbGFzdERhdGFIZWFkZXJFeHRlbnNpb25zLmdldCh0aGlzLmdyaWQpO1xuICAgIGlmICghZXh0ZW5zaW9ucykge1xuICAgICAgY29uc3QgZGF0YUhlYWRlckV4dGVuc2lvbnMgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuXG4gICAgICB0aGlzLmdyaWQucmVnaXN0cnkuZm9yTXVsdGkoJ2RhdGFIZWFkZXJFeHRlbnNpb25zJywgdmFsdWVzID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAoIWRhdGFIZWFkZXJFeHRlbnNpb25zLmhhcyh2YWx1ZS5uYW1lKSkge1xuICAgICAgICAgICAgZGF0YUhlYWRlckV4dGVuc2lvbnMuc2V0KHZhbHVlLm5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHRlbnNpb25zID0gQXJyYXkuZnJvbShkYXRhSGVhZGVyRXh0ZW5zaW9ucy52YWx1ZXMoKSk7XG4gICAgICBsYXN0RGF0YUhlYWRlckV4dGVuc2lvbnMuc2V0KHRoaXMuZ3JpZCwgZXh0ZW5zaW9ucyk7XG4gICAgICAvLyBkZXN0cm95IGl0IG9uIHRoZSBuZXh0IHR1cm4sIHdlIGtub3cgYWxsIGNlbGxzIHdpbGwgcmVuZGVyIG9uIHRoZSBzYW1lIHR1cm4uXG4gICAgICB0aGlzLnpvbmUub25TdGFibGUucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoICgpID0+IGxhc3REYXRhSGVhZGVyRXh0ZW5zaW9ucy5kZWxldGUodGhpcy5ncmlkKSApO1xuICAgIH1cblxuICAgIGxldCB7IHJvb3ROb2RlcyB9ID0gdmlldztcblxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgIGlmICghZXh0LnNob3VsZFJlbmRlciB8fCBleHQuc2hvdWxkUmVuZGVyKGNvbnRleHQpKSB7XG4gICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBQYmxOZ3JpZE11bHRpVGVtcGxhdGVSZWdpc3RyeSkge1xuICAgICAgICAgIGNvbnN0IGV4dFZpZXcgPSB0aGlzLnZjUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhleHQudFJlZiwgY29udGV4dCk7XG4gICAgICAgICAgZXh0Vmlldy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQYmxOZ3JpZE11bHRpQ29tcG9uZW50UmVnaXN0cnkpIHtcbiAgICAgICAgICByb290Tm9kZXMgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudChleHQsIGNvbnRleHQsIHJvb3ROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgY3JlYXRlQ29tcG9uZW50KGV4dDogUGJsTmdyaWRNdWx0aUNvbXBvbmVudFJlZ2lzdHJ5PGFueSwgXCJkYXRhSGVhZGVyRXh0ZW5zaW9uc1wiPiwgY29udGV4dDogUGJsTmdyaWREYXRhSGVhZGVyRXh0ZW5zaW9uQ29udGV4dCwgcm9vdE5vZGVzOiBhbnlbXSk6IGFueVtdIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gZXh0LmdldEZhY3RvcnkoY29udGV4dCk7XG4gICAgY29uc3QgcHJvamVjdGVkQ29udGVudDogYW55W11bXSA9IFtdO1xuXG4gICAgaWYgKGV4dC5wcm9qZWN0Q29udGVudCkge1xuICAgICAgcHJvamVjdGVkQ29udGVudC5wdXNoKHJvb3ROb2Rlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgY21wUmVmID0gdGhpcy52Y1JlZi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgdGhpcy52Y1JlZi5sZW5ndGgsIG51bGwsIHByb2plY3RlZENvbnRlbnQpO1xuXG4gICAgaWYgKGV4dC5wcm9qZWN0Q29udGVudCkge1xuICAgICAgcm9vdE5vZGVzID0gWyBjbXBSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudCBdO1xuICAgIH1cblxuICAgIGlmIChleHQub25DcmVhdGVkKSB7XG4gICAgICBleHQub25DcmVhdGVkKGNvbnRleHQsIGNtcFJlZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3ROb2RlcztcbiAgfVxufVxuXG4vKiogQ2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAncGJsLW5ncmlkLWNlbGwnLFxuICBob3N0OiB7XG4gICAgJ2NsYXNzJzogJ3BibC1uZ3JpZC1jZWxsJyxcbiAgICAncm9sZSc6ICdncmlkY2VsbCcsXG4gIH0sXG4gIGV4cG9ydEFzOiAncGJsTmdyaWRDZWxsJyxcbn0pXG5AVW5SeCgpXG5leHBvcnQgY2xhc3MgUGJsTmdyaWRDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrQ2VsbCBpbXBsZW1lbnRzIERvQ2hlY2sge1xuXG4gIEBJbnB1dCgpIHNldCByb3dDdHgodmFsdWU6IFBibFJvd0NvbnRleHQ8YW55Pikge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcm93Q3R4KSB7XG4gICAgICB0aGlzLl9yb3dDdHggPSB2YWx1ZTtcbiAgICAgIHRoaXMubmdEb0NoZWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfcm93Q3R4OiBQYmxSb3dDb250ZXh0PGFueT47XG4gIGNlbGxDdHg6IFBibENlbGxDb250ZXh0IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbHVtbiBkZWYgYW1vbmcgYWxsIGNvbHVtbnMgcmVnYXJkbGVzcyBvZiB2aXNpYmlsaXR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjb2xJbmRleDogbnVtYmVyO1xuICBwcml2YXRlIGVsOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBmb2N1c2VkID0gZmFsc2U7XG4gIHByaXZhdGUgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbERlZjogUGJsTmdyaWRDb2x1bW5EZWY8UGJsQ29sdW1uPiwgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgIHN1cGVyKGNvbERlZiwgZWxlbWVudFJlZik7XG4gICAgdGhpcy5jb2xJbmRleCA9IHRoaXMuY29sRGVmLmdyaWQuY29sdW1uQXBpLmluZGV4T2YoY29sRGVmLmNvbHVtbiBhcyBQYmxDb2x1bW4pO1xuICAgIHRoaXMuZWwgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29sRGVmLmFwcGx5V2lkdGgodGhpcy5lbCk7XG4gICAgaW5pdENlbGxFbGVtZW50KHRoaXMuZWwsIGNvbERlZi5jb2x1bW4pO1xuICAgIGluaXREYXRhQ2VsbEVsZW1lbnQodGhpcy5lbCwgY29sRGVmLmNvbHVtbik7XG5cblxuICAgIC8qICBBcHBseSB3aWR0aCBjaGFuZ2VzIHRvIHRoaXMgZGF0YSBjZWxsXG4gICAgICAgIFdlIGRvbid0IHVwZGF0ZSBcInVwZGF0ZVwiIGV2ZW50cyBiZWNhdXNlIHRoZXkgYXJlIGZvbGxvd2VkIGJ5IGEgcmVzaXplIGV2ZW50IHdoaWNoIHdpbGwgdXBkYXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZSAocHgpICovXG4gICAgY29sRGVmLndpZHRoQ2hhbmdlXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKCBldmVudCA9PiBldmVudC5yZWFzb24gIT09ICd1cGRhdGUnKSxcbiAgICAgICAgVW5SeCh0aGlzKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4gdGhpcy5jb2xEZWYuYXBwbHlXaWR0aCh0aGlzLmVsKSk7XG4gIH1cblxuICBuZ0RvQ2hlY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3Jvd0N0eCkge1xuICAgICAgY29uc3QgY2VsbENvbnRleHQgPSB0aGlzLmNlbGxDdHggPSB0aGlzLl9yb3dDdHguY2VsbCh0aGlzLmNvbEluZGV4KTtcblxuICAgICAgaWYgKGNlbGxDb250ZXh0LmZvY3VzZWQgIT09IHRoaXMuZm9jdXNlZCkge1xuXG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWQgPSBjZWxsQ29udGV4dC5mb2N1c2VkKSB7XG4gICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdwYmwtbmdyaWQtY2VsbC1mb2N1c2VkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdwYmwtbmdyaWQtY2VsbC1mb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNlbGxDdHguc2VsZWN0ZWQgIT09IHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgPSBjZWxsQ29udGV4dC5zZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgncGJsLW5ncmlkLWNlbGwtc2VsZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3BibC1uZ3JpZC1jZWxsLXNlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAncGJsLW5ncmlkLWZvb3Rlci1jZWxsJyxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdwYmwtbmdyaWQtZm9vdGVyLWNlbGwnLFxuICAgICdyb2xlJzogJ2dyaWRjZWxsJyxcbiAgfSxcbiAgZXhwb3J0QXM6ICduZ3JpZEZvb3RlckNlbGwnLFxuIH0pXG4gQFVuUngoKVxuZXhwb3J0IGNsYXNzIFBibE5ncmlkRm9vdGVyQ2VsbERpcmVjdGl2ZSBleHRlbmRzIENka0Zvb3RlckNlbGwgaW1wbGVtZW50cyBPbkluaXQge1xuICBjZWxsQ3R4OiBNZXRhQ2VsbENvbnRleHQ7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgZ3JpZCBpbnN0ZWFkICovXG4gIHJlYWRvbmx5IHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDtcblxuICBwcml2YXRlIGVsOiBIVE1MRWxlbWVudDtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb2x1bW5EZWY6IFBibE5ncmlkQ29sdW1uRGVmPFBibE1ldGFDb2x1bW4gfCBQYmxDb2x1bW5Hcm91cD4sXG4gICAgICAgICAgICAgIHB1YmxpYyBncmlkOiBQYmxOZ3JpZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgdGhpcy50YWJsZSA9IGdyaWQ7XG4gICAgdGhpcy5lbCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5EZWYuY29sdW1uO1xuICAgIGFwcGx5V2lkdGguY2FsbCh0aGlzKTtcbiAgICBpbml0Q2VsbEVsZW1lbnQodGhpcy5lbCwgY29sdW1uKTtcblxuICAgIGNvbHVtbkRlZi53aWR0aENoYW5nZVxuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlciggZXZlbnQgPT4gZXZlbnQucmVhc29uICE9PSAndXBkYXRlJyksXG4gICAgICAgIFVuUngodGhpcyksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKGFwcGx5V2lkdGguYmluZCh0aGlzKSk7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmNlbGxDdHggPSBNZXRhQ2VsbENvbnRleHQuY3JlYXRlKHRoaXMuY29sdW1uRGVmLmNvbHVtbiwgdGhpcy5ncmlkKTtcbiAgfVxufVxuIl19