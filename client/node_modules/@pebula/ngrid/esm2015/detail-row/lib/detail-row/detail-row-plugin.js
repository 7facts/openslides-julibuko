/**
 * @fileoverview added by tsickle
 * Generated from: lib/detail-row/detail-row-plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __decorate, __metadata } from "tslib";
import { Directive, EventEmitter, Injector, Input, Output, ComponentFactoryResolver } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { UnRx } from '@pebula/utils';
import { PblNgridComponent, PblNgridPluginController, NgridPlugin } from '@pebula/ngrid';
import { PblNgridDefaultDetailRowParentComponent } from './directives';
/** @type {?} */
export const PLUGIN_KEY = 'detailRow';
/** @type {?} */
export const ROW_WHEN_TRUE = (/**
 * @return {?}
 */
() => true);
/** @type {?} */
export const ROW_WHEN_FALSE = (/**
 * @return {?}
 */
() => false);
/**
 * @template T
 * @param {?} grid
 * @param {?} row
 * @param {?=} forceState
 * @return {?}
 */
export function toggleDetailRow(grid, row, forceState) {
    /** @type {?} */
    const controller = PblNgridPluginController.find(grid);
    if (controller) {
        /** @type {?} */
        const plugin = controller.getPlugin(PLUGIN_KEY);
        if (plugin) {
            return plugin.toggleDetailRow(row, forceState);
        }
    }
}
/**
 * @record
 * @template T
 */
export function PblDetailsRowToggleEvent() { }
if (false) {
    /** @type {?} */
    PblDetailsRowToggleEvent.prototype.row;
    /** @type {?} */
    PblDetailsRowToggleEvent.prototype.expended;
    /**
     * @return {?}
     */
    PblDetailsRowToggleEvent.prototype.toggle = function () { };
}
/**
 * @template T
 */
let PblNgridDetailRowPluginDirective = /**
 * @template T
 */
class PblNgridDetailRowPluginDirective {
    /**
     * @param {?} grid
     * @param {?} pluginCtrl
     * @param {?} injector
     */
    constructor(grid, pluginCtrl, injector) {
        this.grid = grid;
        this.injector = injector;
        /**
         * Set the behavior when the row's context is changed while the detail row is opened (another row is displayed in place of the current row).
         *
         * - ignore: don't do anything, leave as is (for manual intervention)
         * - close: close the detail row
         * - render: re-render the row with the new context
         *
         * The default behavior is `render`
         *
         * This scenario will pop-up when using pagination and the user move between pages or change the page size.
         * It might also happen when the data is updated due to custom refresh calls on the datasource or any other scenario that might invoke a datasource update.
         *
         * The `ignore` phase, when used, will not trigger an update, leaving the detail row opened and showing data from the previous row.
         * The `ignore` is intended for use with `toggledRowContextChange`, which will emit when the row context has changed, this will allow the developer to
         * toggle the row (mimic `close`) or update the context manually. For example, if toggling open the detail row invokes a "fetch" operation that retrieves data for the detail row
         * this will allow updates on context change.
         *
         * > Note that `toggledRowContextChange` fires regardless of the value set in `whenContextChange`
         */
        this.whenContextChange = 'render';
        /**
         * Emits whenever a detail row instance is toggled on/off
         * Emits an event handler with the row, the toggle state and a toggle operation method.
         */
        this.toggleChange = new EventEmitter();
        /**
         * Emits whenever the row context has changed while the row is toggled open.
         * This scenario is unique and will occur only when a detail row is opened AND the parent row has changed.
         *
         * For example, when using pagination and the user navigates to the next/previous set or when the rows per page size is changed.
         * It might also occur when the data is updated due to custom refresh calls on the datasource or any other scenario that might invoke a datasource update.
         *
         * Emits an event handler with the row, the toggle state and a toggle operation method.
         */
        this.toggledRowContextChange = new EventEmitter();
        this._isSimpleRow = ROW_WHEN_TRUE;
        this._isDetailRow = ROW_WHEN_FALSE;
        this._detailRowRows = new Map();
        this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, this);
        /** @type {?} */
        let subscription = pluginCtrl.events.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (event.kind === 'onInit') {
                subscription.unsubscribe();
                subscription = undefined;
                // Depends on target-events plugin
                // if it's not set, create it.
                if (!pluginCtrl.hasPlugin('targetEvents')) {
                    pluginCtrl.createPlugin('targetEvents');
                }
                grid.registry.changes
                    .subscribe((/**
                 * @param {?} changes
                 * @return {?}
                 */
                changes => {
                    for (const c of changes) {
                        switch (c.type) {
                            case 'detailRowParent':
                                if (c.op === 'remove') {
                                    grid._cdkTable.removeRowDef(c.value);
                                    this._detailRowDef = undefined;
                                }
                                this.setupDetailRowParent();
                                // grid._cdkTable.syncRows('data');
                                break;
                        }
                    }
                }));
                // if we start with an initial value, then update the grid cause we didn't do that
                // when it was set (we cant cause we're not init)
                // otherwise just setup the parent.
                if (this._detailRow) {
                    this.updateTable();
                }
                else {
                    this.setupDetailRowParent();
                }
            }
        }));
    }
    /**
     * Detail row control (none / all rows / selective rows)
     *
     * A detail row is an additional row added below a row rendered with the context of the row above it.
     *
     * You can enable/disable detail row for the entire grid by setting `detailRow` to true/false respectively.
     * To control detail row per row, provide a predicate.
     * @return {?}
     */
    get detailRow() { return this._detailRow; }
    /**
     * @param {?} value
     * @return {?}
     */
    set detailRow(value) {
        if (this._detailRow !== value) {
            /** @type {?} */
            const grid = this.grid;
            if (typeof value === 'function') {
                this._isSimpleRow = (/**
                 * @param {?} index
                 * @param {?} rowData
                 * @return {?}
                 */
                (index, rowData) => !((/** @type {?} */ (value)))(index, rowData));
                this._isDetailRow = value;
            }
            else {
                value = coerceBooleanProperty(value);
                this._isDetailRow = value ? ROW_WHEN_TRUE : ROW_WHEN_FALSE;
                this._isSimpleRow = value ? ROW_WHEN_FALSE : ROW_WHEN_TRUE;
            }
            this._detailRow = value;
            if (grid.isInit) {
                this.updateTable();
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set singleDetailRow(value) {
        value = coerceBooleanProperty(value);
        if (this._forceSingle !== value) {
            this._forceSingle = value;
            if (value && this._openedRow && this._openedRow.expended) {
                this._detailRowRows.forEach((/**
                 * @param {?} r
                 * @return {?}
                 */
                r => {
                    if (r.row !== this._openedRow.row) {
                        r.toggle(false);
                    }
                }));
            }
        }
    }
    /**
     * @param {?} detailRow
     * @return {?}
     */
    addDetailRow(detailRow) {
        this._detailRowRows.set(detailRow.row, detailRow);
    }
    /**
     * @param {?} detailRow
     * @return {?}
     */
    removeDetailRow(detailRow) {
        this._detailRowRows.delete(detailRow.row);
    }
    /**
     * @param {?} row
     * @param {?=} forceState
     * @return {?}
     */
    toggleDetailRow(row, forceState) {
        /** @type {?} */
        const detailRow = this._detailRowRows.get(row);
        if (detailRow) {
            detailRow.toggle(forceState);
            return detailRow.expended;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._defaultParentRef) {
            this._defaultParentRef.destroy();
        }
        this._removePlugin(this.grid);
    }
    /**
     * \@internal
     * @param {?} event
     * @return {?}
     */
    detailRowToggled(event) {
        // logic for closing previous row
        /** @type {?} */
        const isSelf = this._openedRow && this._openedRow.row === event.row;
        if (event.expended) {
            if (this._forceSingle && this._openedRow && this._openedRow.expended && !isSelf) {
                this._openedRow.toggle();
            }
            this._openedRow = event;
        }
        else if (isSelf) {
            this._openedRow = undefined;
        }
        this.toggleChange.emit(event);
    }
    /**
     * @private
     * @return {?}
     */
    setupDetailRowParent() {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const cdkTable = grid._cdkTable;
        if (this._detailRowDef) {
            cdkTable.removeRowDef(this._detailRowDef);
            this._detailRowDef = undefined;
        }
        if (this.detailRow) {
            /** @type {?} */
            let detailRow = grid.registry.getSingle('detailRowParent');
            if (detailRow) {
                this._detailRowDef = detailRow = detailRow.clone();
                Object.defineProperty(detailRow, 'columns', { enumerable: true, get: (/**
                     * @return {?}
                     */
                    () => grid.columnApi.visibleColumnIds) });
                Object.defineProperty(detailRow, 'when', { enumerable: true, get: (/**
                     * @return {?}
                     */
                    () => this._isDetailRow) });
                detailRow.ngOnChanges({ columns: { isFirstChange: (/**
                         * @return {?}
                         */
                        () => true), firstChange: true, currentValue: detailRow.columns, previousValue: null } });
            }
            else if (!this._defaultParentRef) {
                // TODO: move to module? set in root registry? put elsewhere to avoid grid sync (see event of registry change)...
                this._defaultParentRef = this.injector.get(ComponentFactoryResolver)
                    .resolveComponentFactory(PblNgridDefaultDetailRowParentComponent)
                    .create(this.injector);
                this._defaultParentRef.changeDetectorRef.detectChanges();
                return;
            }
        }
        this.resetTableRowDefs();
    }
    /**
     * @private
     * @return {?}
     */
    resetTableRowDefs() {
        /** @type {?} */
        const grid = this.grid;
        if (this._detailRowDef) {
            this._detailRow === false
                ? grid._cdkTable.removeRowDef(this._detailRowDef)
                : grid._cdkTable.addRowDef(this._detailRowDef);
        }
    }
    /**
     * Update the grid with detail row infor.
     * Instead of calling for a change detection cycle we can assign the new predicates directly to the cdkRowDef instances.
     * @private
     * @return {?}
     */
    updateTable() {
        this.grid._tableRowDef.when = this._isSimpleRow;
        this.setupDetailRowParent();
        // Once we changed the `when` predicate on the `CdkRowDef` we must:
        //   1. Update the row cache (property `rowDefs`) to reflect the new change
        this.grid._cdkTable.updateRowDefCache();
        //   2. re-render all rows.
        // The logic for re-rendering all rows is handled in `CdkTable._forceRenderDataRows()` which is a private method.
        // This is a workaround, assigning to `multiTemplateDataRows` will invoke the setter which
        // also calls `CdkTable._forceRenderDataRows()`
        // TODO: This is risky, the setter logic might change.
        // for example, if material will chack for change in `multiTemplateDataRows` setter from previous value...
        this.grid._cdkTable.multiTemplateDataRows = !!this._detailRow;
    }
};
PblNgridDetailRowPluginDirective.decorators = [
    { type: Directive, args: [{ selector: 'pbl-ngrid[detailRow]', exportAs: 'pblNgridDetailRow' },] }
];
/** @nocollapse */
PblNgridDetailRowPluginDirective.ctorParameters = () => [
    { type: PblNgridComponent },
    { type: PblNgridPluginController },
    { type: Injector }
];
PblNgridDetailRowPluginDirective.propDecorators = {
    detailRow: [{ type: Input }],
    singleDetailRow: [{ type: Input }],
    excludeToggleFrom: [{ type: Input }],
    whenContextChange: [{ type: Input }],
    toggleChange: [{ type: Output }],
    toggledRowContextChange: [{ type: Output }]
};
/**
 * @template T
 */
PblNgridDetailRowPluginDirective = __decorate([
    NgridPlugin({ id: PLUGIN_KEY }),
    UnRx(),
    __metadata("design:paramtypes", [PblNgridComponent, PblNgridPluginController, Injector])
], PblNgridDetailRowPluginDirective);
export { PblNgridDetailRowPluginDirective };
if (false) {
    /**
     * A list of columns that will not trigger a detail row toggle when clicked.
     * @type {?}
     */
    PblNgridDetailRowPluginDirective.prototype.excludeToggleFrom;
    /**
     * Set the behavior when the row's context is changed while the detail row is opened (another row is displayed in place of the current row).
     *
     * - ignore: don't do anything, leave as is (for manual intervention)
     * - close: close the detail row
     * - render: re-render the row with the new context
     *
     * The default behavior is `render`
     *
     * This scenario will pop-up when using pagination and the user move between pages or change the page size.
     * It might also happen when the data is updated due to custom refresh calls on the datasource or any other scenario that might invoke a datasource update.
     *
     * The `ignore` phase, when used, will not trigger an update, leaving the detail row opened and showing data from the previous row.
     * The `ignore` is intended for use with `toggledRowContextChange`, which will emit when the row context has changed, this will allow the developer to
     * toggle the row (mimic `close`) or update the context manually. For example, if toggling open the detail row invokes a "fetch" operation that retrieves data for the detail row
     * this will allow updates on context change.
     *
     * > Note that `toggledRowContextChange` fires regardless of the value set in `whenContextChange`
     * @type {?}
     */
    PblNgridDetailRowPluginDirective.prototype.whenContextChange;
    /**
     * Emits whenever a detail row instance is toggled on/off
     * Emits an event handler with the row, the toggle state and a toggle operation method.
     * @type {?}
     */
    PblNgridDetailRowPluginDirective.prototype.toggleChange;
    /**
     * Emits whenever the row context has changed while the row is toggled open.
     * This scenario is unique and will occur only when a detail row is opened AND the parent row has changed.
     *
     * For example, when using pagination and the user navigates to the next/previous set or when the rows per page size is changed.
     * It might also occur when the data is updated due to custom refresh calls on the datasource or any other scenario that might invoke a datasource update.
     *
     * Emits an event handler with the row, the toggle state and a toggle operation method.
     * @type {?}
     */
    PblNgridDetailRowPluginDirective.prototype.toggledRowContextChange;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._openedRow;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._forceSingle;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._isSimpleRow;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._isDetailRow;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._detailRowRows;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._detailRow;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._detailRowDef;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._defaultParentRef;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype._removePlugin;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype.grid;
    /**
     * @type {?}
     * @private
     */
    PblNgridDetailRowPluginDirective.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV0YWlsLXJvdy1wbHVnaW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcGVidWxhL25ncmlkL2RldGFpbC1yb3cvIiwic291cmNlcyI6WyJsaWIvZGV0YWlsLXJvdy9kZXRhaWwtcm93LXBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFtQixZQUFZLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQUUsd0JBQXdCLEVBQWdCLE1BQU0sZUFBZSxDQUFDO0FBQ3JKLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTlELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLHdCQUF3QixFQUFFLFdBQVcsRUFBc0IsTUFBTSxlQUFlLENBQUM7QUFHN0csT0FBTyxFQUF1Qyx1Q0FBdUMsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7QUFRNUcsTUFBTSxPQUFPLFVBQVUsR0FBZ0IsV0FBVzs7QUFFbEQsTUFBTSxPQUFPLGFBQWE7OztBQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQTs7QUFDdkMsTUFBTSxPQUFPLGNBQWM7OztBQUFHLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQTs7Ozs7Ozs7QUFFekMsTUFBTSxVQUFVLGVBQWUsQ0FBVSxJQUEwQixFQUFFLEdBQU0sRUFBRSxVQUFvQjs7VUFDekYsVUFBVSxHQUFHLHdCQUF3QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDdEQsSUFBSSxVQUFVLEVBQUU7O2NBQ1IsTUFBTSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO1FBQy9DLElBQUksTUFBTSxFQUFFO1lBQ1YsT0FBTyxNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQztTQUNoRDtLQUNGO0FBQ0gsQ0FBQzs7Ozs7QUFFRCw4Q0FJQzs7O0lBSEMsdUNBQU87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QXFCTCxLQUFLO2dDQWlCTCxLQUFLO2dDQXFCTCxLQUFLOzJCQU1MLE1BQU07c0NBVU4sTUFBTTs7Ozs7QUFwRkksZ0NBQWdDO0lBSDVDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsQ0FBQztJQUUvQixJQUFJLEVBQUU7cUNBaUdxQixpQkFBaUIsRUFBbUIsd0JBQXdCLEVBQXVCLFFBQVE7R0FoRzFHLGdDQUFnQyxDQXVPNUM7U0F2T1ksZ0NBQWdDOzs7Ozs7SUErQzNDLDZEQUFxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBcUJyQyw2REFBcUU7Ozs7OztJQU1yRSx3REFBeUU7Ozs7Ozs7Ozs7O0lBVXpFLG1FQUFvRjs7Ozs7SUFFcEYsc0RBQWlEOzs7OztJQUNqRCx3REFBOEI7Ozs7O0lBQzlCLHdEQUE2RTs7Ozs7SUFDN0Usd0RBQThFOzs7OztJQUM5RSwwREFBb0U7Ozs7O0lBQ3BFLHNEQUF5RTs7Ozs7SUFDekUseURBQThEOzs7OztJQUM5RCw2REFBaUY7Ozs7O0lBQ2pGLHlEQUE4RDs7Ozs7SUFFbEQsZ0RBQW9DOzs7OztJQUEyQyxvREFBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVtYmVkZGVkVmlld1JlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3RvciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcblxuaW1wb3J0IHsgVW5SeCB9IGZyb20gJ0BwZWJ1bGEvdXRpbHMnO1xuaW1wb3J0IHsgUGJsTmdyaWRDb21wb25lbnQsIFBibE5ncmlkUGx1Z2luQ29udHJvbGxlciwgTmdyaWRQbHVnaW4sIFBibE5ncmlkUm93Q29udGV4dCB9IGZyb20gJ0BwZWJ1bGEvbmdyaWQnO1xuXG5pbXBvcnQgeyBQYmxOZ3JpZERldGFpbFJvd0NvbXBvbmVudCB9IGZyb20gJy4vcm93JztcbmltcG9ydCB7IFBibE5ncmlkRGV0YWlsUm93UGFyZW50UmVmRGlyZWN0aXZlLCBQYmxOZ3JpZERlZmF1bHREZXRhaWxSb3dQYXJlbnRDb21wb25lbnQgfSBmcm9tICcuL2RpcmVjdGl2ZXMnO1xuXG5kZWNsYXJlIG1vZHVsZSAnQHBlYnVsYS9uZ3JpZC9saWIvZXh0L3R5cGVzJyB7XG4gIGludGVyZmFjZSBQYmxOZ3JpZFBsdWdpbkV4dGVuc2lvbiB7XG4gICAgZGV0YWlsUm93PzogUGJsTmdyaWREZXRhaWxSb3dQbHVnaW5EaXJlY3RpdmU8YW55PjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUExVR0lOX0tFWTogJ2RldGFpbFJvdycgPSAnZGV0YWlsUm93JztcblxuZXhwb3J0IGNvbnN0IFJPV19XSEVOX1RSVUUgPSAoKSA9PiB0cnVlO1xuZXhwb3J0IGNvbnN0IFJPV19XSEVOX0ZBTFNFID0gKCkgPT4gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVEZXRhaWxSb3c8VCA9IGFueT4oZ3JpZDogUGJsTmdyaWRDb21wb25lbnQ8VD4sIHJvdzogVCwgZm9yY2VTdGF0ZT86IGJvb2xlYW4pOiBib29sZWFuIHwgdm9pZCB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBQYmxOZ3JpZFBsdWdpbkNvbnRyb2xsZXIuZmluZChncmlkKTtcbiAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBwbHVnaW4gPSBjb250cm9sbGVyLmdldFBsdWdpbihQTFVHSU5fS0VZKTtcbiAgICBpZiAocGx1Z2luKSB7XG4gICAgICByZXR1cm4gcGx1Z2luLnRvZ2dsZURldGFpbFJvdyhyb3csIGZvcmNlU3RhdGUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBibERldGFpbHNSb3dUb2dnbGVFdmVudDxUID0gYW55PiB7XG4gIHJvdzogVDtcbiAgZXhwZW5kZWQ6IGJvb2xlYW47XG4gIHRvZ2dsZSgpOiB2b2lkO1xufVxuXG5ATmdyaWRQbHVnaW4oeyBpZDogUExVR0lOX0tFWSB9KVxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAncGJsLW5ncmlkW2RldGFpbFJvd10nLCBleHBvcnRBczogJ3BibE5ncmlkRGV0YWlsUm93JyB9KVxuQFVuUngoKVxuZXhwb3J0IGNsYXNzIFBibE5ncmlkRGV0YWlsUm93UGx1Z2luRGlyZWN0aXZlPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIERldGFpbCByb3cgY29udHJvbCAobm9uZSAvIGFsbCByb3dzIC8gc2VsZWN0aXZlIHJvd3MpXG4gICAqXG4gICAqIEEgZGV0YWlsIHJvdyBpcyBhbiBhZGRpdGlvbmFsIHJvdyBhZGRlZCBiZWxvdyBhIHJvdyByZW5kZXJlZCB3aXRoIHRoZSBjb250ZXh0IG9mIHRoZSByb3cgYWJvdmUgaXQuXG4gICAqXG4gICAqIFlvdSBjYW4gZW5hYmxlL2Rpc2FibGUgZGV0YWlsIHJvdyBmb3IgdGhlIGVudGlyZSBncmlkIGJ5IHNldHRpbmcgYGRldGFpbFJvd2AgdG8gdHJ1ZS9mYWxzZSByZXNwZWN0aXZlbHkuXG4gICAqIFRvIGNvbnRyb2wgZGV0YWlsIHJvdyBwZXIgcm93LCBwcm92aWRlIGEgcHJlZGljYXRlLlxuICAgKi9cbiAgQElucHV0KCkgZ2V0IGRldGFpbFJvdygpOiAoIChpbmRleDogbnVtYmVyLCByb3dEYXRhOiBUKSA9PiBib29sZWFuICkgfCBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2RldGFpbFJvdzsgfVxuICBzZXQgZGV0YWlsUm93KHZhbHVlOiAoIChpbmRleDogbnVtYmVyLCByb3dEYXRhOiBUKSA9PiBib29sZWFuICkgfCBib29sZWFuICkge1xuICAgIGlmICh0aGlzLl9kZXRhaWxSb3cgIT09IHZhbHVlKSB7XG4gICAgICBjb25zdCBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2lzU2ltcGxlUm93ID0gKGluZGV4OiBudW1iZXIsIHJvd0RhdGE6IFQpID0+ICEodmFsdWUgYXMgYW55KShpbmRleCwgcm93RGF0YSk7XG4gICAgICAgIHRoaXMuX2lzRGV0YWlsUm93ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2lzRGV0YWlsUm93ID0gdmFsdWUgPyBST1dfV0hFTl9UUlVFIDogUk9XX1dIRU5fRkFMU0U7XG4gICAgICAgIHRoaXMuX2lzU2ltcGxlUm93ID0gdmFsdWUgPyBST1dfV0hFTl9GQUxTRSA6IFJPV19XSEVOX1RSVUU7XG4gICAgICB9XG4gICAgICB0aGlzLl9kZXRhaWxSb3cgPSB2YWx1ZTtcblxuICAgICAgaWYgKGdyaWQuaXNJbml0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2luZ2xlRGV0YWlsUm93KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9mb3JjZVNpbmdsZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2ZvcmNlU2luZ2xlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgJiYgdGhpcy5fb3BlbmVkUm93ICYmIHRoaXMuX29wZW5lZFJvdy5leHBlbmRlZCkge1xuICAgICAgICB0aGlzLl9kZXRhaWxSb3dSb3dzLmZvckVhY2goIHIgPT4ge1xuICAgICAgICAgIGlmIChyLnJvdyAhPT0gdGhpcy5fb3BlbmVkUm93LnJvdykge1xuICAgICAgICAgICAgci50b2dnbGUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBjb2x1bW5zIHRoYXQgd2lsbCBub3QgdHJpZ2dlciBhIGRldGFpbCByb3cgdG9nZ2xlIHdoZW4gY2xpY2tlZC5cbiAgICovXG4gIEBJbnB1dCgpIGV4Y2x1ZGVUb2dnbGVGcm9tOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogU2V0IHRoZSBiZWhhdmlvciB3aGVuIHRoZSByb3cncyBjb250ZXh0IGlzIGNoYW5nZWQgd2hpbGUgdGhlIGRldGFpbCByb3cgaXMgb3BlbmVkIChhbm90aGVyIHJvdyBpcyBkaXNwbGF5ZWQgaW4gcGxhY2Ugb2YgdGhlIGN1cnJlbnQgcm93KS5cbiAgICpcbiAgICogLSBpZ25vcmU6IGRvbid0IGRvIGFueXRoaW5nLCBsZWF2ZSBhcyBpcyAoZm9yIG1hbnVhbCBpbnRlcnZlbnRpb24pXG4gICAqIC0gY2xvc2U6IGNsb3NlIHRoZSBkZXRhaWwgcm93XG4gICAqIC0gcmVuZGVyOiByZS1yZW5kZXIgdGhlIHJvdyB3aXRoIHRoZSBuZXcgY29udGV4dFxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgcmVuZGVyYFxuICAgKlxuICAgKiBUaGlzIHNjZW5hcmlvIHdpbGwgcG9wLXVwIHdoZW4gdXNpbmcgcGFnaW5hdGlvbiBhbmQgdGhlIHVzZXIgbW92ZSBiZXR3ZWVuIHBhZ2VzIG9yIGNoYW5nZSB0aGUgcGFnZSBzaXplLlxuICAgKiBJdCBtaWdodCBhbHNvIGhhcHBlbiB3aGVuIHRoZSBkYXRhIGlzIHVwZGF0ZWQgZHVlIHRvIGN1c3RvbSByZWZyZXNoIGNhbGxzIG9uIHRoZSBkYXRhc291cmNlIG9yIGFueSBvdGhlciBzY2VuYXJpbyB0aGF0IG1pZ2h0IGludm9rZSBhIGRhdGFzb3VyY2UgdXBkYXRlLlxuICAgKlxuICAgKiBUaGUgYGlnbm9yZWAgcGhhc2UsIHdoZW4gdXNlZCwgd2lsbCBub3QgdHJpZ2dlciBhbiB1cGRhdGUsIGxlYXZpbmcgdGhlIGRldGFpbCByb3cgb3BlbmVkIGFuZCBzaG93aW5nIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgcm93LlxuICAgKiBUaGUgYGlnbm9yZWAgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoIGB0b2dnbGVkUm93Q29udGV4dENoYW5nZWAsIHdoaWNoIHdpbGwgZW1pdCB3aGVuIHRoZSByb3cgY29udGV4dCBoYXMgY2hhbmdlZCwgdGhpcyB3aWxsIGFsbG93IHRoZSBkZXZlbG9wZXIgdG9cbiAgICogdG9nZ2xlIHRoZSByb3cgKG1pbWljIGBjbG9zZWApIG9yIHVwZGF0ZSB0aGUgY29udGV4dCBtYW51YWxseS4gRm9yIGV4YW1wbGUsIGlmIHRvZ2dsaW5nIG9wZW4gdGhlIGRldGFpbCByb3cgaW52b2tlcyBhIFwiZmV0Y2hcIiBvcGVyYXRpb24gdGhhdCByZXRyaWV2ZXMgZGF0YSBmb3IgdGhlIGRldGFpbCByb3dcbiAgICogdGhpcyB3aWxsIGFsbG93IHVwZGF0ZXMgb24gY29udGV4dCBjaGFuZ2UuXG4gICAqXG4gICAqID4gTm90ZSB0aGF0IGB0b2dnbGVkUm93Q29udGV4dENoYW5nZWAgZmlyZXMgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgc2V0IGluIGB3aGVuQ29udGV4dENoYW5nZWBcbiAgICovXG4gIEBJbnB1dCgpIHdoZW5Db250ZXh0Q2hhbmdlOiAnaWdub3JlJyB8ICdjbG9zZScgfCAncmVuZGVyJyA9ICdyZW5kZXInO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciBhIGRldGFpbCByb3cgaW5zdGFuY2UgaXMgdG9nZ2xlZCBvbi9vZmZcbiAgICogRW1pdHMgYW4gZXZlbnQgaGFuZGxlciB3aXRoIHRoZSByb3csIHRoZSB0b2dnbGUgc3RhdGUgYW5kIGEgdG9nZ2xlIG9wZXJhdGlvbiBtZXRob2QuXG4gICAqL1xuICBAT3V0cHV0KCkgdG9nZ2xlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxQYmxEZXRhaWxzUm93VG9nZ2xlRXZlbnQ8VD4+KCk7XG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGUgcm93IGNvbnRleHQgaGFzIGNoYW5nZWQgd2hpbGUgdGhlIHJvdyBpcyB0b2dnbGVkIG9wZW4uXG4gICAqIFRoaXMgc2NlbmFyaW8gaXMgdW5pcXVlIGFuZCB3aWxsIG9jY3VyIG9ubHkgd2hlbiBhIGRldGFpbCByb3cgaXMgb3BlbmVkIEFORCB0aGUgcGFyZW50IHJvdyBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHdoZW4gdXNpbmcgcGFnaW5hdGlvbiBhbmQgdGhlIHVzZXIgbmF2aWdhdGVzIHRvIHRoZSBuZXh0L3ByZXZpb3VzIHNldCBvciB3aGVuIHRoZSByb3dzIHBlciBwYWdlIHNpemUgaXMgY2hhbmdlZC5cbiAgICogSXQgbWlnaHQgYWxzbyBvY2N1ciB3aGVuIHRoZSBkYXRhIGlzIHVwZGF0ZWQgZHVlIHRvIGN1c3RvbSByZWZyZXNoIGNhbGxzIG9uIHRoZSBkYXRhc291cmNlIG9yIGFueSBvdGhlciBzY2VuYXJpbyB0aGF0IG1pZ2h0IGludm9rZSBhIGRhdGFzb3VyY2UgdXBkYXRlLlxuICAgKlxuICAgKiBFbWl0cyBhbiBldmVudCBoYW5kbGVyIHdpdGggdGhlIHJvdywgdGhlIHRvZ2dsZSBzdGF0ZSBhbmQgYSB0b2dnbGUgb3BlcmF0aW9uIG1ldGhvZC5cbiAgICovXG4gIEBPdXRwdXQoKSB0b2dnbGVkUm93Q29udGV4dENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8UGJsRGV0YWlsc1Jvd1RvZ2dsZUV2ZW50PFQ+PigpO1xuXG4gIHByaXZhdGUgX29wZW5lZFJvdz86IFBibERldGFpbHNSb3dUb2dnbGVFdmVudDxUPjtcbiAgcHJpdmF0ZSBfZm9yY2VTaW5nbGU6IGJvb2xlYW47XG4gIHByaXZhdGUgX2lzU2ltcGxlUm93OiAoaW5kZXg6IG51bWJlciwgcm93RGF0YTogVCkgPT4gYm9vbGVhbiA9IFJPV19XSEVOX1RSVUU7XG4gIHByaXZhdGUgX2lzRGV0YWlsUm93OiAoaW5kZXg6IG51bWJlciwgcm93RGF0YTogVCkgPT4gYm9vbGVhbiA9IFJPV19XSEVOX0ZBTFNFO1xuICBwcml2YXRlIF9kZXRhaWxSb3dSb3dzID0gbmV3IE1hcDxhbnksIFBibE5ncmlkRGV0YWlsUm93Q29tcG9uZW50PigpO1xuICBwcml2YXRlIF9kZXRhaWxSb3c6ICggKGluZGV4OiBudW1iZXIsIHJvd0RhdGE6IFQpID0+IGJvb2xlYW4gKSB8IGJvb2xlYW47XG4gIHByaXZhdGUgX2RldGFpbFJvd0RlZjogUGJsTmdyaWREZXRhaWxSb3dQYXJlbnRSZWZEaXJlY3RpdmU8VD47XG4gIHByaXZhdGUgX2RlZmF1bHRQYXJlbnRSZWY6IENvbXBvbmVudFJlZjxQYmxOZ3JpZERlZmF1bHREZXRhaWxSb3dQYXJlbnRDb21wb25lbnQ+O1xuICBwcml2YXRlIF9yZW1vdmVQbHVnaW46IChncmlkOiBQYmxOZ3JpZENvbXBvbmVudDxhbnk+KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3JpZDogUGJsTmdyaWRDb21wb25lbnQ8YW55PiwgcGx1Z2luQ3RybDogUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyPFQ+LCBwcml2YXRlIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHRoaXMuX3JlbW92ZVBsdWdpbiA9IHBsdWdpbkN0cmwuc2V0UGx1Z2luKFBMVUdJTl9LRVksIHRoaXMpO1xuXG4gICAgbGV0IHN1YnNjcmlwdGlvbiA9IHBsdWdpbkN0cmwuZXZlbnRzLnN1YnNjcmliZSggZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtpbmQgPT09ICdvbkluaXQnKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gRGVwZW5kcyBvbiB0YXJnZXQtZXZlbnRzIHBsdWdpblxuICAgICAgICAvLyBpZiBpdCdzIG5vdCBzZXQsIGNyZWF0ZSBpdC5cbiAgICAgICAgaWYgKCFwbHVnaW5DdHJsLmhhc1BsdWdpbigndGFyZ2V0RXZlbnRzJykpIHtcbiAgICAgICAgICBwbHVnaW5DdHJsLmNyZWF0ZVBsdWdpbigndGFyZ2V0RXZlbnRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlZ2lzdHJ5LmNoYW5nZXNcbiAgICAgICAgICAuc3Vic2NyaWJlKCBjaGFuZ2VzID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoYy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV0YWlsUm93UGFyZW50JzpcbiAgICAgICAgICAgICAgICAgIGlmIChjLm9wID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICBncmlkLl9jZGtUYWJsZS5yZW1vdmVSb3dEZWYoYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldGFpbFJvd0RlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBEZXRhaWxSb3dQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgIC8vIGdyaWQuX2Nka1RhYmxlLnN5bmNSb3dzKCdkYXRhJyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHdlIHN0YXJ0IHdpdGggYW4gaW5pdGlhbCB2YWx1ZSwgdGhlbiB1cGRhdGUgdGhlIGdyaWQgY2F1c2Ugd2UgZGlkbid0IGRvIHRoYXRcbiAgICAgICAgLy8gd2hlbiBpdCB3YXMgc2V0ICh3ZSBjYW50IGNhdXNlIHdlJ3JlIG5vdCBpbml0KVxuICAgICAgICAvLyBvdGhlcndpc2UganVzdCBzZXR1cCB0aGUgcGFyZW50LlxuICAgICAgICBpZiAodGhpcy5fZGV0YWlsUm93KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVUYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0dXBEZXRhaWxSb3dQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYWRkRGV0YWlsUm93KGRldGFpbFJvdzogUGJsTmdyaWREZXRhaWxSb3dDb21wb25lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl9kZXRhaWxSb3dSb3dzLnNldChkZXRhaWxSb3cucm93LCBkZXRhaWxSb3cpO1xuICB9XG5cbiAgcmVtb3ZlRGV0YWlsUm93KGRldGFpbFJvdzogUGJsTmdyaWREZXRhaWxSb3dDb21wb25lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl9kZXRhaWxSb3dSb3dzLmRlbGV0ZShkZXRhaWxSb3cucm93KTtcbiAgfVxuXG4gIHRvZ2dsZURldGFpbFJvdyhyb3c6IGFueSwgZm9yY2VTdGF0ZT86IGJvb2xlYW4pOiBib29sZWFuIHwgdm9pZCB7XG4gICAgY29uc3QgZGV0YWlsUm93ID0gdGhpcy5fZGV0YWlsUm93Um93cy5nZXQocm93KTtcbiAgICBpZiAoZGV0YWlsUm93KSB7XG4gICAgICBkZXRhaWxSb3cudG9nZ2xlKGZvcmNlU3RhdGUpO1xuICAgICAgcmV0dXJuIGRldGFpbFJvdy5leHBlbmRlZDtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZGVmYXVsdFBhcmVudFJlZikge1xuICAgICAgdGhpcy5fZGVmYXVsdFBhcmVudFJlZi5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZVBsdWdpbih0aGlzLmdyaWQpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBkZXRhaWxSb3dUb2dnbGVkKGV2ZW50OiBQYmxEZXRhaWxzUm93VG9nZ2xlRXZlbnQ8VD4pOiB2b2lkIHtcbiAgICAvLyBsb2dpYyBmb3IgY2xvc2luZyBwcmV2aW91cyByb3dcbiAgICBjb25zdCBpc1NlbGYgPSB0aGlzLl9vcGVuZWRSb3cgJiYgdGhpcy5fb3BlbmVkUm93LnJvdyA9PT0gZXZlbnQucm93O1xuICAgIGlmIChldmVudC5leHBlbmRlZCkge1xuICAgICAgaWYgKHRoaXMuX2ZvcmNlU2luZ2xlICYmIHRoaXMuX29wZW5lZFJvdyAmJiB0aGlzLl9vcGVuZWRSb3cuZXhwZW5kZWQgJiYgIWlzU2VsZikge1xuICAgICAgICB0aGlzLl9vcGVuZWRSb3cudG9nZ2xlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vcGVuZWRSb3cgPSBldmVudDtcbiAgICB9IGVsc2UgaWYgKGlzU2VsZikge1xuICAgICAgdGhpcy5fb3BlbmVkUm93ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZUNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBEZXRhaWxSb3dQYXJlbnQoKTogdm9pZCB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMuZ3JpZDtcbiAgICBjb25zdCBjZGtUYWJsZSA9IGdyaWQuX2Nka1RhYmxlO1xuICAgIGlmICh0aGlzLl9kZXRhaWxSb3dEZWYpIHtcbiAgICAgIGNka1RhYmxlLnJlbW92ZVJvd0RlZih0aGlzLl9kZXRhaWxSb3dEZWYpO1xuICAgICAgdGhpcy5fZGV0YWlsUm93RGVmID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZXRhaWxSb3cpIHtcbiAgICAgIGxldCBkZXRhaWxSb3cgPSBncmlkLnJlZ2lzdHJ5LmdldFNpbmdsZSgnZGV0YWlsUm93UGFyZW50Jyk7XG4gICAgICBpZiAoZGV0YWlsUm93KSB7XG4gICAgICAgIHRoaXMuX2RldGFpbFJvd0RlZiA9IGRldGFpbFJvdyA9IGRldGFpbFJvdy5jbG9uZSgpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGV0YWlsUm93LCAnY29sdW1ucycsIHsgZW51bWVyYWJsZTogdHJ1ZSwgIGdldDogKCkgPT4gZ3JpZC5jb2x1bW5BcGkudmlzaWJsZUNvbHVtbklkcyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRldGFpbFJvdywgJ3doZW4nLCB7IGVudW1lcmFibGU6IHRydWUsICBnZXQ6ICgpID0+IHRoaXMuX2lzRGV0YWlsUm93IH0pO1xuICAgICAgICBkZXRhaWxSb3cubmdPbkNoYW5nZXMoeyBjb2x1bW5zOiB7IGlzRmlyc3RDaGFuZ2U6ICgpID0+IHRydWUsIGZpcnN0Q2hhbmdlOiB0cnVlLCBjdXJyZW50VmFsdWU6IGRldGFpbFJvdy5jb2x1bW5zLCBwcmV2aW91c1ZhbHVlOiBudWxsIH19KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2RlZmF1bHRQYXJlbnRSZWYpIHtcbiAgICAgICAgLy8gVE9ETzogbW92ZSB0byBtb2R1bGU/IHNldCBpbiByb290IHJlZ2lzdHJ5PyBwdXQgZWxzZXdoZXJlIHRvIGF2b2lkIGdyaWQgc3luYyAoc2VlIGV2ZW50IG9mIHJlZ2lzdHJ5IGNoYW5nZSkuLi5cbiAgICAgICAgdGhpcy5fZGVmYXVsdFBhcmVudFJlZiA9IHRoaXMuaW5qZWN0b3IuZ2V0KENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcilcbiAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoUGJsTmdyaWREZWZhdWx0RGV0YWlsUm93UGFyZW50Q29tcG9uZW50KVxuICAgICAgICAgIC5jcmVhdGUodGhpcy5pbmplY3Rvcik7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQYXJlbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzZXRUYWJsZVJvd0RlZnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRUYWJsZVJvd0RlZnMoKTogdm9pZCB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMuZ3JpZDtcbiAgICBpZiAodGhpcy5fZGV0YWlsUm93RGVmKSB7XG4gICAgICB0aGlzLl9kZXRhaWxSb3cgPT09IGZhbHNlXG4gICAgICAgID8gZ3JpZC5fY2RrVGFibGUucmVtb3ZlUm93RGVmKHRoaXMuX2RldGFpbFJvd0RlZilcbiAgICAgICAgOiBncmlkLl9jZGtUYWJsZS5hZGRSb3dEZWYodGhpcy5fZGV0YWlsUm93RGVmKVxuICAgICAgO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGdyaWQgd2l0aCBkZXRhaWwgcm93IGluZm9yLlxuICAgKiBJbnN0ZWFkIG9mIGNhbGxpbmcgZm9yIGEgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSB3ZSBjYW4gYXNzaWduIHRoZSBuZXcgcHJlZGljYXRlcyBkaXJlY3RseSB0byB0aGUgY2RrUm93RGVmIGluc3RhbmNlcy5cbiAgICovXG4gIHByaXZhdGUgdXBkYXRlVGFibGUoKTogdm9pZCB7XG4gICAgdGhpcy5ncmlkLl90YWJsZVJvd0RlZi53aGVuID0gdGhpcy5faXNTaW1wbGVSb3c7XG4gICAgdGhpcy5zZXR1cERldGFpbFJvd1BhcmVudCgpO1xuICAgIC8vIE9uY2Ugd2UgY2hhbmdlZCB0aGUgYHdoZW5gIHByZWRpY2F0ZSBvbiB0aGUgYENka1Jvd0RlZmAgd2UgbXVzdDpcbiAgICAvLyAgIDEuIFVwZGF0ZSB0aGUgcm93IGNhY2hlIChwcm9wZXJ0eSBgcm93RGVmc2ApIHRvIHJlZmxlY3QgdGhlIG5ldyBjaGFuZ2VcbiAgICB0aGlzLmdyaWQuX2Nka1RhYmxlLnVwZGF0ZVJvd0RlZkNhY2hlKCk7XG5cbiAgICAvLyAgIDIuIHJlLXJlbmRlciBhbGwgcm93cy5cbiAgICAvLyBUaGUgbG9naWMgZm9yIHJlLXJlbmRlcmluZyBhbGwgcm93cyBpcyBoYW5kbGVkIGluIGBDZGtUYWJsZS5fZm9yY2VSZW5kZXJEYXRhUm93cygpYCB3aGljaCBpcyBhIHByaXZhdGUgbWV0aG9kLlxuICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kLCBhc3NpZ25pbmcgdG8gYG11bHRpVGVtcGxhdGVEYXRhUm93c2Agd2lsbCBpbnZva2UgdGhlIHNldHRlciB3aGljaFxuICAgIC8vIGFsc28gY2FsbHMgYENka1RhYmxlLl9mb3JjZVJlbmRlckRhdGFSb3dzKClgXG4gICAgLy8gVE9ETzogVGhpcyBpcyByaXNreSwgdGhlIHNldHRlciBsb2dpYyBtaWdodCBjaGFuZ2UuXG4gICAgLy8gZm9yIGV4YW1wbGUsIGlmIG1hdGVyaWFsIHdpbGwgY2hhY2sgZm9yIGNoYW5nZSBpbiBgbXVsdGlUZW1wbGF0ZURhdGFSb3dzYCBzZXR0ZXIgZnJvbSBwcmV2aW91cyB2YWx1ZS4uLlxuICAgIHRoaXMuZ3JpZC5fY2RrVGFibGUubXVsdGlUZW1wbGF0ZURhdGFSb3dzID0gISF0aGlzLl9kZXRhaWxSb3c7XG4gIH1cbn1cbiJdfQ==