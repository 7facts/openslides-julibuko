var PblNgridColumnReorderPluginDirective_1;
/**
 * @fileoverview added by tsickle
 * Generated from: lib/drag-and-drop/column/column-reorder-plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __decorate, __metadata } from "tslib";
// tslint:disable:no-output-rename
import { BehaviorSubject } from 'rxjs';
import { ChangeDetectorRef, Directive, ElementRef, Input, Inject, SkipSelf, Output, Optional, ViewContainerRef, NgZone, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DragDrop, CdkDrag, CDK_DROP_LIST, CdkDropListGroup, CdkDropList, CDK_DRAG_CONFIG, } from '@angular/cdk/drag-drop';
import { PblNgridComponent, NgridPlugin, PblNgridPluginController } from '@pebula/ngrid';
import { PblDragDrop } from '../core/drag-drop';
import { CdkLazyDropList, CdkLazyDrag } from '../core/lazy-drag-drop';
import { extendGrid } from './extend-grid';
/** @type {?} */
export const PLUGIN_KEY = 'columnReorder';
/** @type {?} */
let _uniqueIdCounter = 0;
/**
 * @template T
 */
let PblNgridColumnReorderPluginDirective = PblNgridColumnReorderPluginDirective_1 = /**
 * @template T
 */
class PblNgridColumnReorderPluginDirective extends CdkDropList {
    /**
     * @param {?} table
     * @param {?} pluginCtrl
     * @param {?} element
     * @param {?} dragDrop
     * @param {?} changeDetectorRef
     * @param {?=} dir
     * @param {?=} group
     */
    constructor(table, pluginCtrl, element, dragDrop, changeDetectorRef, dir, group) {
        super(element, dragDrop, changeDetectorRef, dir, group);
        this.table = table;
        this.id = `pbl-ngrid-column-reorder-list-${_uniqueIdCounter++}`;
        this.orientation = 'horizontal';
        this.dragging = new BehaviorSubject(false);
        this._columnReorder = false;
        this._manualOverride = false;
        this._draggablesSet = new Set();
        this._removePlugin = pluginCtrl.setPlugin(PLUGIN_KEY, this);
        this.directContainerElement = '.pbl-ngrid-header-row-main';
        this.dropped.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (!this.manualOverride) {
                this.table.columnApi.moveColumn(((/** @type {?} */ (event.item))).column, event.currentIndex);
            }
        }));
        this.dragging.subscribe((/**
         * @param {?} isDragging
         * @return {?}
         */
        isDragging => {
            /** @type {?} */
            const el = element.nativeElement;
            if (isDragging) {
                el.classList.add('pbl-ngrid-column-list-dragging');
            }
            else {
                el.classList.remove('pbl-ngrid-column-list-dragging');
            }
            this.lastSwap = undefined;
        }));
        this.monkeyPatchDropListRef();
    }
    /**
     * @return {?}
     */
    get columnReorder() { return this._columnReorder; }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set columnReorder(value) {
        value = coerceBooleanProperty(value);
        this._columnReorder = value;
    }
    /**
     * When true, will not move the column on drop.
     * Instead you need to handle the dropped event.
     * @return {?}
     */
    get manualOverride() { return this._manualOverride; }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set manualOverride(value) { this._manualOverride = coerceBooleanProperty(value); }
    // Stuff to workaround encapsulation in CdkDropList
    /**
     * @private
     * @return {?}
     */
    get pblGetItemIndexFromPointerPosition() {
        return ((/** @type {?} */ (this._dropListRef)))._getItemIndexFromPointerPosition.bind(this._dropListRef);
    }
    /**
     * @private
     * @return {?}
     */
    get pblGetPositionCacheItems() {
        return ((/** @type {?} */ (this._dropListRef)))._itemPositions;
    }
    /**
     * @return {?}
     */
    get pblDropListRef() { return (/** @type {?} */ (this._dropListRef)); }
    // ngOnInit(): void { CdkLazyDropList.prototype.ngOnInit.call(this); }
    /**
     * @param {?} drag
     * @return {?}
     */
    addDrag(drag) { return CdkLazyDropList.prototype.addDrag.call(this, drag); }
    /**
     * @param {?} drag
     * @return {?}
     */
    removeDrag(drag) { return CdkLazyDropList.prototype.removeDrag.call(this, drag); }
    // beforeStarted(): void { CdkLazyDropList.prototype.beforeStarted.call(this); }
    /* CdkLazyDropList end */
    /**
     * @return {?}
     */
    ngOnInit() {
        CdkLazyDropList.prototype.ngOnInit.call(this); // super.ngOnInit();
        this.dropped.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        e => this._pblReset()));
        this.pblDropListRef.beforeExit.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        e => this._pblReset()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this._removePlugin(this.table);
    }
    /* protected */ /**
     * @return {?}
     */
    beforeStarted() {
        CdkLazyDropList.prototype.beforeStarted.call(this); // super.beforeStarted();
        this.lastSorted = undefined;
        this.dragging.next(true);
    }
    /**
     * @private
     * @return {?}
     */
    _pblReset() {
        this.dragging.next(false);
        /** @type {?} */
        const siblings = this.pblGetPositionCacheItems;
        siblings.forEach((/**
         * @param {?} sibling
         * @param {?} index
         * @return {?}
         */
        (sibling, index) => {
            for (const c of sibling.drag.data.getCells()) {
                c.style.transform = ``;
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    monkeyPatchDropListRef() {
        const { _sortItem, enter } = this._dropListRef;
        this.pblDropListRef.enter = (/**
         * @param {?} item
         * @param {?} pointerX
         * @param {?} pointerY
         * @return {?}
         */
        (item, pointerX, pointerY) => {
            /** @type {?} */
            const lastSorted = this.lastSorted;
            this.lastSorted = undefined;
            if (lastSorted && lastSorted.drag === item) {
                /** @type {?} */
                const isHorizontal = this.orientation === 'horizontal';
                pointerX = lastSorted.clientRect.left + 1 - (isHorizontal ? lastSorted.offset : 0);
                pointerY = lastSorted.clientRect.top + 1 - (!isHorizontal ? lastSorted.offset : 0);
            }
            enter.call(this._dropListRef, item, pointerX, pointerY);
        });
        this.pblDropListRef._sortItem = (/**
         * @param {?} item
         * @param {?} pointerX
         * @param {?} pointerY
         * @param {?} pointerDelta
         * @return {?}
         */
        (item, pointerX, pointerY, pointerDelta) => {
            /** @type {?} */
            const siblings = this.pblGetPositionCacheItems;
            this.lastSorted = siblings.find((/**
             * @param {?} s
             * @return {?}
             */
            s => s.drag === item));
            /** @type {?} */
            const newIndex = this.pblGetItemIndexFromPointerPosition((/** @type {?} */ (item)), pointerX, pointerY, pointerDelta);
            if (newIndex === -1 && siblings.length > 0) {
                return;
            }
            /** @type {?} */
            const oldOrder = siblings.slice();
            /** @type {?} */
            const isHorizontal = this.orientation === 'horizontal';
            /** @type {?} */
            const siblingAtNewPosition = siblings[newIndex];
            if (siblingAtNewPosition.drag.data.column.wontBudge) {
                return;
            }
            // we now need to find if between current and new position there are items with `wontBudge`
            /** @type {?} */
            const itemAtOriginalPosition = this.lastSwap ? this.lastSwap : item;
            /** @type {?} */
            const currentIndex = siblings.findIndex((/**
             * @param {?} currentItem
             * @return {?}
             */
            currentItem => currentItem.drag === itemAtOriginalPosition));
            /** @type {?} */
            const start = Math.min(newIndex, currentIndex);
            /** @type {?} */
            const itemsDraggedOver = siblings.slice(start, Math.abs(newIndex - currentIndex) + start);
            for (const dragItem of itemsDraggedOver) {
                if (dragItem.drag.data.column.wontBudge && dragItem.drag !== item) {
                    return;
                }
            }
            // check if we move the item outside of locked group OR into a locked group... both are invalid.
            if (!item.data.column.checkGroupLockConstraint(siblingAtNewPosition.drag.data.column)) {
                return;
            }
            _sortItem.call(this._dropListRef, item, pointerX, pointerY, pointerDelta);
            this.lastSwap = siblingAtNewPosition.drag;
            if (isHorizontal) {
                siblings.forEach((/**
                 * @param {?} sibling
                 * @param {?} index
                 * @return {?}
                 */
                (sibling, index) => {
                    // Don't do anything if the position hasn't changed.
                    if (oldOrder[index] === sibling) {
                        return;
                    }
                    for (const c of sibling.drag.data.getCells()) {
                        c.style.transform = `translate3d(${sibling.offset}px, 0, 0)`;
                    }
                }));
            }
        });
    }
};
PblNgridColumnReorderPluginDirective.decorators = [
    { type: Directive, args: [{
                selector: 'pbl-ngrid[columnReorder]',
                exportAs: 'pblNgridColumnReorder',
                inputs: [
                    'directContainerElement:cdkDropListDirectContainerElement'
                ],
                host: {
                    // tslint:disable-line:use-host-property-decorator
                    'class': 'cdk-drop-list',
                    '[id]': 'id',
                    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',
                    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',
                },
                providers: [
                    { provide: DragDrop, useExisting: PblDragDrop },
                    { provide: CDK_DROP_LIST, useExisting: PblNgridColumnReorderPluginDirective_1 },
                ],
            },] }
];
/** @nocollapse */
PblNgridColumnReorderPluginDirective.ctorParameters = () => [
    { type: PblNgridComponent },
    { type: PblNgridPluginController },
    { type: ElementRef },
    { type: DragDrop },
    { type: ChangeDetectorRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
PblNgridColumnReorderPluginDirective.propDecorators = {
    columnReorder: [{ type: Input }],
    manualOverride: [{ type: Input }],
    dragging: [{ type: Output, args: ['cdkDropDragging',] }]
};
/**
 * @template T
 */
PblNgridColumnReorderPluginDirective = PblNgridColumnReorderPluginDirective_1 = __decorate([
    NgridPlugin({ id: PLUGIN_KEY, runOnce: extendGrid }),
    __metadata("design:paramtypes", [PblNgridComponent,
        PblNgridPluginController,
        ElementRef,
        DragDrop,
        ChangeDetectorRef,
        Directionality,
        CdkDropListGroup])
], PblNgridColumnReorderPluginDirective);
export { PblNgridColumnReorderPluginDirective };
if (false) {
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.id;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.orientation;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.dragging;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype._draggables;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype._columnReorder;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype._manualOverride;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype._removePlugin;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype.lastSwap;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnReorderPluginDirective.prototype.lastSorted;
    /**
     * Selector that will be used to determine the direct container element, starting from
     * the `cdkDropList` element and going down the DOM. Passing an alternate direct container element
     * is useful when the `cdkDropList` is not the direct parent (i.e. ancestor but not father)
     * of the draggable elements.
     * @type {?}
     */
    PblNgridColumnReorderPluginDirective.prototype.directContainerElement;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.originalElement;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype._draggablesSet;
    /** @type {?} */
    PblNgridColumnReorderPluginDirective.prototype.table;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
/**
 * @template T
 */
export class PblNgridColumnDragDirective extends CdkDrag {
    // CTOR IS REQUIRED OR IT WONT WORK IN AOT
    // TODO: Try to remove when supporting IVY
    /**
     * @param {?} element
     * @param {?} dropContainer
     * @param {?} _document
     * @param {?} _ngZone
     * @param {?} _viewContainerRef
     * @param {?} config
     * @param {?} _dir
     * @param {?} dragDrop
     * @param {?} _changeDetectorRef
     */
    constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {
        super(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef);
        this.rootElementSelector = 'pbl-ngrid-header-cell';
        this._hostNotRoot = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set context(value) {
        this._context = value;
        this.column = value && value.col;
        /** @type {?} */
        const pluginCtrl = this.pluginCtrl = value && PblNgridPluginController.find(value.grid);
        /** @type {?} */
        const plugin = pluginCtrl && pluginCtrl.getPlugin(PLUGIN_KEY);
        this.cdkDropList = plugin || undefined;
        this.disabled = this.column && this.column.reorder ? false : true;
    }
    /* CdkLazyDrag start */
    /**
     * A class to set when the root element is not the host element. (i.e. when `cdkDragRootElement` is used).
     * @param {?} value
     * @return {?}
     */
    set rootElementSelectorClass(value) {
        if (value !== this._rootClass && this._hostNotRoot) {
            if (this._rootClass) {
                this.getRootElement().classList.remove(...this._rootClass.split(' '));
            }
            if (value) {
                this.getRootElement().classList.add(...value.split(' '));
            }
        }
        this._rootClass = value;
    }
    /**
     * @return {?}
     */
    get pblDragRef() { return (/** @type {?} */ (this._dragRef)); }
    /**
     * @return {?}
     */
    get cdkDropList() { return (/** @type {?} */ (this.dropContainer)); }
    /**
     * @param {?} value
     * @return {?}
     */
    set cdkDropList(value) {
        // TO SUPPORT `cdkDropList` via string input (ID) we need a reactive registry...
        if (this.cdkDropList) {
            this.cdkDropList.removeDrag(this);
        }
        this.dropContainer = value;
        if (value) {
            this._dragRef._withDropContainer(value._dropListRef);
            value.addDrag(this);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() { CdkLazyDrag.prototype.ngOnInit.call(this); }
    // ngAfterViewInit(): void { CdkLazyDrag.prototype.ngAfterViewInit.call(this); super.ngAfterViewInit(); }
    /**
     * @return {?}
     */
    ngOnDestroy() { CdkLazyDrag.prototype.ngOnDestroy.call(this); super.ngOnDestroy(); }
    /* CdkLazyDrag end */
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        CdkLazyDrag.prototype.ngAfterViewInit.call(this);
        super.ngAfterViewInit();
        this._dragRef.beforeStarted.subscribe((/**
         * @return {?}
         */
        () => {
            const { cdkDropList } = this;
            if (cdkDropList && cdkDropList.columnReorder && this._context.col.reorder) {
                // we don't allow a new dragging session before the previous ends.
                // this sound impossible, but due to animation transitions its actually is.
                // if the `transitionend` is long enough, a new drag can start...
                //
                // the `disabled` state is checked by pointerDown AFTER calling before start so we can cancel the start...
                if (cdkDropList._dropListRef.isDragging()) {
                    return this.disabled = true;
                }
            }
        }));
        this.started.subscribe((/**
         * @return {?}
         */
        () => this._context.col.columnDef.isDragging = true));
        this.ended.subscribe((/**
         * @return {?}
         */
        () => this._context.col.columnDef.isDragging = false));
    }
    /**
     * @return {?}
     */
    getCells() {
        if (!this.cache) {
            this.cache = this._context.col.columnDef.queryCellElements('table');
        }
        return this.cache;
    }
    /**
     * @return {?}
     */
    reset() {
        super.reset();
        if (this.cache) {
            for (const el of this.cache) {
                el.style.transform = ``;
            }
            this.cache = undefined;
        }
    }
}
PblNgridColumnDragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pblNgridColumnDrag]',
                exportAs: 'pblNgridColumnDrag',
                host: {
                    // tslint:disable-line:use-host-property-decorator
                    'class': 'cdk-drag',
                    '[class.cdk-drag-dragging]': '_dragRef.isDragging()',
                },
                providers: [
                    { provide: DragDrop, useExisting: PblDragDrop },
                    { provide: CdkDrag, useExisting: PblNgridColumnDragDirective }
                ]
            },] }
];
/** @nocollapse */
PblNgridColumnDragDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: CdkDropList, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },
    { type: Directionality },
    { type: DragDrop },
    { type: ChangeDetectorRef }
];
PblNgridColumnDragDirective.propDecorators = {
    context: [{ type: Input, args: ['pblNgridColumnDrag',] }],
    rootElementSelectorClass: [{ type: Input, args: ['cdkDragRootElementClass',] }],
    cdkDropList: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    PblNgridColumnDragDirective.prototype.rootElementSelector;
    /** @type {?} */
    PblNgridColumnDragDirective.prototype.column;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnDragDirective.prototype._context;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnDragDirective.prototype.pluginCtrl;
    /**
     * @type {?}
     * @private
     */
    PblNgridColumnDragDirective.prototype.cache;
    /** @type {?} */
    PblNgridColumnDragDirective.prototype._rootClass;
    /** @type {?} */
    PblNgridColumnDragDirective.prototype._hostNotRoot;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLXJlb3JkZXItcGx1Z2luLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBlYnVsYS9uZ3JpZC9kcmFnLyIsInNvdXJjZXMiOlsibGliL2RyYWctYW5kLWRyb3AvY29sdW1uL2NvbHVtbi1yZW9yZGVyLXBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFdkMsT0FBTyxFQUVMLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLEtBQUssRUFDTCxNQUFNLEVBQ04sUUFBUSxFQUNSLE1BQU0sRUFFTixRQUFRLEVBRVIsZ0JBQWdCLEVBQ2hCLE1BQU0sR0FFUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFDTCxRQUFRLEVBQ1IsT0FBTyxFQUVQLGFBQWEsRUFFYixnQkFBZ0IsRUFDaEIsV0FBVyxFQUNYLGVBQWUsR0FFaEIsTUFBTSx3QkFBd0IsQ0FBQztBQUVoQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFhLHdCQUF3QixFQUF1QixNQUFNLGVBQWUsQ0FBQztBQUN6SCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDaEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUd0RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQVEzQyxNQUFNLE9BQU8sVUFBVSxHQUFvQixlQUFlOztJQUV0RCxnQkFBZ0IsR0FBRyxDQUFDOzs7O0lBb0JYLG9DQUFvQzs7O01BQXBDLG9DQUE4QyxTQUFRLFdBQWM7Ozs7Ozs7Ozs7SUFt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QUM7UUFDZCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDZCxLQUFLLE1BQU0sRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQzNCLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQzthQUN6QjtZQUNELElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQzs7O1lBaElGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsc0JBQXNCO2dCQUNoQyxRQUFRLEVBQUUsb0JBQW9CO2dCQUM5QixJQUFJLEVBQUU7O29CQUNKLE9BQU8sRUFBRSxVQUFVO29CQUNuQiwyQkFBMkIsRUFBRSx1QkFBdUI7aUJBQ3JEO2dCQUNELFNBQVMsRUFBRTtvQkFDVCxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRTtvQkFDL0MsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSwyQkFBMkIsRUFBRTtpQkFDL0Q7YUFDRjs7OztZQXhQQyxVQUFVO1lBdUJWLFdBQVcsdUJBdVBFLE1BQU0sU0FBQyxhQUFhLGNBQUcsUUFBUSxZQUFJLFFBQVE7NENBQzNDLE1BQU0sU0FBQyxRQUFRO1lBdFE1QixNQUFNO1lBRE4sZ0JBQWdCOzRDQTBRSCxNQUFNLFNBQUMsZUFBZTtZQXBRNUIsY0FBYztZQUdyQixRQUFRO1lBbkJSLGlCQUFpQjs7O3NCQWdRaEIsS0FBSyxTQUFDLG9CQUFvQjt1Q0F5QzFCLEtBQUssU0FBQyx5QkFBeUI7MEJBYy9CLEtBQUs7Ozs7SUEzRE4sMERBQThDOztJQUU5Qyw2Q0FBa0I7Ozs7O0lBV2xCLCtDQUF1SDs7Ozs7SUFDdkgsaURBQTZDOzs7OztJQUM3Qyw0Q0FBNkI7O0lBeUQ3QixpREFBbUI7O0lBQ25CLG1EQUFxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLW91dHB1dC1yZW5hbWVcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgSW5qZWN0LFxuICBTa2lwU2VsZixcbiAgT3V0cHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBPbkluaXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIE5nWm9uZSxcbiAgUXVlcnlMaXN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgRHJhZ0Ryb3AsXG4gIENka0RyYWcsXG4gIENka0RyYWdEcm9wLFxuICBDREtfRFJPUF9MSVNULFxuICBEcmFnUmVmLFxuICBDZGtEcm9wTGlzdEdyb3VwLFxuICBDZGtEcm9wTGlzdCxcbiAgQ0RLX0RSQUdfQ09ORklHLFxuICBEcmFnUmVmQ29uZmlnLFxufSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcblxuaW1wb3J0IHsgUGJsTmdyaWRDb21wb25lbnQsIE5ncmlkUGx1Z2luLCBQYmxDb2x1bW4sIFBibE5ncmlkUGx1Z2luQ29udHJvbGxlciwgUGJsTmdyaWRDZWxsQ29udGV4dCB9IGZyb20gJ0BwZWJ1bGEvbmdyaWQnO1xuaW1wb3J0IHsgUGJsRHJhZ0Ryb3AgfSBmcm9tICcuLi9jb3JlL2RyYWctZHJvcCc7XG5pbXBvcnQgeyBDZGtMYXp5RHJvcExpc3QsIENka0xhenlEcmFnIH0gZnJvbSAnLi4vY29yZS9sYXp5LWRyYWctZHJvcCc7XG5pbXBvcnQgeyBQYmxEcm9wTGlzdFJlZiB9IGZyb20gJy4uL2NvcmUvZHJvcC1saXN0LXJlZic7XG5pbXBvcnQgeyBQYmxEcmFnUmVmIH0gZnJvbSAnLi4vY29yZS9kcmFnLXJlZic7XG5pbXBvcnQgeyBleHRlbmRHcmlkIH0gZnJvbSAnLi9leHRlbmQtZ3JpZCc7XG5cbmRlY2xhcmUgbW9kdWxlICdAcGVidWxhL25ncmlkL2xpYi9leHQvdHlwZXMnIHtcbiAgaW50ZXJmYWNlIFBibE5ncmlkUGx1Z2luRXh0ZW5zaW9uIHtcbiAgICBjb2x1bW5SZW9yZGVyPzogUGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQTFVHSU5fS0VZOiAnY29sdW1uUmVvcmRlcicgPSAnY29sdW1uUmVvcmRlcic7XG5cbmxldCBfdW5pcXVlSWRDb3VudGVyID0gMDtcblxuQE5ncmlkUGx1Z2luKHsgaWQ6IFBMVUdJTl9LRVksIHJ1bk9uY2U6IGV4dGVuZEdyaWQgfSlcbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ3BibC1uZ3JpZFtjb2x1bW5SZW9yZGVyXScsXG4gIGV4cG9ydEFzOiAncGJsTmdyaWRDb2x1bW5SZW9yZGVyJyxcbiAgaW5wdXRzOiBbXG4gICAgJ2RpcmVjdENvbnRhaW5lckVsZW1lbnQ6Y2RrRHJvcExpc3REaXJlY3RDb250YWluZXJFbGVtZW50J1xuICBdLFxuICBob3N0OiB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6dXNlLWhvc3QtcHJvcGVydHktZGVjb3JhdG9yXG4gICAgJ2NsYXNzJzogJ2Nkay1kcm9wLWxpc3QnLFxuICAgICdbaWRdJzogJ2lkJyxcbiAgICAnW2NsYXNzLmNkay1kcm9wLWxpc3QtZHJhZ2dpbmddJzogJ19kcm9wTGlzdFJlZi5pc0RyYWdnaW5nKCknLFxuICAgICdbY2xhc3MuY2RrLWRyb3AtbGlzdC1yZWNlaXZpbmddJzogJ19kcm9wTGlzdFJlZi5pc1JlY2VpdmluZygpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbXG4gICAgeyBwcm92aWRlOiBEcmFnRHJvcCwgdXNlRXhpc3Rpbmc6IFBibERyYWdEcm9wIH0sXG4gICAgeyBwcm92aWRlOiBDREtfRFJPUF9MSVNULCB1c2VFeGlzdGluZzogUGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUID0gYW55PiBleHRlbmRzIENka0Ryb3BMaXN0PFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIENka0xhenlEcm9wTGlzdDxULCBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU8VD4+IHtcbiAgaWQgPSBgcGJsLW5ncmlkLWNvbHVtbi1yZW9yZGVyLWxpc3QtJHtfdW5pcXVlSWRDb3VudGVyKyt9YDtcbiAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgPSAnaG9yaXpvbnRhbCc7XG5cbiAgQElucHV0KCkgZ2V0IGNvbHVtblJlb3JkZXIoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9jb2x1bW5SZW9yZGVyOyB9O1xuICBzZXQgY29sdW1uUmVvcmRlcih2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICB0aGlzLl9jb2x1bW5SZW9yZGVyID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0cnVlLCB3aWxsIG5vdCBtb3ZlIHRoZSBjb2x1bW4gb24gZHJvcC5cbiAgICogSW5zdGVhZCB5b3UgbmVlZCB0byBoYW5kbGUgdGhlIGRyb3BwZWQgZXZlbnQuXG4gICAqL1xuICBASW5wdXQoKSBnZXQgbWFudWFsT3ZlcnJpZGUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9tYW51YWxPdmVycmlkZTsgfTtcbiAgc2V0IG1hbnVhbE92ZXJyaWRlKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX21hbnVhbE92ZXJyaWRlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIEBPdXRwdXQoJ2Nka0Ryb3BEcmFnZ2luZycpIGRyYWdnaW5nOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICBfZHJhZ2dhYmxlczogUXVlcnlMaXN0PENka0RyYWc+O1xuXG4gIHByaXZhdGUgX2NvbHVtblJlb3JkZXIgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfbWFudWFsT3ZlcnJpZGUgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfcmVtb3ZlUGx1Z2luOiAodGFibGU6IFBibE5ncmlkQ29tcG9uZW50PGFueT4pID0+IHZvaWQ7XG4gIHByaXZhdGUgbGFzdFN3YXA6IERyYWdSZWY8UGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+PjtcbiAgcHJpdmF0ZSBsYXN0U29ydGVkOiB7IGRyYWc6IERyYWdSZWY8UGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+Pjsgb2Zmc2V0OiBudW1iZXI7IGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7IH07XG5cbiAgLy8gU3R1ZmYgdG8gd29ya2Fyb3VuZCBlbmNhcHN1bGF0aW9uIGluIENka0Ryb3BMaXN0XG4gIHByaXZhdGUgZ2V0IHBibEdldEl0ZW1JbmRleEZyb21Qb2ludGVyUG9zaXRpb24oKTogKGl0ZW06IERyYWdSZWY8UGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+PiwgcG9pbnRlclg6IG51bWJlciwgcG9pbnRlclk6IG51bWJlciwgZGVsdGE/OiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9KSA9PiBudW1iZXIge1xuICAgIHJldHVybiAodGhpcy5fZHJvcExpc3RSZWYgYXMgYW55KS5fZ2V0SXRlbUluZGV4RnJvbVBvaW50ZXJQb3NpdGlvbi5iaW5kKHRoaXMuX2Ryb3BMaXN0UmVmKTtcbiAgfVxuICBwcml2YXRlIGdldCBwYmxHZXRQb3NpdGlvbkNhY2hlSXRlbXMoKTogeyBkcmFnOiBEcmFnUmVmPFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUPj47IG9mZnNldDogbnVtYmVyOyBjbGllbnRSZWN0OiBDbGllbnRSZWN0OyB9W10ge1xuICAgIHJldHVybiAodGhpcy5fZHJvcExpc3RSZWYgYXMgYW55KS5faXRlbVBvc2l0aW9ucztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWJsZTogUGJsTmdyaWRDb21wb25lbnQ8VD4sXG4gICAgICAgICAgICAgIHBsdWdpbkN0cmw6IFBibE5ncmlkUGx1Z2luQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgICAgICAgIGRyYWdEcm9wOiBEcmFnRHJvcCxcbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBkaXI/OiBEaXJlY3Rpb25hbGl0eSxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQFNraXBTZWxmKCkgZ3JvdXA/OiBDZGtEcm9wTGlzdEdyb3VwPENka0Ryb3BMaXN0Pikge1xuICAgIHN1cGVyKGVsZW1lbnQsIGRyYWdEcm9wLCBjaGFuZ2VEZXRlY3RvclJlZiwgZGlyLCBncm91cCk7XG4gICAgdGhpcy5fcmVtb3ZlUGx1Z2luID0gcGx1Z2luQ3RybC5zZXRQbHVnaW4oUExVR0lOX0tFWSwgdGhpcyk7XG5cbiAgICB0aGlzLmRpcmVjdENvbnRhaW5lckVsZW1lbnQgPSAnLnBibC1uZ3JpZC1oZWFkZXItcm93LW1haW4nO1xuICAgIHRoaXMuZHJvcHBlZC5zdWJzY3JpYmUoIChldmVudDogQ2RrRHJhZ0Ryb3A8VCwgYW55PikgPT4ge1xuICAgICAgaWYgKCF0aGlzLm1hbnVhbE92ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMudGFibGUuY29sdW1uQXBpLm1vdmVDb2x1bW4oKGV2ZW50Lml0ZW0gYXMgUGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+KS5jb2x1bW4sIGV2ZW50LmN1cnJlbnRJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdnaW5nLnN1YnNjcmliZSggaXNEcmFnZ2luZyA9PiB7XG4gICAgICBjb25zdCBlbCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3BibC1uZ3JpZC1jb2x1bW4tbGlzdC1kcmFnZ2luZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncGJsLW5ncmlkLWNvbHVtbi1saXN0LWRyYWdnaW5nJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RTd2FwID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb25rZXlQYXRjaERyb3BMaXN0UmVmKCk7XG4gIH1cblxuICAvKiBDZGtMYXp5RHJvcExpc3Qgc3RhcnQgKi9cbiAgLyoqXG4gICAqIFNlbGVjdG9yIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgZGlyZWN0IGNvbnRhaW5lciBlbGVtZW50LCBzdGFydGluZyBmcm9tXG4gICAqIHRoZSBgY2RrRHJvcExpc3RgIGVsZW1lbnQgYW5kIGdvaW5nIGRvd24gdGhlIERPTS4gUGFzc2luZyBhbiBhbHRlcm5hdGUgZGlyZWN0IGNvbnRhaW5lciBlbGVtZW50XG4gICAqIGlzIHVzZWZ1bCB3aGVuIHRoZSBgY2RrRHJvcExpc3RgIGlzIG5vdCB0aGUgZGlyZWN0IHBhcmVudCAoaS5lLiBhbmNlc3RvciBidXQgbm90IGZhdGhlcilcbiAgICogb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50cy5cbiAgICovXG4gIGRpcmVjdENvbnRhaW5lckVsZW1lbnQ6IHN0cmluZztcbiAgZ2V0IHBibERyb3BMaXN0UmVmKCk6IFBibERyb3BMaXN0UmVmPFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPj4geyByZXR1cm4gdGhpcy5fZHJvcExpc3RSZWYgYXMgYW55OyB9XG4gIG9yaWdpbmFsRWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gIF9kcmFnZ2FibGVzU2V0ID0gbmV3IFNldDxDZGtEcmFnPigpO1xuICAvLyBuZ09uSW5pdCgpOiB2b2lkIHsgQ2RrTGF6eURyb3BMaXN0LnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpOyB9XG4gIGFkZERyYWcoZHJhZzogQ2RrRHJhZyk6IHZvaWQgeyByZXR1cm4gQ2RrTGF6eURyb3BMaXN0LnByb3RvdHlwZS5hZGREcmFnLmNhbGwodGhpcywgZHJhZyk7IH1cbiAgcmVtb3ZlRHJhZyhkcmFnOiBDZGtEcmFnKTogYm9vbGVhbiB7IHJldHVybiBDZGtMYXp5RHJvcExpc3QucHJvdG90eXBlLnJlbW92ZURyYWcuY2FsbCh0aGlzLCBkcmFnKTsgfVxuICAvLyBiZWZvcmVTdGFydGVkKCk6IHZvaWQgeyBDZGtMYXp5RHJvcExpc3QucHJvdG90eXBlLmJlZm9yZVN0YXJ0ZWQuY2FsbCh0aGlzKTsgfVxuICAvKiBDZGtMYXp5RHJvcExpc3QgZW5kICovXG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgQ2RrTGF6eURyb3BMaXN0LnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpOyAvLyBzdXBlci5uZ09uSW5pdCgpO1xuICAgIHRoaXMuZHJvcHBlZC5zdWJzY3JpYmUoIGUgPT4gdGhpcy5fcGJsUmVzZXQoKSApO1xuICAgIHRoaXMucGJsRHJvcExpc3RSZWYuYmVmb3JlRXhpdC5zdWJzY3JpYmUoIGUgPT4gdGhpcy5fcGJsUmVzZXQoKSApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICB0aGlzLl9yZW1vdmVQbHVnaW4odGhpcy50YWJsZSk7XG4gIH1cblxuICAvKiBwcm90ZWN0ZWQgKi8gYmVmb3JlU3RhcnRlZCgpOiB2b2lkIHtcbiAgICBDZGtMYXp5RHJvcExpc3QucHJvdG90eXBlLmJlZm9yZVN0YXJ0ZWQuY2FsbCh0aGlzKTsgLy8gc3VwZXIuYmVmb3JlU3RhcnRlZCgpO1xuICAgIHRoaXMubGFzdFNvcnRlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRyYWdnaW5nLm5leHQodHJ1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9wYmxSZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmRyYWdnaW5nLm5leHQoZmFsc2UpO1xuICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5wYmxHZXRQb3NpdGlvbkNhY2hlSXRlbXM7XG4gICAgc2libGluZ3MuZm9yRWFjaCgoc2libGluZywgaW5kZXgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBzaWJsaW5nLmRyYWcuZGF0YS5nZXRDZWxscygpKSB7XG4gICAgICAgIGMuc3R5bGUudHJhbnNmb3JtID0gYGA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG1vbmtleVBhdGNoRHJvcExpc3RSZWYoKTogdm9pZCB7XG4gICAgY29uc3QgeyBfc29ydEl0ZW0sIGVudGVyIH0gPSB0aGlzLl9kcm9wTGlzdFJlZjtcblxuICAgIHRoaXMucGJsRHJvcExpc3RSZWYuZW50ZXIgPSAoaXRlbTogUGFyYW1ldGVyczx0eXBlb2YgZW50ZXI+WzBdLCBwb2ludGVyWDogbnVtYmVyLCBwb2ludGVyWTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBsYXN0U29ydGVkID0gdGhpcy5sYXN0U29ydGVkXG4gICAgICB0aGlzLmxhc3RTb3J0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAobGFzdFNvcnRlZCAmJiBsYXN0U29ydGVkLmRyYWcgPT09IGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICBwb2ludGVyWCA9IGxhc3RTb3J0ZWQuY2xpZW50UmVjdC5sZWZ0ICsgMSAtIChpc0hvcml6b250YWwgPyBsYXN0U29ydGVkLm9mZnNldCA6IDApO1xuICAgICAgICBwb2ludGVyWSA9IGxhc3RTb3J0ZWQuY2xpZW50UmVjdC50b3AgKyAxIC0gKCFpc0hvcml6b250YWwgPyBsYXN0U29ydGVkLm9mZnNldCA6IDApO1xuICAgICAgfVxuICAgICAgZW50ZXIuY2FsbCh0aGlzLl9kcm9wTGlzdFJlZiwgaXRlbSwgcG9pbnRlclgsIHBvaW50ZXJZKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wYmxEcm9wTGlzdFJlZi5fc29ydEl0ZW0gPSAoaXRlbTogUGFyYW1ldGVyczx0eXBlb2YgZW50ZXI+WzBdLCBwb2ludGVyWDogbnVtYmVyLCBwb2ludGVyWTogbnVtYmVyLCBwb2ludGVyRGVsdGE6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5wYmxHZXRQb3NpdGlvbkNhY2hlSXRlbXM7XG4gICAgICB0aGlzLmxhc3RTb3J0ZWQgPSBzaWJsaW5ncy5maW5kKCBzID0+IHMuZHJhZyA9PT0gaXRlbSApO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLnBibEdldEl0ZW1JbmRleEZyb21Qb2ludGVyUG9zaXRpb24oaXRlbSBhcyBEcmFnUmVmPFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUPj4sIHBvaW50ZXJYLCBwb2ludGVyWSwgcG9pbnRlckRlbHRhKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gLTEgJiYgc2libGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRPcmRlciA9IHNpYmxpbmdzLnNsaWNlKCk7XG4gICAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICBjb25zdCBzaWJsaW5nQXROZXdQb3NpdGlvbiA9IHNpYmxpbmdzW25ld0luZGV4XTtcblxuICAgICAgaWYgKHNpYmxpbmdBdE5ld1Bvc2l0aW9uLmRyYWcuZGF0YS5jb2x1bW4ud29udEJ1ZGdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2Ugbm93IG5lZWQgdG8gZmluZCBpZiBiZXR3ZWVuIGN1cnJlbnQgYW5kIG5ldyBwb3NpdGlvbiB0aGVyZSBhcmUgaXRlbXMgd2l0aCBgd29udEJ1ZGdlYFxuICAgICAgY29uc3QgaXRlbUF0T3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMubGFzdFN3YXAgPyB0aGlzLmxhc3RTd2FwIDogaXRlbTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHNpYmxpbmdzLmZpbmRJbmRleCggY3VycmVudEl0ZW0gPT4gY3VycmVudEl0ZW0uZHJhZyA9PT0gaXRlbUF0T3JpZ2luYWxQb3NpdGlvbiApO1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihuZXdJbmRleCwgY3VycmVudEluZGV4KVxuICAgICAgY29uc3QgaXRlbXNEcmFnZ2VkT3ZlciA9IHNpYmxpbmdzLnNsaWNlKHN0YXJ0LCBNYXRoLmFicyhuZXdJbmRleCAtIGN1cnJlbnRJbmRleCkgKyBzdGFydCk7XG4gICAgICBmb3IgKGNvbnN0IGRyYWdJdGVtIG9mIGl0ZW1zRHJhZ2dlZE92ZXIpIHtcbiAgICAgICAgaWYgKGRyYWdJdGVtLmRyYWcuZGF0YS5jb2x1bW4ud29udEJ1ZGdlICYmIGRyYWdJdGVtLmRyYWcgIT09IGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgd2UgbW92ZSB0aGUgaXRlbSBvdXRzaWRlIG9mIGxvY2tlZCBncm91cCBPUiBpbnRvIGEgbG9ja2VkIGdyb3VwLi4uIGJvdGggYXJlIGludmFsaWQuXG4gICAgICBpZiAoIWl0ZW0uZGF0YS5jb2x1bW4uY2hlY2tHcm91cExvY2tDb25zdHJhaW50KHNpYmxpbmdBdE5ld1Bvc2l0aW9uLmRyYWcuZGF0YS5jb2x1bW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3NvcnRJdGVtLmNhbGwodGhpcy5fZHJvcExpc3RSZWYsIGl0ZW0sIHBvaW50ZXJYLCBwb2ludGVyWSwgcG9pbnRlckRlbHRhKTtcblxuICAgICAgdGhpcy5sYXN0U3dhcCA9IHNpYmxpbmdBdE5ld1Bvc2l0aW9uLmRyYWc7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgc2libGluZ3MuZm9yRWFjaCgoc2libGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgcG9zaXRpb24gaGFzbid0IGNoYW5nZWQuXG4gICAgICAgICAgaWYgKG9sZE9yZGVyW2luZGV4XSA9PT0gc2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBzaWJsaW5nLmRyYWcuZGF0YS5nZXRDZWxscygpKSB7XG4gICAgICAgICAgICBjLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3NpYmxpbmcub2Zmc2V0fXB4LCAwLCAwKWA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1twYmxOZ3JpZENvbHVtbkRyYWddJyxcbiAgZXhwb3J0QXM6ICdwYmxOZ3JpZENvbHVtbkRyYWcnLFxuICBob3N0OiB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6dXNlLWhvc3QtcHJvcGVydHktZGVjb3JhdG9yXG4gICAgJ2NsYXNzJzogJ2Nkay1kcmFnJyxcbiAgICAnW2NsYXNzLmNkay1kcmFnLWRyYWdnaW5nXSc6ICdfZHJhZ1JlZi5pc0RyYWdnaW5nKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IERyYWdEcm9wLCB1c2VFeGlzdGluZzogUGJsRHJhZ0Ryb3AgfSxcbiAgICB7IHByb3ZpZGU6IENka0RyYWcsIHVzZUV4aXN0aW5nOiBQYmxOZ3JpZENvbHVtbkRyYWdEaXJlY3RpdmUgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUID0gYW55PiBleHRlbmRzIENka0RyYWc8VD4gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBDZGtMYXp5RHJhZzxULCBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU8VD4sIFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUPj4ge1xuICByb290RWxlbWVudFNlbGVjdG9yID0gJ3BibC1uZ3JpZC1oZWFkZXItY2VsbCc7XG5cbiAgY29sdW1uOiBQYmxDb2x1bW47XG5cbiAgQElucHV0KCdwYmxOZ3JpZENvbHVtbkRyYWcnKSBzZXQgY29udGV4dCh2YWx1ZTogUGljazxQYmxOZ3JpZENlbGxDb250ZXh0PFQ+LCAnY29sJyB8ICdncmlkJz4gJiBQYXJ0aWFsPFBpY2s8UGJsTmdyaWRDZWxsQ29udGV4dDxUPiwgJ3JvdycgfCAndmFsdWUnPj4pIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gdmFsdWU7XG4gICAgdGhpcy5jb2x1bW4gPSB2YWx1ZSAmJiB2YWx1ZS5jb2w7XG4gICAgY29uc3QgcGx1Z2luQ3RybCA9IHRoaXMucGx1Z2luQ3RybCA9IHZhbHVlICYmIFBibE5ncmlkUGx1Z2luQ29udHJvbGxlci5maW5kKHZhbHVlLmdyaWQpO1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbkN0cmwgJiYgcGx1Z2luQ3RybC5nZXRQbHVnaW4oUExVR0lOX0tFWSk7XG4gICAgdGhpcy5jZGtEcm9wTGlzdCA9IHBsdWdpbiB8fCB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuY29sdW1uICYmIHRoaXMuY29sdW1uLnJlb3JkZXIgPyBmYWxzZSA6IHRydWU7XG4gIH1cblxuICBwcml2YXRlIF9jb250ZXh0OiBQaWNrPFBibE5ncmlkQ2VsbENvbnRleHQ8VD4sICdjb2wnIHwgJ2dyaWQnPiAmIFBhcnRpYWw8UGljazxQYmxOZ3JpZENlbGxDb250ZXh0PFQ+LCAncm93JyB8ICd2YWx1ZSc+PlxuICBwcml2YXRlIHBsdWdpbkN0cmw6IFBibE5ncmlkUGx1Z2luQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBjYWNoZTogSFRNTEVsZW1lbnRbXTtcblxuICAvLyBDVE9SIElTIFJFUVVJUkVEIE9SIElUIFdPTlQgV09SSyBJTiBBT1RcbiAgLy8gVE9ETzogVHJ5IHRvIHJlbW92ZSB3aGVuIHN1cHBvcnRpbmcgSVZZXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICAgICAgICBASW5qZWN0KENES19EUk9QX0xJU1QpIEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIGRyb3BDb250YWluZXI6IENka0Ryb3BMaXN0LFxuICAgICAgICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBfZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgICAgICAgX25nWm9uZTogTmdab25lLFxuICAgICAgICAgICAgICBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgQEluamVjdChDREtfRFJBR19DT05GSUcpIGNvbmZpZzogRHJhZ1JlZkNvbmZpZyxcbiAgICAgICAgICAgICAgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgICAgICAgICAgIGRyYWdEcm9wOiBEcmFnRHJvcCxcbiAgICAgICAgICAgICAgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGRyb3BDb250YWluZXIsXG4gICAgICBfZG9jdW1lbnQsXG4gICAgICBfbmdab25lLFxuICAgICAgX3ZpZXdDb250YWluZXJSZWYsXG4gICAgICBjb25maWcsXG4gICAgICBfZGlyLFxuICAgICAgZHJhZ0Ryb3AsXG4gICAgICBfY2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgKTtcbiAgfVxuXG4gIC8qIENka0xhenlEcmFnIHN0YXJ0ICovXG4gIC8qKlxuICAgKiBBIGNsYXNzIHRvIHNldCB3aGVuIHRoZSByb290IGVsZW1lbnQgaXMgbm90IHRoZSBob3N0IGVsZW1lbnQuIChpLmUuIHdoZW4gYGNka0RyYWdSb290RWxlbWVudGAgaXMgdXNlZCkuXG4gICAqL1xuICBASW5wdXQoJ2Nka0RyYWdSb290RWxlbWVudENsYXNzJykgc2V0IHJvb3RFbGVtZW50U2VsZWN0b3JDbGFzcyh2YWx1ZTogc3RyaW5nKSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8taW5wdXQtcmVuYW1lXG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yb290Q2xhc3MgJiYgdGhpcy5faG9zdE5vdFJvb3QpIHtcbiAgICAgIGlmICh0aGlzLl9yb290Q2xhc3MpIHtcbiAgICAgICAgdGhpcy5nZXRSb290RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fcm9vdENsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Um9vdEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKC4uLnZhbHVlLnNwbGl0KCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yb290Q2xhc3MgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBwYmxEcmFnUmVmKCk6IFBibERyYWdSZWY8UGJsTmdyaWRDb2x1bW5EcmFnRGlyZWN0aXZlPFQ+PiB7IHJldHVybiB0aGlzLl9kcmFnUmVmIGFzIGFueTsgfVxuXG4gIEBJbnB1dCgpIGdldCBjZGtEcm9wTGlzdCgpOiBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU8VD4geyByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyIGFzIFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPjsgfVxuICBzZXQgY2RrRHJvcExpc3QodmFsdWU6IFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPikge1xuICAgIC8vIFRPIFNVUFBPUlQgYGNka0Ryb3BMaXN0YCB2aWEgc3RyaW5nIGlucHV0IChJRCkgd2UgbmVlZCBhIHJlYWN0aXZlIHJlZ2lzdHJ5Li4uXG4gICAgaWYgKHRoaXMuY2RrRHJvcExpc3QpIHtcbiAgICAgIHRoaXMuY2RrRHJvcExpc3QucmVtb3ZlRHJhZyh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5kcm9wQ29udGFpbmVyID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl9kcmFnUmVmLl93aXRoRHJvcENvbnRhaW5lcih2YWx1ZS5fZHJvcExpc3RSZWYpO1xuICAgICAgdmFsdWUuYWRkRHJhZyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfcm9vdENsYXNzOiBzdHJpbmc7XG4gIF9ob3N0Tm90Um9vdCA9IGZhbHNlO1xuICBuZ09uSW5pdCgpOiB2b2lkIHsgQ2RrTGF6eURyYWcucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7IH1cbiAgLy8gbmdBZnRlclZpZXdJbml0KCk6IHZvaWQgeyBDZGtMYXp5RHJhZy5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7IHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpOyB9XG4gIG5nT25EZXN0cm95KCk6IHZvaWQgeyBDZGtMYXp5RHJhZy5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTsgIHN1cGVyLm5nT25EZXN0cm95KCk7IH1cbiAgLyogQ2RrTGF6eURyYWcgZW5kICovXG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIENka0xhenlEcmFnLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcblxuICAgIHRoaXMuX2RyYWdSZWYuYmVmb3JlU3RhcnRlZC5zdWJzY3JpYmUoICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY2RrRHJvcExpc3QgfSA9IHRoaXM7XG4gICAgICBpZiAoY2RrRHJvcExpc3QgJiYgY2RrRHJvcExpc3QuY29sdW1uUmVvcmRlciAmJiB0aGlzLl9jb250ZXh0LmNvbC5yZW9yZGVyKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGFsbG93IGEgbmV3IGRyYWdnaW5nIHNlc3Npb24gYmVmb3JlIHRoZSBwcmV2aW91cyBlbmRzLlxuICAgICAgICAvLyB0aGlzIHNvdW5kIGltcG9zc2libGUsIGJ1dCBkdWUgdG8gYW5pbWF0aW9uIHRyYW5zaXRpb25zIGl0cyBhY3R1YWxseSBpcy5cbiAgICAgICAgLy8gaWYgdGhlIGB0cmFuc2l0aW9uZW5kYCBpcyBsb25nIGVub3VnaCwgYSBuZXcgZHJhZyBjYW4gc3RhcnQuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhlIGBkaXNhYmxlZGAgc3RhdGUgaXMgY2hlY2tlZCBieSBwb2ludGVyRG93biBBRlRFUiBjYWxsaW5nIGJlZm9yZSBzdGFydCBzbyB3ZSBjYW4gY2FuY2VsIHRoZSBzdGFydC4uLlxuICAgICAgICBpZiAoY2RrRHJvcExpc3QuX2Ryb3BMaXN0UmVmLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RhcnRlZC5zdWJzY3JpYmUoICgpID0+IHRoaXMuX2NvbnRleHQuY29sLmNvbHVtbkRlZi5pc0RyYWdnaW5nID0gdHJ1ZSApO1xuICAgIHRoaXMuZW5kZWQuc3Vic2NyaWJlKCAoKSA9PiB0aGlzLl9jb250ZXh0LmNvbC5jb2x1bW5EZWYuaXNEcmFnZ2luZyA9IGZhbHNlICk7XG4gIH1cblxuICBnZXRDZWxscygpOiBIVE1MRWxlbWVudFtdIHtcbiAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLl9jb250ZXh0LmNvbC5jb2x1bW5EZWYucXVlcnlDZWxsRWxlbWVudHMoJ3RhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGBgO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==