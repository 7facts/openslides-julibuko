/**
 * @fileoverview added by tsickle
 * Generated from: lib/grid/directives/cell.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __decorate, __metadata } from "tslib";
// tslint:disable:use-host-property-decorator
// tslint:disable:directive-selector
import { first, filter } from 'rxjs/operators';
import { Component, Directive, ElementRef, ChangeDetectionStrategy, ViewEncapsulation, ViewContainerRef, ViewChild, NgZone, Input, } from '@angular/core';
import { CdkHeaderCell, CdkCell, CdkFooterCell } from '@angular/cdk/table';
import { UnRx } from '@pebula/utils';
import { PblNgridComponent } from '../ngrid.component';
import { uniqueColumnCss, uniqueColumnTypeCss, COLUMN_EDITABLE_CELL_CLASS } from '../circular-dep-bridge';
import { isPblColumn, isPblColumnGroup } from '../columns';
import { MetaCellContext, PblRowContext } from '../context/index';
import { PblNgridColumnDef } from './column-def';
import { PblNgridDataHeaderExtensionContext, PblNgridMultiComponentRegistry, PblNgridMultiTemplateRegistry } from './registry.directives';
/** @type {?} */
const HEADER_GROUP_CSS = `pbl-header-group-cell`;
/** @type {?} */
const HEADER_GROUP_PLACE_HOLDER_CSS = `pbl-header-group-cell-placeholder`;
/**
 * @param {?} el
 * @param {?} column
 * @return {?}
 */
function initCellElement(el, column) {
    el.classList.add(uniqueColumnCss(column.columnDef));
    if (column.type) {
        el.classList.add(uniqueColumnTypeCss(column.type));
    }
    if (column.css) {
        /** @type {?} */
        const css = column.css.split(' ');
        for (const c of css) {
            el.classList.add(c);
        }
    }
}
/**
 * @param {?} el
 * @param {?} column
 * @return {?}
 */
function initDataCellElement(el, column) {
    if (column.editable && column.editorTpl) {
        el.classList.add(COLUMN_EDITABLE_CELL_CLASS);
    }
}
/** @type {?} */
const lastDataHeaderExtensions = new Map();
/**
 * @this {?}
 * @return {?}
 */
function applyWidth() {
    this.columnDef.applyWidth(this.el);
}
/**
 * @this {?}
 * @return {?}
 */
function applySourceWidth() {
    this.columnDef.applySourceWidth(this.el);
}
/**
 * Header cell component.
 * The header cell component will render the header cell template and add the proper classes and role.
 *
 * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.
 * These extensions add features to the cells either as a template instance or as a component instance.
 * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...
 * @template T
 */
let PblNgridHeaderCellComponent = /**
 * Header cell component.
 * The header cell component will render the header cell template and add the proper classes and role.
 *
 * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.
 * These extensions add features to the cells either as a template instance or as a component instance.
 * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...
 * @template T
 */
class PblNgridHeaderCellComponent extends CdkHeaderCell {
    /**
     * @param {?} columnDef
     * @param {?} grid
     * @param {?} elementRef
     * @param {?} zone
     */
    constructor(columnDef, grid, elementRef, zone) {
        super(columnDef, elementRef);
        this.columnDef = columnDef;
        this.grid = grid;
        this.elementRef = elementRef;
        this.zone = zone;
        this.table = grid;
        /** @type {?} */
        const column = columnDef.column;
        /** @type {?} */
        const el = this.el = elementRef.nativeElement;
        if (isPblColumnGroup(column)) {
            el.classList.add(HEADER_GROUP_CSS);
            if (column.placeholder) {
                el.classList.add(HEADER_GROUP_PLACE_HOLDER_CSS);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const col = this.columnDef.column;
        /** @type {?} */
        let predicate;
        /** @type {?} */
        let view;
        /** @type {?} */
        let widthUpdater;
        if (isPblColumn(col)) {
            /** @type {?} */
            const gridWidthRow = this.el.parentElement.hasAttribute('gridWidthRow');
            widthUpdater = gridWidthRow ? applySourceWidth : applyWidth;
            predicate = (/**
             * @param {?} event
             * @return {?}
             */
            event => (!gridWidthRow && event.reason !== 'update') || (gridWidthRow && event.reason !== 'resize'));
            view = !gridWidthRow ? this.initMainHeaderColumnView(col) : undefined;
        }
        else {
            widthUpdater = applySourceWidth;
            predicate = (/**
             * @param {?} event
             * @return {?}
             */
            event => event.reason !== 'resize');
            view = this.initMetaHeaderColumnView(col);
        }
        this.columnDef.widthChange
            .pipe(filter(predicate), UnRx(this))
            .subscribe(widthUpdater.bind(this));
        view && view.detectChanges();
        widthUpdater.call(this);
        initCellElement(this.el, col);
    }
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    initMainHeaderColumnView(col) {
        this.cellCtx = PblNgridDataHeaderExtensionContext.createDateHeaderCtx((/** @type {?} */ (this)), this.vcRef.injector);
        /** @type {?} */
        const context = (/** @type {?} */ (this.cellCtx));
        /** @type {?} */
        const view = this.vcRef.createEmbeddedView(col.headerCellTpl, context);
        this.zone.onStable
            .pipe(first())
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.runHeaderExtensions(context, (/** @type {?} */ (view)));
            /** @type {?} */
            const v = this.vcRef.get(0);
            // at this point the view might get destroyed, its possible...
            if (!v.destroyed) {
                v.detectChanges();
            }
        }));
        return view;
    }
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    initMetaHeaderColumnView(col) {
        this.cellCtx = MetaCellContext.create(col, this.grid);
        return this.vcRef.createEmbeddedView(col.template, this.cellCtx);
    }
    /**
     * @protected
     * @param {?} context
     * @param {?} view
     * @return {?}
     */
    runHeaderExtensions(context, view) {
        // we collect the first header extension for each unique name only once per grid instance
        /** @type {?} */
        let extensions = lastDataHeaderExtensions.get(this.grid);
        if (!extensions) {
            /** @type {?} */
            const dataHeaderExtensions = new Map();
            this.grid.registry.forMulti('dataHeaderExtensions', (/**
             * @param {?} values
             * @return {?}
             */
            values => {
                for (const value of values) {
                    if (!dataHeaderExtensions.has(value.name)) {
                        dataHeaderExtensions.set(value.name, value);
                    }
                }
            }));
            extensions = Array.from(dataHeaderExtensions.values());
            lastDataHeaderExtensions.set(this.grid, extensions);
            // destroy it on the next turn, we know all cells will render on the same turn.
            this.zone.onStable.pipe(first()).subscribe((/**
             * @return {?}
             */
            () => lastDataHeaderExtensions.delete(this.grid)));
        }
        let { rootNodes } = view;
        for (const ext of extensions) {
            if (!ext.shouldRender || ext.shouldRender(context)) {
                if (ext instanceof PblNgridMultiTemplateRegistry) {
                    /** @type {?} */
                    const extView = this.vcRef.createEmbeddedView(ext.tRef, context);
                    extView.markForCheck();
                }
                else if (ext instanceof PblNgridMultiComponentRegistry) {
                    rootNodes = this.createComponent(ext, context, rootNodes);
                }
            }
        }
    }
    /**
     * @protected
     * @param {?} ext
     * @param {?} context
     * @param {?} rootNodes
     * @return {?}
     */
    createComponent(ext, context, rootNodes) {
        /** @type {?} */
        const factory = ext.getFactory(context);
        /** @type {?} */
        const projectedContent = [];
        if (ext.projectContent) {
            projectedContent.push(rootNodes);
        }
        /** @type {?} */
        const cmpRef = this.vcRef.createComponent(factory, this.vcRef.length, null, projectedContent);
        if (ext.projectContent) {
            rootNodes = [cmpRef.location.nativeElement];
        }
        if (ext.onCreated) {
            ext.onCreated(context, cmpRef);
        }
        return rootNodes;
    }
};
PblNgridHeaderCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'pbl-ngrid-header-cell',
                host: {
                    class: 'pbl-ngrid-header-cell',
                    role: 'columnheader',
                },
                exportAs: 'ngridHeaderCell',
                template: `<ng-container #vcRef></ng-container>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
PblNgridHeaderCellComponent.ctorParameters = () => [
    { type: PblNgridColumnDef },
    { type: PblNgridComponent },
    { type: ElementRef },
    { type: NgZone }
];
PblNgridHeaderCellComponent.propDecorators = {
    vcRef: [{ type: ViewChild, args: ['vcRef', { read: ViewContainerRef, static: true },] }]
};
/**
 * Header cell component.
 * The header cell component will render the header cell template and add the proper classes and role.
 *
 * It is also responsible for creating and managing the any `dataHeaderExtensions` registered in the registry.
 * These extensions add features to the cells either as a template instance or as a component instance.
 * Examples: Sorting behavior, drag&drop/resize handlers, menus etc...
 * @template T
 */
PblNgridHeaderCellComponent = __decorate([
    UnRx(),
    __metadata("design:paramtypes", [PblNgridColumnDef,
        PblNgridComponent,
        ElementRef,
        NgZone])
], PblNgridHeaderCellComponent);
export { PblNgridHeaderCellComponent };
if (false) {
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.vcRef;
    /**
     * @type {?}
     * @private
     */
    PblNgridHeaderCellComponent.prototype.el;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.cellCtx;
    /**
     * @deprecated use grid instead
     * @type {?}
     */
    PblNgridHeaderCellComponent.prototype.table;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.columnDef;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.grid;
    /** @type {?} */
    PblNgridHeaderCellComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    PblNgridHeaderCellComponent.prototype.zone;
}
/**
 * Cell template container that adds the right classes and role.
 */
let PblNgridCellDirective = /**
 * Cell template container that adds the right classes and role.
 */
class PblNgridCellDirective extends CdkCell {
    /**
     * @param {?} colDef
     * @param {?} elementRef
     */
    constructor(colDef, elementRef) {
        super(colDef, elementRef);
        this.colDef = colDef;
        this.focused = false;
        this.selected = false;
        this.colIndex = this.colDef.grid.columnApi.indexOf((/** @type {?} */ (colDef.column)));
        this.el = elementRef.nativeElement;
        colDef.applyWidth(this.el);
        initCellElement(this.el, colDef.column);
        initDataCellElement(this.el, colDef.column);
        /*  Apply width changes to this data cell
            We don't update "update" events because they are followed by a resize event which will update the absolute value (px) */
        colDef.widthChange
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.reason !== 'update')), UnRx(this))
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => this.colDef.applyWidth(this.el)));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rowCtx(value) {
        if (value !== this._rowCtx) {
            this._rowCtx = value;
            this.ngDoCheck();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._rowCtx) {
            /** @type {?} */
            const cellContext = this.cellCtx = this._rowCtx.cell(this.colIndex);
            if (cellContext.focused !== this.focused) {
                if (this.focused = cellContext.focused) {
                    this.el.classList.add('pbl-ngrid-cell-focused');
                }
                else {
                    this.el.classList.remove('pbl-ngrid-cell-focused');
                }
            }
            if (this.cellCtx.selected !== this.selected) {
                if (this.selected = cellContext.selected) {
                    this.el.classList.add('pbl-ngrid-cell-selected');
                }
                else {
                    this.el.classList.remove('pbl-ngrid-cell-selected');
                }
            }
        }
    }
};
PblNgridCellDirective.decorators = [
    { type: Directive, args: [{
                selector: 'pbl-ngrid-cell',
                host: {
                    'class': 'pbl-ngrid-cell',
                    'role': 'gridcell',
                },
                exportAs: 'pblNgridCell',
            },] }
];
/** @nocollapse */
PblNgridCellDirective.ctorParameters = () => [
    { type: PblNgridColumnDef },
    { type: ElementRef }
];
PblNgridCellDirective.propDecorators = {
    rowCtx: [{ type: Input }]
};
/**
 * Cell template container that adds the right classes and role.
 */
PblNgridCellDirective = __decorate([
    UnRx(),
    __metadata("design:paramtypes", [PblNgridColumnDef, ElementRef])
], PblNgridCellDirective);
export { PblNgridCellDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype._rowCtx;
    /** @type {?} */
    PblNgridCellDirective.prototype.cellCtx;
    /**
     * The position of the column def among all columns regardless of visibility.
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.colIndex;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.focused;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.selected;
    /**
     * @type {?}
     * @private
     */
    PblNgridCellDirective.prototype.colDef;
}
let PblNgridFooterCellDirective = class PblNgridFooterCellDirective extends CdkFooterCell {
    /**
     * @param {?} columnDef
     * @param {?} grid
     * @param {?} elementRef
     */
    constructor(columnDef, grid, elementRef) {
        super(columnDef, elementRef);
        this.columnDef = columnDef;
        this.grid = grid;
        this.table = grid;
        this.el = elementRef.nativeElement;
        /** @type {?} */
        const column = columnDef.column;
        applyWidth.call(this);
        initCellElement(this.el, column);
        columnDef.widthChange
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.reason !== 'update')), UnRx(this))
            .subscribe(applyWidth.bind(this));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.cellCtx = MetaCellContext.create(this.columnDef.column, this.grid);
    }
};
PblNgridFooterCellDirective.decorators = [
    { type: Directive, args: [{
                selector: 'pbl-ngrid-footer-cell',
                host: {
                    'class': 'pbl-ngrid-footer-cell',
                    'role': 'gridcell',
                },
                exportAs: 'ngridFooterCell',
            },] }
];
/** @nocollapse */
PblNgridFooterCellDirective.ctorParameters = () => [
    { type: PblNgridColumnDef },
    { type: PblNgridComponent },
    { type: ElementRef }
];
PblNgridFooterCellDirective = __decorate([
    UnRx(),
    __metadata("design:paramtypes", [PblNgridColumnDef,
        PblNgridComponent,
        ElementRef])
], PblNgridFooterCellDirective);
export { PblNgridFooterCellDirective };
if (false) {
    /** @type {?} */
    PblNgridFooterCellDirective.prototype.cellCtx;
    /**
     * @deprecated use grid instead
     * @type {?}
     */
    PblNgridFooterCellDirective.prototype.table;
    /**
     * @type {?}
     * @private
     */
    PblNgridFooterCellDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    PblNgridFooterCellDirective.prototype.columnDef;
    /** @type {?} */
    PblNgridFooterCellDirective.prototype.grid;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BwZWJ1bGEvbmdyaWQvIiwic291cmNlcyI6WyJsaWIvZ3JpZC9kaXJlY3RpdmVzL2NlbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9DLE9BQU8sRUFFTCxTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFFVix1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQixTQUFTLEVBQ1QsTUFBTSxFQUVOLEtBQUssR0FDTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXJDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxlQUFlLEVBQUUsbUJBQW1CLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRyxPQUFPLEVBQW9ELFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUM3RyxPQUFPLEVBQUUsZUFBZSxFQUEyQixhQUFhLEVBQWtCLE1BQU0sa0JBQWtCLENBQUM7QUFFM0csT0FBTyxFQUFFLGlCQUFpQixFQUFvQixNQUFNLGNBQWMsQ0FBQztBQUNuRSxPQUFPLEVBQUUsa0NBQWtDLEVBQUUsOEJBQThCLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7TUFFcEksZ0JBQWdCLEdBQUcsdUJBQXVCOztNQUMxQyw2QkFBNkIsR0FBRyxtQ0FBbUM7Ozs7OztBQUV6RSxTQUFTLGVBQWUsQ0FBQyxFQUFlLEVBQUUsTUFBYztJQUN0RCxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsTUFB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QVEsRUFBRSx1QkFBdUI7Z0JBQ2pDLElBQUksRUFBRTtvQkFDSixPQUFPLEVBQUUsdUJBQXVCO29CQUNoQyxNQUFNLEVBQUUsVUFBVTtpQkFDbkI7Z0JBQ0QsUUFBUSxFQUFFLGlCQUFpQjthQUMzQjs7OztZQTFRTyxpQkFBaUI7WUFMakIsaUJBQWlCO1lBYnhCLFVBQVU7O0FBOFJDLDJCQUEyQjtJQUR0QyxJQUFJLEVBQUU7cUNBT3lCLGlCQUFpQjtRQUN2QixpQkFBaUI7UUFDbEIsVUFBVTtHQVJ2QiwyQkFBMkIsQ0EyQnZDO1NBM0JZLDJCQUEyQjs7O0lBQ3RDLDhDQUF5Qjs7Ozs7SUFFekIsNENBQWtDOzs7OztJQUVsQyx5Q0FBd0I7Ozs7O0lBQ1osZ0RBQW9FOztJQUNwRSwyQ0FBOEIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTp1c2UtaG9zdC1wcm9wZXJ0eS1kZWNvcmF0b3Jcbi8vIHRzbGludDpkaXNhYmxlOmRpcmVjdGl2ZS1zZWxlY3RvclxuaW1wb3J0IHsgZmlyc3QsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIE9uSW5pdCxcbiAgQ29tcG9uZW50LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIERvQ2hlY2ssXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgVmlld0NoaWxkLFxuICBOZ1pvbmUsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgSW5wdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrSGVhZGVyQ2VsbCwgQ2RrQ2VsbCwgQ2RrRm9vdGVyQ2VsbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90YWJsZSc7XG5pbXBvcnQgeyBVblJ4IH0gZnJvbSAnQHBlYnVsYS91dGlscyc7XG5cbmltcG9ydCB7IFBibE5ncmlkQ29tcG9uZW50IH0gZnJvbSAnLi4vbmdyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IHVuaXF1ZUNvbHVtbkNzcywgdW5pcXVlQ29sdW1uVHlwZUNzcywgQ09MVU1OX0VESVRBQkxFX0NFTExfQ0xBU1MgfSBmcm9tICcuLi9jaXJjdWxhci1kZXAtYnJpZGdlJztcbmltcG9ydCB7IENPTFVNTiwgUGJsTWV0YUNvbHVtbiwgUGJsQ29sdW1uLCBQYmxDb2x1bW5Hcm91cCwgaXNQYmxDb2x1bW4sIGlzUGJsQ29sdW1uR3JvdXAgfSBmcm9tICcuLi9jb2x1bW5zJztcbmltcG9ydCB7IE1ldGFDZWxsQ29udGV4dCwgUGJsTmdyaWRNZXRhQ2VsbENvbnRleHQsIFBibFJvd0NvbnRleHQsIFBibENlbGxDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9pbmRleCc7XG5pbXBvcnQgeyBQYmxOZ3JpZE11bHRpUmVnaXN0cnlNYXAgfSBmcm9tICcuLi9zZXJ2aWNlcy9ncmlkLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHsgUGJsTmdyaWRDb2x1bW5EZWYsIFdpZHRoQ2hhbmdlRXZlbnQgfSBmcm9tICcuL2NvbHVtbi1kZWYnO1xuaW1wb3J0IHsgUGJsTmdyaWREYXRhSGVhZGVyRXh0ZW5zaW9uQ29udGV4dCwgUGJsTmdyaWRNdWx0aUNvbXBvbmVudFJlZ2lzdHJ5LCBQYmxOZ3JpZE11bHRpVGVtcGxhdGVSZWdpc3RyeSB9IGZyb20gJy4vcmVnaXN0cnkuZGlyZWN0aXZlcyc7XG5cbmNvbnN0IEhFQURFUl9HUk9VUF9DU1MgPSBgcGJsLWhlYWRlci1ncm91cC1jZWxsYDtcbmNvbnN0IEhFQURFUl9HUk9VUF9QTEFDRV9IT0xERVJfQ1NTID0gYHBibC1oZWFkZXItZ3JvdXAtY2VsbC1wbGFjZWhvbGRlcmA7XG5cbmZ1bmN0aW9uIGluaXRDZWxsRWxlbWVudChlbDogSFRNTEVsZW1lbnQsIGNvbHVtbjogQ09MVU1OKTogdm9pZCB7XG4gIGVsLmNsYXNzTGlzdC5hZGQodW5pcXVlQ29sdW1uQ3NzKGNvbHVtbi5jb2x1bW5EZWYpKTtcbiAgaWYgKGNvbHVtbi50eXBlKSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCh1bmlxdWVDb2x1bW5UeXBlQ3NzKGNvbHVtbi50eXBlKSk7XG4gIH1cbiAgaWYgKGNvbHVtbi5jc3MpIHtcbiAgICBjb25zdCBjc3MgPSBjb2x1bW4uY3NzLnNwbGl0KCcgJyk7XG4gICAgZm9yIChjb25zdCBjIG9mIGNzcykge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdERhdGFDZWxsRWxlbWVudChlbDogSFRNTEVsZW1lbnQsIGNvbHVtbjogUGJsQ29sdW1uKTogdm9pZCB7XG4gIGlmIChjb2x1bW4uZWRpdGFibGUgJiYgY29sdW1uLmVkaXRvclRwbCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoQ09MVU1OX0VESVRBQkxFX0NFTExfQ0xBU1MpO1xuICB9XG59XG5cbmNvbnN0IGxhc3REYXRhSGVhZGVyRXh0ZW5zaW9ucyA9IG5ldyBNYXA8UGJsTmdyaWRDb21wb25lbnQ8YW55PiwgUGJsTmdyaWRNdWx0aVJlZ2lzdHJ5TWFwWydkYXRhSGVhZGVyRXh0ZW5zaW9ucyddW10+KCk7XG5cbmZ1bmN0aW9uIGFwcGx5V2lkdGgodGhpczogeyBjb2x1bW5EZWY6IFBibE5ncmlkQ29sdW1uRGVmOyBlbDogSFRNTEVsZW1lbnQgfSkge1xuICB0aGlzLmNvbHVtbkRlZi5hcHBseVdpZHRoKHRoaXMuZWwpO1xufVxuXG5mdW5jdGlvbiBhcHBseVNvdXJjZVdpZHRoKHRoaXM6IHsgY29sdW1uRGVmOiBQYmxOZ3JpZENvbHVtbkRlZjsgZWw6IEhUTUxFbGVtZW50IH0pIHtcbiAgdGhpcy5jb2x1bW5EZWYuYXBwbHlTb3VyY2VXaWR0aCh0aGlzLmVsKTtcbn1cblxuLyoqXG4gKiBIZWFkZXIgY2VsbCBjb21wb25lbnQuXG4gKiBUaGUgaGVhZGVyIGNlbGwgY29tcG9uZW50IHdpbGwgcmVuZGVyIHRoZSBoZWFkZXIgY2VsbCB0ZW1wbGF0ZSBhbmQgYWRkIHRoZSBwcm9wZXIgY2xhc3NlcyBhbmQgcm9sZS5cbiAqXG4gKiBJdCBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgbWFuYWdpbmcgdGhlIGFueSBgZGF0YUhlYWRlckV4dGVuc2lvbnNgIHJlZ2lzdGVyZWQgaW4gdGhlIHJlZ2lzdHJ5LlxuICogVGhlc2UgZXh0ZW5zaW9ucyBhZGQgZmVhdHVyZXMgdG8gdGhlIGNlbGxzIGVpdGhlciBhcyBhIHRlbXBsYXRlIGluc3RhbmNlIG9yIGFzIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICogRXhhbXBsZXM6IFNvcnRpbmcgYmVoYXZpb3IsIGRyYWcmZHJvcC9yZXNpemUgaGFuZGxlcnMsIG1lbnVzIGV0Yy4uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdwYmwtbmdyaWQtaGVhZGVyLWNlbGwnLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdwYmwtbmdyaWQtaGVhZGVyLWNlbGwnLFxuICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInLFxuICB9LFxuICBleHBvcnRBczogJ25ncmlkSGVhZGVyQ2VsbCcsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAjdmNSZWY+PC9uZy1jb250YWluZXI+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuQFVuUngoKVxuZXhwb3J0IGNsYXNzIFBibE5ncmlkSGVhZGVyQ2VsbENvbXBvbmVudDxUIGV4dGVuZHMgQ09MVU1OID0gQ09MVU1OPiBleHRlbmRzIENka0hlYWRlckNlbGwgaW1wbGVtZW50cyBPbkluaXQge1xuICBAVmlld0NoaWxkKCd2Y1JlZicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0pIHZjUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIHByaXZhdGUgZWw6IEhUTUxFbGVtZW50O1xuXG4gIGNlbGxDdHg6IFBibE5ncmlkRGF0YUhlYWRlckV4dGVuc2lvbkNvbnRleHQgfCBNZXRhQ2VsbENvbnRleHQ7XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBncmlkIGluc3RlYWQgKi9cbiAgcmVhZG9ubHkgdGFibGU6IFBibE5ncmlkQ29tcG9uZW50PFQ+O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBjb2x1bW5EZWY6IFBibE5ncmlkQ29sdW1uRGVmPFQ+LFxuICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZ3JpZDogUGJsTmdyaWRDb21wb25lbnQ8YW55PixcbiAgICAgICAgICAgICAgcHVibGljIHJlYWRvbmx5IGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgem9uZTogTmdab25lKSB7XG4gICAgc3VwZXIoY29sdW1uRGVmLCBlbGVtZW50UmVmKTtcbiAgICB0aGlzLnRhYmxlID0gZ3JpZDtcblxuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbkRlZi5jb2x1bW47XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuXG4gICAgaWYgKGlzUGJsQ29sdW1uR3JvdXAoY29sdW1uKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChIRUFERVJfR1JPVVBfQ1NTKTtcbiAgICAgIGlmIChjb2x1bW4ucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChIRUFERVJfR1JPVVBfUExBQ0VfSE9MREVSX0NTUyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgY29uc3QgY29sOiBDT0xVTU4gPSB0aGlzLmNvbHVtbkRlZi5jb2x1bW47XG4gICAgbGV0IHByZWRpY2F0ZTogKGV2ZW50OiBXaWR0aENoYW5nZUV2ZW50KSA9PiBib29sZWFuO1xuICAgIGxldCB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8UGJsTmdyaWRNZXRhQ2VsbENvbnRleHQ8YW55LCBQYmxNZXRhQ29sdW1uIHwgUGJsQ29sdW1uPj5cbiAgICBsZXQgd2lkdGhVcGRhdGVyOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG5cbiAgICBpZiAoaXNQYmxDb2x1bW4oY29sKSkge1xuICAgICAgY29uc3QgZ3JpZFdpZHRoUm93ID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZ3JpZFdpZHRoUm93Jyk7XG4gICAgICB3aWR0aFVwZGF0ZXIgPSBncmlkV2lkdGhSb3cgPyBhcHBseVNvdXJjZVdpZHRoIDogYXBwbHlXaWR0aDtcbiAgICAgIHByZWRpY2F0ZSA9IGV2ZW50ID0+ICghZ3JpZFdpZHRoUm93ICYmIGV2ZW50LnJlYXNvbiAhPT0gJ3VwZGF0ZScpIHx8IChncmlkV2lkdGhSb3cgJiYgZXZlbnQucmVhc29uICE9PSAncmVzaXplJyk7XG4gICAgICB2aWV3ID0gIWdyaWRXaWR0aFJvdyA/IHRoaXMuaW5pdE1haW5IZWFkZXJDb2x1bW5WaWV3KGNvbCkgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoVXBkYXRlciA9IGFwcGx5U291cmNlV2lkdGg7XG4gICAgICBwcmVkaWNhdGUgPSBldmVudCA9PiBldmVudC5yZWFzb24gIT09ICdyZXNpemUnO1xuICAgICAgdmlldyA9IHRoaXMuaW5pdE1ldGFIZWFkZXJDb2x1bW5WaWV3KGNvbCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2x1bW5EZWYud2lkdGhDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcihwcmVkaWNhdGUpLCBVblJ4KHRoaXMpKVxuICAgICAgLnN1YnNjcmliZSh3aWR0aFVwZGF0ZXIuYmluZCh0aGlzKSk7XG5cbiAgICB2aWV3ICYmIHZpZXcuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIHdpZHRoVXBkYXRlci5jYWxsKHRoaXMpO1xuICAgIGluaXRDZWxsRWxlbWVudCh0aGlzLmVsLCBjb2wpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluaXRNYWluSGVhZGVyQ29sdW1uVmlldyhjb2w6IFBibENvbHVtbikge1xuICAgIHRoaXMuY2VsbEN0eCA9IFBibE5ncmlkRGF0YUhlYWRlckV4dGVuc2lvbkNvbnRleHQuY3JlYXRlRGF0ZUhlYWRlckN0eCh0aGlzIGFzIFBibE5ncmlkSGVhZGVyQ2VsbENvbXBvbmVudDxQYmxDb2x1bW4+LCB0aGlzLnZjUmVmLmluamVjdG9yKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jZWxsQ3R4IGFzIFBibE5ncmlkRGF0YUhlYWRlckV4dGVuc2lvbkNvbnRleHQ7XG4gICAgY29uc3QgdmlldyA9IHRoaXMudmNSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbC5oZWFkZXJDZWxsVHBsLCBjb250ZXh0KTtcbiAgICB0aGlzLnpvbmUub25TdGFibGVcbiAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAuc3Vic2NyaWJlKCAoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSGVhZGVyRXh0ZW5zaW9ucyhjb250ZXh0LCB2aWV3IGFzIEVtYmVkZGVkVmlld1JlZjxQYmxOZ3JpZE1ldGFDZWxsQ29udGV4dDxhbnksIFBibENvbHVtbj4+KTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMudmNSZWYuZ2V0KDApO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSB2aWV3IG1pZ2h0IGdldCBkZXN0cm95ZWQsIGl0cyBwb3NzaWJsZS4uLlxuICAgICAgICBpZiAoIXYuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiB2aWV3O1xuICB9XG5cbiAgcHJvdGVjdGVkIGluaXRNZXRhSGVhZGVyQ29sdW1uVmlldyhjb2w6IFBibE1ldGFDb2x1bW4gfCBQYmxDb2x1bW5Hcm91cCkge1xuICAgIHRoaXMuY2VsbEN0eCA9IE1ldGFDZWxsQ29udGV4dC5jcmVhdGUoY29sLCB0aGlzLmdyaWQpO1xuICAgIHJldHVybiB0aGlzLnZjUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhjb2wudGVtcGxhdGUsIHRoaXMuY2VsbEN0eCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcnVuSGVhZGVyRXh0ZW5zaW9ucyhjb250ZXh0OiBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LCB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8UGJsTmdyaWRNZXRhQ2VsbENvbnRleHQ8YW55LCBQYmxDb2x1bW4+Pik6IHZvaWQge1xuICAgIC8vIHdlIGNvbGxlY3QgdGhlIGZpcnN0IGhlYWRlciBleHRlbnNpb24gZm9yIGVhY2ggdW5pcXVlIG5hbWUgb25seSBvbmNlIHBlciBncmlkIGluc3RhbmNlXG4gICAgbGV0IGV4dGVuc2lvbnMgPSBsYXN0RGF0YUhlYWRlckV4dGVuc2lvbnMuZ2V0KHRoaXMuZ3JpZCk7XG4gICAgaWYgKCFleHRlbnNpb25zKSB7XG4gICAgICBjb25zdCBkYXRhSGVhZGVyRXh0ZW5zaW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbiAgICAgIHRoaXMuZ3JpZC5yZWdpc3RyeS5mb3JNdWx0aSgnZGF0YUhlYWRlckV4dGVuc2lvbnMnLCB2YWx1ZXMgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmICghZGF0YUhlYWRlckV4dGVuc2lvbnMuaGFzKHZhbHVlLm5hbWUpKSB7XG4gICAgICAgICAgICBkYXRhSGVhZGVyRXh0ZW5zaW9ucy5zZXQodmFsdWUubmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4dGVuc2lvbnMgPSBBcnJheS5mcm9tKGRhdGFIZWFkZXJFeHRlbnNpb25zLnZhbHVlcygpKTtcbiAgICAgIGxhc3REYXRhSGVhZGVyRXh0ZW5zaW9ucy5zZXQodGhpcy5ncmlkLCBleHRlbnNpb25zKTtcbiAgICAgIC8vIGRlc3Ryb3kgaXQgb24gdGhlIG5leHQgdHVybiwgd2Uga25vdyBhbGwgY2VsbHMgd2lsbCByZW5kZXIgb24gdGhlIHNhbWUgdHVybi5cbiAgICAgIHRoaXMuem9uZS5vblN0YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSggKCkgPT4gbGFzdERhdGFIZWFkZXJFeHRlbnNpb25zLmRlbGV0ZSh0aGlzLmdyaWQpICk7XG4gICAgfVxuXG4gICAgbGV0IHsgcm9vdE5vZGVzIH0gPSB2aWV3O1xuXG4gICAgZm9yIChjb25zdCBleHQgb2YgZXh0ZW5zaW9ucykge1xuICAgICAgaWYgKCFleHQuc2hvdWxkUmVuZGVyIHx8IGV4dC5zaG91bGRSZW5kZXIoY29udGV4dCkpIHtcbiAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFBibE5ncmlkTXVsdGlUZW1wbGF0ZVJlZ2lzdHJ5KSB7XG4gICAgICAgICAgY29uc3QgZXh0VmlldyA9IHRoaXMudmNSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGV4dC50UmVmLCBjb250ZXh0KTtcbiAgICAgICAgICBleHRWaWV3Lm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFBibE5ncmlkTXVsdGlDb21wb25lbnRSZWdpc3RyeSkge1xuICAgICAgICAgIHJvb3ROb2RlcyA9IHRoaXMuY3JlYXRlQ29tcG9uZW50KGV4dCwgY29udGV4dCwgcm9vdE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBjcmVhdGVDb21wb25lbnQoZXh0OiBQYmxOZ3JpZE11bHRpQ29tcG9uZW50UmVnaXN0cnk8YW55LCBcImRhdGFIZWFkZXJFeHRlbnNpb25zXCI+LCBjb250ZXh0OiBQYmxOZ3JpZERhdGFIZWFkZXJFeHRlbnNpb25Db250ZXh0LCByb290Tm9kZXM6IGFueVtdKTogYW55W10ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBleHQuZ2V0RmFjdG9yeShjb250ZXh0KTtcbiAgICBjb25zdCBwcm9qZWN0ZWRDb250ZW50OiBhbnlbXVtdID0gW107XG5cbiAgICBpZiAoZXh0LnByb2plY3RDb250ZW50KSB7XG4gICAgICBwcm9qZWN0ZWRDb250ZW50LnB1c2gocm9vdE5vZGVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbXBSZWYgPSB0aGlzLnZjUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5LCB0aGlzLnZjUmVmLmxlbmd0aCwgbnVsbCwgcHJvamVjdGVkQ29udGVudCk7XG5cbiAgICBpZiAoZXh0LnByb2plY3RDb250ZW50KSB7XG4gICAgICByb290Tm9kZXMgPSBbIGNtcFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50IF07XG4gICAgfVxuXG4gICAgaWYgKGV4dC5vbkNyZWF0ZWQpIHtcbiAgICAgIGV4dC5vbkNyZWF0ZWQoY29udGV4dCwgY21wUmVmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdE5vZGVzO1xuICB9XG59XG5cbi8qKiBDZWxsIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGFkZHMgdGhlIHJpZ2h0IGNsYXNzZXMgYW5kIHJvbGUuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdwYmwtbmdyaWQtY2VsbCcsXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAncGJsLW5ncmlkLWNlbGwnLFxuICAgICdyb2xlJzogJ2dyaWRjZWxsJyxcbiAgfSxcbiAgZXhwb3J0QXM6ICdwYmxOZ3JpZENlbGwnLFxufSlcbkBVblJ4KClcbmV4cG9ydCBjbGFzcyBQYmxOZ3JpZENlbGxEaXJlY3RpdmUgZXh0ZW5kcyBDZGtDZWxsIGltcGxlbWVudHMgRG9DaGVjayB7XG5cbiAgQElucHV0KCkgc2V0IHJvd0N0eCh2YWx1ZTogUGJsUm93Q29udGV4dDxhbnk+KSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yb3dDdHgpIHtcbiAgICAgIHRoaXMuX3Jvd0N0eCA9IHZhbHVlO1xuICAgICAgdGhpcy5uZ0RvQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9yb3dDdHg6IFBibFJvd0NvbnRleHQ8YW55PjtcbiAgY2VsbEN0eDogUGJsQ2VsbENvbnRleHQgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uIGRlZiBhbW9uZyBhbGwgY29sdW1ucyByZWdhcmRsZXNzIG9mIHZpc2liaWxpdHkuXG4gICAqL1xuICBwcml2YXRlIGNvbEluZGV4OiBudW1iZXI7XG4gIHByaXZhdGUgZWw6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIGZvY3VzZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29sRGVmOiBQYmxOZ3JpZENvbHVtbkRlZjxQYmxDb2x1bW4+LCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgc3VwZXIoY29sRGVmLCBlbGVtZW50UmVmKTtcbiAgICB0aGlzLmNvbEluZGV4ID0gdGhpcy5jb2xEZWYuZ3JpZC5jb2x1bW5BcGkuaW5kZXhPZihjb2xEZWYuY29sdW1uIGFzIFBibENvbHVtbik7XG4gICAgdGhpcy5lbCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb2xEZWYuYXBwbHlXaWR0aCh0aGlzLmVsKTtcbiAgICBpbml0Q2VsbEVsZW1lbnQodGhpcy5lbCwgY29sRGVmLmNvbHVtbik7XG4gICAgaW5pdERhdGFDZWxsRWxlbWVudCh0aGlzLmVsLCBjb2xEZWYuY29sdW1uKTtcblxuXG4gICAgLyogIEFwcGx5IHdpZHRoIGNoYW5nZXMgdG8gdGhpcyBkYXRhIGNlbGxcbiAgICAgICAgV2UgZG9uJ3QgdXBkYXRlIFwidXBkYXRlXCIgZXZlbnRzIGJlY2F1c2UgdGhleSBhcmUgZm9sbG93ZWQgYnkgYSByZXNpemUgZXZlbnQgd2hpY2ggd2lsbCB1cGRhdGUgdGhlIGFic29sdXRlIHZhbHVlIChweCkgKi9cbiAgICBjb2xEZWYud2lkdGhDaGFuZ2VcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoIGV2ZW50ID0+IGV2ZW50LnJlYXNvbiAhPT0gJ3VwZGF0ZScpLFxuICAgICAgICBVblJ4KHRoaXMpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShldmVudCA9PiB0aGlzLmNvbERlZi5hcHBseVdpZHRoKHRoaXMuZWwpKTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcm93Q3R4KSB7XG4gICAgICBjb25zdCBjZWxsQ29udGV4dCA9IHRoaXMuY2VsbEN0eCA9IHRoaXMuX3Jvd0N0eC5jZWxsKHRoaXMuY29sSW5kZXgpO1xuXG4gICAgICBpZiAoY2VsbENvbnRleHQuZm9jdXNlZCAhPT0gdGhpcy5mb2N1c2VkKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZCA9IGNlbGxDb250ZXh0LmZvY3VzZWQpIHtcbiAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3BibC1uZ3JpZC1jZWxsLWZvY3VzZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3BibC1uZ3JpZC1jZWxsLWZvY3VzZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2VsbEN0eC5zZWxlY3RlZCAhPT0gdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCA9IGNlbGxDb250ZXh0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdwYmwtbmdyaWQtY2VsbC1zZWxlY3RlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgncGJsLW5ncmlkLWNlbGwtc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdwYmwtbmdyaWQtZm9vdGVyLWNlbGwnLFxuICBob3N0OiB7XG4gICAgJ2NsYXNzJzogJ3BibC1uZ3JpZC1mb290ZXItY2VsbCcsXG4gICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICB9LFxuICBleHBvcnRBczogJ25ncmlkRm9vdGVyQ2VsbCcsXG4gfSlcbiBAVW5SeCgpXG5leHBvcnQgY2xhc3MgUGJsTmdyaWRGb290ZXJDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrRm9vdGVyQ2VsbCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGNlbGxDdHg6IE1ldGFDZWxsQ29udGV4dDtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBncmlkIGluc3RlYWQgKi9cbiAgcmVhZG9ubHkgdGFibGU6IFBibE5ncmlkQ29tcG9uZW50O1xuXG4gIHByaXZhdGUgZWw6IEhUTUxFbGVtZW50O1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbHVtbkRlZjogUGJsTmdyaWRDb2x1bW5EZWY8UGJsTWV0YUNvbHVtbiB8IFBibENvbHVtbkdyb3VwPixcbiAgICAgICAgICAgICAgcHVibGljIGdyaWQ6IFBibE5ncmlkQ29tcG9uZW50LFxuICAgICAgICAgICAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgc3VwZXIoY29sdW1uRGVmLCBlbGVtZW50UmVmKTtcbiAgICB0aGlzLnRhYmxlID0gZ3JpZDtcbiAgICB0aGlzLmVsID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbkRlZi5jb2x1bW47XG4gICAgYXBwbHlXaWR0aC5jYWxsKHRoaXMpO1xuICAgIGluaXRDZWxsRWxlbWVudCh0aGlzLmVsLCBjb2x1bW4pO1xuXG4gICAgY29sdW1uRGVmLndpZHRoQ2hhbmdlXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKCBldmVudCA9PiBldmVudC5yZWFzb24gIT09ICd1cGRhdGUnKSxcbiAgICAgICAgVW5SeCh0aGlzKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoYXBwbHlXaWR0aC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuY2VsbEN0eCA9IE1ldGFDZWxsQ29udGV4dC5jcmVhdGUodGhpcy5jb2x1bW5EZWYuY29sdW1uLCB0aGlzLmdyaWQpO1xuICB9XG59XG4iXX0=