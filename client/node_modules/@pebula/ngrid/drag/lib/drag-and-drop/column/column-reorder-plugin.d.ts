import { BehaviorSubject } from 'rxjs';
import { AfterViewInit, ChangeDetectorRef, ElementRef, OnDestroy, OnInit, ViewContainerRef, NgZone, QueryList } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { DragDrop, CdkDrag, CdkDropListGroup, CdkDropList, DragRefConfig } from '@angular/cdk/drag-drop';
import { PblNgridComponent, PblColumn, PblNgridPluginController, PblNgridCellContext } from '@pebula/ngrid';
import { CdkLazyDropList, CdkLazyDrag } from '../core/lazy-drag-drop';
import { PblDropListRef } from '../core/drop-list-ref';
import { PblDragRef } from '../core/drag-ref';
import * as ɵngcc0 from '@angular/core';
declare module '@pebula/ngrid/lib/ext/types' {
    interface PblNgridPluginExtension {
        columnReorder?: PblNgridColumnReorderPluginDirective;
    }
}
export declare const PLUGIN_KEY: 'columnReorder';
export declare class PblNgridColumnReorderPluginDirective<T = any> extends CdkDropList<T> implements OnInit, OnDestroy, CdkLazyDropList<T, PblNgridColumnReorderPluginDirective<T>> {
    table: PblNgridComponent<T>;
    id: string;
    orientation: 'horizontal' | 'vertical';
    get columnReorder(): boolean;
    set columnReorder(value: boolean);
    /**
     * When true, will not move the column on drop.
     * Instead you need to handle the dropped event.
     */
    get manualOverride(): boolean;
    set manualOverride(value: boolean);
    dragging: BehaviorSubject<boolean>;
    _draggables: QueryList<CdkDrag>;
    private _columnReorder;
    private _manualOverride;
    private _removePlugin;
    private lastSwap;
    private lastSorted;
    private get pblGetItemIndexFromPointerPosition();
    private get pblGetPositionCacheItems();
    constructor(table: PblNgridComponent<T>, pluginCtrl: PblNgridPluginController, element: ElementRef<HTMLElement>, dragDrop: DragDrop, changeDetectorRef: ChangeDetectorRef, dir?: Directionality, group?: CdkDropListGroup<CdkDropList>);
    /**
     * Selector that will be used to determine the direct container element, starting from
     * the `cdkDropList` element and going down the DOM. Passing an alternate direct container element
     * is useful when the `cdkDropList` is not the direct parent (i.e. ancestor but not father)
     * of the draggable elements.
     */
    directContainerElement: string;
    get pblDropListRef(): PblDropListRef<PblNgridColumnReorderPluginDirective<T>>;
    originalElement: ElementRef<HTMLElement>;
    _draggablesSet: Set<CdkDrag<any>>;
    addDrag(drag: CdkDrag): void;
    removeDrag(drag: CdkDrag): boolean;
    ngOnInit(): void;
    ngOnDestroy(): void;
    beforeStarted(): void;
    private _pblReset;
    private monkeyPatchDropListRef;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridColumnReorderPluginDirective<any>, [null, null, null, null, null, { optional: true; }, { optional: true; skipSelf: true; }]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PblNgridColumnReorderPluginDirective<any>, "pbl-ngrid[columnReorder]", ["pblNgridColumnReorder"], { "directContainerElement": "cdkDropListDirectContainerElement"; "columnReorder": "columnReorder"; "manualOverride": "manualOverride"; }, { "dragging": "cdkDropDragging"; }, never>;
}
export declare class PblNgridColumnDragDirective<T = any> extends CdkDrag<T> implements AfterViewInit, CdkLazyDrag<T, PblNgridColumnReorderPluginDirective<T>, PblNgridColumnDragDirective<T>> {
    rootElementSelector: string;
    column: PblColumn;
    set context(value: Pick<PblNgridCellContext<T>, 'col' | 'grid'> & Partial<Pick<PblNgridCellContext<T>, 'row' | 'value'>>);
    private _context;
    private pluginCtrl;
    private cache;
    constructor(element: ElementRef<HTMLElement>, dropContainer: CdkDropList, _document: any, _ngZone: NgZone, _viewContainerRef: ViewContainerRef, config: DragRefConfig, _dir: Directionality, dragDrop: DragDrop, _changeDetectorRef: ChangeDetectorRef);
    /**
     * A class to set when the root element is not the host element. (i.e. when `cdkDragRootElement` is used).
     */
    set rootElementSelectorClass(value: string);
    get pblDragRef(): PblDragRef<PblNgridColumnDragDirective<T>>;
    get cdkDropList(): PblNgridColumnReorderPluginDirective<T>;
    set cdkDropList(value: PblNgridColumnReorderPluginDirective<T>);
    _rootClass: string;
    _hostNotRoot: boolean;
    ngOnInit(): void;
    ngOnDestroy(): void;
    ngAfterViewInit(): void;
    getCells(): HTMLElement[];
    reset(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PblNgridColumnDragDirective<any>, [null, { optional: true; skipSelf: true; }, null, null, null, null, null, null, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PblNgridColumnDragDirective<any>, "[pblNgridColumnDrag]", ["pblNgridColumnDrag"], { "context": "pblNgridColumnDrag"; "cdkDropList": "cdkDropList"; "rootElementSelectorClass": "cdkDragRootElementClass"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLXJlb3JkZXItcGx1Z2luLmQudHMiLCJzb3VyY2VzIjpbImNvbHVtbi1yZW9yZGVyLXBsdWdpbi5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBEcmFnRHJvcCwgQ2RrRHJhZywgQ2RrRHJvcExpc3RHcm91cCwgQ2RrRHJvcExpc3QsIERyYWdSZWZDb25maWcgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcbmltcG9ydCB7IFBibE5ncmlkQ29tcG9uZW50LCBQYmxDb2x1bW4sIFBibE5ncmlkUGx1Z2luQ29udHJvbGxlciwgUGJsTmdyaWRDZWxsQ29udGV4dCB9IGZyb20gJ0BwZWJ1bGEvbmdyaWQnO1xuaW1wb3J0IHsgQ2RrTGF6eURyb3BMaXN0LCBDZGtMYXp5RHJhZyB9IGZyb20gJy4uL2NvcmUvbGF6eS1kcmFnLWRyb3AnO1xuaW1wb3J0IHsgUGJsRHJvcExpc3RSZWYgfSBmcm9tICcuLi9jb3JlL2Ryb3AtbGlzdC1yZWYnO1xuaW1wb3J0IHsgUGJsRHJhZ1JlZiB9IGZyb20gJy4uL2NvcmUvZHJhZy1yZWYnO1xuZGVjbGFyZSBtb2R1bGUgJ0BwZWJ1bGEvbmdyaWQvbGliL2V4dC90eXBlcycge1xuICAgIGludGVyZmFjZSBQYmxOZ3JpZFBsdWdpbkV4dGVuc2lvbiB7XG4gICAgICAgIGNvbHVtblJlb3JkZXI/OiBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU7XG4gICAgfVxufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgUExVR0lOX0tFWTogJ2NvbHVtblJlb3JkZXInO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGJsTmdyaWRDb2x1bW5SZW9yZGVyUGx1Z2luRGlyZWN0aXZlPFQgPSBhbnk+IGV4dGVuZHMgQ2RrRHJvcExpc3Q8VD4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQ2RrTGF6eURyb3BMaXN0PFQsIFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPj4ge1xuICAgIHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxUPjtcbiAgICBpZDogc3RyaW5nO1xuICAgIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnO1xuICAgIGdldCBjb2x1bW5SZW9yZGVyKCk6IGJvb2xlYW47XG4gICAgc2V0IGNvbHVtblJlb3JkZXIodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgd2lsbCBub3QgbW92ZSB0aGUgY29sdW1uIG9uIGRyb3AuXG4gICAgICogSW5zdGVhZCB5b3UgbmVlZCB0byBoYW5kbGUgdGhlIGRyb3BwZWQgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IG1hbnVhbE92ZXJyaWRlKCk6IGJvb2xlYW47XG4gICAgc2V0IG1hbnVhbE92ZXJyaWRlKHZhbHVlOiBib29sZWFuKTtcbiAgICBkcmFnZ2luZzogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+O1xuICAgIF9kcmFnZ2FibGVzOiBRdWVyeUxpc3Q8Q2RrRHJhZz47XG4gICAgcHJpdmF0ZSBfY29sdW1uUmVvcmRlcjtcbiAgICBwcml2YXRlIF9tYW51YWxPdmVycmlkZTtcbiAgICBwcml2YXRlIF9yZW1vdmVQbHVnaW47XG4gICAgcHJpdmF0ZSBsYXN0U3dhcDtcbiAgICBwcml2YXRlIGxhc3RTb3J0ZWQ7XG4gICAgcHJpdmF0ZSBnZXQgcGJsR2V0SXRlbUluZGV4RnJvbVBvaW50ZXJQb3NpdGlvbigpO1xuICAgIHByaXZhdGUgZ2V0IHBibEdldFBvc2l0aW9uQ2FjaGVJdGVtcygpO1xuICAgIGNvbnN0cnVjdG9yKHRhYmxlOiBQYmxOZ3JpZENvbXBvbmVudDxUPiwgcGx1Z2luQ3RybDogUGJsTmdyaWRQbHVnaW5Db250cm9sbGVyLCBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgZHJhZ0Ryb3A6IERyYWdEcm9wLCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGRpcj86IERpcmVjdGlvbmFsaXR5LCBncm91cD86IENka0Ryb3BMaXN0R3JvdXA8Q2RrRHJvcExpc3Q+KTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RvciB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRpcmVjdCBjb250YWluZXIgZWxlbWVudCwgc3RhcnRpbmcgZnJvbVxuICAgICAqIHRoZSBgY2RrRHJvcExpc3RgIGVsZW1lbnQgYW5kIGdvaW5nIGRvd24gdGhlIERPTS4gUGFzc2luZyBhbiBhbHRlcm5hdGUgZGlyZWN0IGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogaXMgdXNlZnVsIHdoZW4gdGhlIGBjZGtEcm9wTGlzdGAgaXMgbm90IHRoZSBkaXJlY3QgcGFyZW50IChpLmUuIGFuY2VzdG9yIGJ1dCBub3QgZmF0aGVyKVxuICAgICAqIG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudHMuXG4gICAgICovXG4gICAgZGlyZWN0Q29udGFpbmVyRWxlbWVudDogc3RyaW5nO1xuICAgIGdldCBwYmxEcm9wTGlzdFJlZigpOiBQYmxEcm9wTGlzdFJlZjxQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU8VD4+O1xuICAgIG9yaWdpbmFsRWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gICAgX2RyYWdnYWJsZXNTZXQ6IFNldDxDZGtEcmFnPGFueT4+O1xuICAgIGFkZERyYWcoZHJhZzogQ2RrRHJhZyk6IHZvaWQ7XG4gICAgcmVtb3ZlRHJhZyhkcmFnOiBDZGtEcmFnKTogYm9vbGVhbjtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgYmVmb3JlU3RhcnRlZCgpOiB2b2lkO1xuICAgIHByaXZhdGUgX3BibFJlc2V0O1xuICAgIHByaXZhdGUgbW9ua2V5UGF0Y2hEcm9wTGlzdFJlZjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUID0gYW55PiBleHRlbmRzIENka0RyYWc8VD4gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBDZGtMYXp5RHJhZzxULCBQYmxOZ3JpZENvbHVtblJlb3JkZXJQbHVnaW5EaXJlY3RpdmU8VD4sIFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUPj4ge1xuICAgIHJvb3RFbGVtZW50U2VsZWN0b3I6IHN0cmluZztcbiAgICBjb2x1bW46IFBibENvbHVtbjtcbiAgICBzZXQgY29udGV4dCh2YWx1ZTogUGljazxQYmxOZ3JpZENlbGxDb250ZXh0PFQ+LCAnY29sJyB8ICdncmlkJz4gJiBQYXJ0aWFsPFBpY2s8UGJsTmdyaWRDZWxsQ29udGV4dDxUPiwgJ3JvdycgfCAndmFsdWUnPj4pO1xuICAgIHByaXZhdGUgX2NvbnRleHQ7XG4gICAgcHJpdmF0ZSBwbHVnaW5DdHJsO1xuICAgIHByaXZhdGUgY2FjaGU7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIGRyb3BDb250YWluZXI6IENka0Ryb3BMaXN0LCBfZG9jdW1lbnQ6IGFueSwgX25nWm9uZTogTmdab25lLCBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgY29uZmlnOiBEcmFnUmVmQ29uZmlnLCBfZGlyOiBEaXJlY3Rpb25hbGl0eSwgZHJhZ0Ryb3A6IERyYWdEcm9wLCBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIHRvIHNldCB3aGVuIHRoZSByb290IGVsZW1lbnQgaXMgbm90IHRoZSBob3N0IGVsZW1lbnQuIChpLmUuIHdoZW4gYGNka0RyYWdSb290RWxlbWVudGAgaXMgdXNlZCkuXG4gICAgICovXG4gICAgc2V0IHJvb3RFbGVtZW50U2VsZWN0b3JDbGFzcyh2YWx1ZTogc3RyaW5nKTtcbiAgICBnZXQgcGJsRHJhZ1JlZigpOiBQYmxEcmFnUmVmPFBibE5ncmlkQ29sdW1uRHJhZ0RpcmVjdGl2ZTxUPj47XG4gICAgZ2V0IGNka0Ryb3BMaXN0KCk6IFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPjtcbiAgICBzZXQgY2RrRHJvcExpc3QodmFsdWU6IFBibE5ncmlkQ29sdW1uUmVvcmRlclBsdWdpbkRpcmVjdGl2ZTxUPik7XG4gICAgX3Jvb3RDbGFzczogc3RyaW5nO1xuICAgIF9ob3N0Tm90Um9vdDogYm9vbGVhbjtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgZ2V0Q2VsbHMoKTogSFRNTEVsZW1lbnRbXTtcbiAgICByZXNldCgpOiB2b2lkO1xufVxuIl19