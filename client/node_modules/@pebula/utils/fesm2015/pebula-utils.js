import { Subject } from 'rxjs';
import { takeUntil, filter } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Emits the values emitted by the source observable until a kill signal is sent to the group.
 * You can also specify a `subKillGroup` which can be used to kill specific subscriptions within a group.
 *
 * When a `killGroup` is "killed" all `subKillGroup` are killed as well. When a `subKillGroup` is "killed" the group remains
 * as well as other "subKillGroup" registered for that group.
 *
 * > WARNING: Do not apply operators that subscribe internally (e.g. combineLatest, switchMap) after the `killOnDestroy` operator.
 * Internal subscriptions will not unsubscribe automatically.
 * For more information see {\@link https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef | this blog post}
 * @template T
 * @param {?} killGroup
 * @param {?=} subKillGroup
 * @return {?}
 */
function unrx(killGroup, subKillGroup) {
    return unrx.pipe(killGroup, subKillGroup);
}
(function (unrx) {
    /** @type {?} */
    const ALL_HANDLERS_TOKEN = {};
    /** @type {?} */
    const notifierStore = new WeakMap();
    /**
     * @param {?} component
     * @param {?=} create
     * @return {?}
     */
    function getNotifier(component, create = false) {
        /** @type {?} */
        let notifier = notifierStore.get(component);
        if (!notifier && create === true) {
            notifierStore.set(component, notifier = new Subject());
        }
        return notifier;
    }
    /**
     * @param {?} killGroup
     * @param {...?} subKillGroup
     * @return {?}
     */
    function kill(killGroup, ...subKillGroup) {
        if (subKillGroup.length === 0) {
            killAll(killGroup);
        }
        else {
            /** @type {?} */
            const notifier = getNotifier(killGroup);
            if (notifier) {
                for (const h of subKillGroup) {
                    notifier.next(h);
                }
            }
        }
    }
    unrx.kill = kill;
    /**
     * {\@inheritdoc unrx}
     * @template T
     * @param {?} killGroup
     * @param {?=} subKillGroup
     * @return {?}
     */
    function pipe(killGroup, subKillGroup) {
        return (/**
         * @param {?} source
         * @return {?}
         */
        (source) => source.pipe(takeUntil(getNotifier(killGroup, true).pipe(filter((/**
         * @param {?} h
         * @return {?}
         */
        h => h === ALL_HANDLERS_TOKEN || (subKillGroup && h === subKillGroup)))))));
    }
    unrx.pipe = pipe;
    /**
     * @param {?} obj
     * @return {?}
     */
    function killAll(obj) {
        /** @type {?} */
        const notifier = getNotifier(obj);
        if (notifier) {
            notifier.next(ALL_HANDLERS_TOKEN);
            notifier.complete();
            notifierStore.delete(obj);
        }
    }
})(unrx || (unrx = {}));
/**
 * @template T
 * @param {?=} component
 * @param {?=} handler
 * @return {?}
 */
function UnRx(component, handler) {
    return component
        ? unrx(component, handler)
        : UnRx.decorateComponent;
}
(function (UnRx) {
    /** @type {?} */
    let invokeTypeStack = [];
    /** @type {?} */
    const originalOnDestroyFunctionStore = new Map();
    /**
     * @return {?}
     */
    function ngOnDestroy() {
        /** @type {?} */
        const len = invokeTypeStack.length;
        /** @type {?} */
        let type = this.constructor;
        if (len > 0) {
            /** @type {?} */
            const lastType = invokeTypeStack[len - 1];
            if (type === lastType) {
                type = Object.getPrototypeOf(type);
            }
        }
        invokeTypeStack.push(type);
        /** @type {?} */
        const oldNgOnDestroy = originalOnDestroyFunctionStore.get(type);
        if (oldNgOnDestroy) {
            try {
                oldNgOnDestroy.apply(this);
            }
            catch (err) {
                invokeTypeStack = [];
                throw err;
            }
        }
        invokeTypeStack.pop();
        if (len === 0) {
            unrx.kill(this);
        }
    }
    /**
     * @param {?} target
     * @return {?}
     */
    function decorateComponent(target) {
        /** @type {?} */
        const proto = target.prototype;
        if (proto.ngOnDestroy) {
            originalOnDestroyFunctionStore.set(target, proto.ngOnDestroy);
        }
        proto.ngOnDestroy = ngOnDestroy;
        return target;
    }
    UnRx.decorateComponent = decorateComponent;
    /**
     * @param {?} component
     * @param {...?} tokens
     * @return {?}
     */
    function kill(component, ...tokens) {
        unrx.kill(component, ...tokens);
    }
    UnRx.kill = kill;
})(UnRx || (UnRx = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} arr
 * @param {?} value
 * @return {?}
 */
function removeFromArray(arr, value) {
    if (Array.isArray(value)) {
        return value.map((/**
         * @param {?} v
         * @return {?}
         */
        v => _removeFromArray(arr, v)));
    }
    else if (typeof value === 'function') {
        /** @type {?} */
        const idx = arr.findIndex((/** @type {?} */ (value)));
        if (idx > -1) {
            arr.splice(idx, 1);
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return _removeFromArray(arr, value);
    }
}
/**
 * @template T
 * @param {?} arr
 * @param {?} value
 * @return {?}
 */
function _removeFromArray(arr, value) {
    /** @type {?} */
    const idx = arr.indexOf(value);
    if (idx > -1) {
        arr.splice(idx, 1);
        return true;
    }
    else {
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function Constructor() { }
/**
 * @param {?} base
 * @param {?} mixins
 * @return {?}
 */
function mixObjects(base, mixins) {
    mixins.forEach((/**
     * @param {?} mixin
     * @return {?}
     */
    mixin => {
        Object.getOwnPropertyNames(mixin)
            .concat((/** @type {?} */ (Object.getOwnPropertySymbols(mixin))))
            .forEach((/**
         * @param {?} name
         * @return {?}
         */
        name => {
            // mixin can't override base behavior, only add
            if (!base.hasOwnProperty(name)) {
                // if its a property descriptor we need to rewire the context
                /** @type {?} */
                const propDesc = Object.getOwnPropertyDescriptor(mixin, name);
                if (propDesc) {
                    Object.defineProperty(base, name, propDesc);
                }
                else {
                    base[name] = mixin[name];
                }
            }
        }));
    }));
}
/**
 * Type-less mixin
 * @param {?} base
 * @param {?} mixin
 * @param {?=} extend
 * @return {?}
 */
function MixinFree(base, mixin, extend = 'both') {
    if (extend === 'proto' || extend === 'both') {
        mixObjects(base.prototype, [mixin.prototype]);
    }
    if (extend === 'class' || extend === 'both') {
        mixObjects(base, [mixin]);
    }
    return (/** @type {?} */ (base));
}
/**
 * A type friendly, class based, mixin functions that mix in instance and static members.
 *
 * EXAMPLE:
 * ```ts
 * class User_ {
 *   id: number;
 *   firstName: string;
 *   lastName: string;
 * }
 *
 * class FullName {
 *   get fullName(): string {
 *     return `${this['firstName']} ${this['lastName']}`;
 *   }
 *
 *   static createId(): number {
 *     // a shady id generator.
 *     return Date.now();
 *   }
 * }
 *
 * export const User = Mixin(User_, FullName);
 * export type User = Mixin<User_, FullName>;
 *
 * // not using it:
 * const user = new User();
 * user.id = User.createId();
 * user.firstName = 'John';
 * user.lastName = 'Doe';
 * console.log(user.fullName); // John Doe
 * ```
 *
 * > To allow Generics in static members (e.g. static createUser(): T) see MixinExt
 *
 * ## Limitations:
 * From a type perspective this utility has limitations.
 *
 * #### You can't (currently) extend a mixed in type.
 * ```ts
 *  export const User = Mixin(User_, FullName);
 *
 *  export class MyExtendedUser extends User { // <- Type Error
 *  }
 * ```
 *
 * ```
 * Type 'Type<User_ & FullName> & typeof FullName & typeof User_' is not a constructor function type.
 * ```
 *
 * The error is misleading, this is a current known TS limitation (see [Github Issue](https://github.com/Microsoft/TypeScript/issues/4890))
 *
 * #### You can use generic inference once, from that point the generic param types for mixin have to be explicitly set:
 * ```ts
 *   export const User = Mixin(User_, FullName); // fine
 *
 *   export const UserNumber2 = Mixin(User, OtherMixin); // Error
 * ```
 *
 * ```
 * The type argument for type parameter 'TBASE' cannot be inferred from the usage.
 * Consider specifying the type arguments explicitly.
 * Type argument candidate 'FullName' is not a valid type argument because it is not a supertype of candidate 'User_'.
 * Property 'fullName' is missing in type 'User_'.
 * ```
 * This might be related to the previous limitation, or not...
 *
 *
 * There are 2 solution:
 *
 * 1) Using the built in interface that supports up to 6 mixins at once. (base + 6)
 * ```ts
 * export const User = Mixin(User_, FullName, OtherMixin); //  FullName, OtherMixin are 2, you can rest param your way for 5 more...
 * export type User = User_ & FullName & OtherMixin
 * ```
 * > This time we cant use `Mixin` to apply the User **type** so we just do it manually...
 *
 * 2) going the long way:
 * ```ts
 *   export const User = Mixin(User_, FullName); // fine
 *
 *   export const UserNumber2 = Mixin<User, typeof User, OtherMixin, typeof OtherMixin>(User, OtherMixin);
 * ```
 *
 *
 * @template TBASE, CBASE, TMIXIN, CMIXIN
 * @param {?} base
 * @param {...?} mixins
 * @return {?}
 */
function Mixin(base, ...mixins) {
    mixObjects(base.prototype, mixins.map((/**
     * @param {?} m
     * @return {?}
     */
    m => m.prototype)));
    mixObjects(base, mixins);
    return (/** @type {?} */ (base));
}
/**
 * For full description see Mixin function.
 *
 * The MixinExt utility does the same as Mixin but also allows adding an extra static type to the intersection.
 *
 * Although static members are mixed in there is a situation that requires an additional static mixin.
 * In a TypeScript class we can not apply generics on static members in the class level, only in a member based level.
 * If we want to return our final mixin type from a static member (e.g: factory) we need a different type.
 *
 * Example:
 * ```ts
 * class User_ {
 *   id: number;
 *   firstName: string;
 *   lastName: string;
 * }
 *
 * class FullName {
 *   get fullName(): string {
 *     return `${this['firstName']} ${this['lastName']}`;
 *   }
 * }
 *
 * const createNew = {
 *   create(): any {
 *     return new User_(); // at this point User_ is fully mixed in.
 *   }
 * }
 *
 * interface CreateStatic<T> {
 *   create(): Mixin<T, FullName>;
 * }
 *
 * export const User = MixinExt(User_, createNew as CreateStatic<User_>, FullName );
 * export type User = Mixin<User_, FullName>;
 * ```
 *
 * > Same as Mixin, MixinExt supports up to 6 mixins but only 1 extra static member.
 * If you need more then 1 just intersect all of your extera static interfaces to 1.
 * @template TBASE, CBASE, SMIXIN, TMIXIN, CMIXIN
 * @param {?} base
 * @param {?} extraStatic Optional object for extra static member, use for static functions that require generics with Generics.
 * @param {...?} mixins
 * @return {?}
 */
function MixinExt(base, extraStatic, ...mixins) {
    ((/** @type {?} */ (Mixin)))(base, ...mixins);
    mixObjects(base, Array.of(extraStatic));
    return (/** @type {?} */ (base));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isNumber(obj) {
    return typeof obj === 'number';
}
/**
 * @param {?} obj
 * @return {?}
 */
function isString(obj) {
    return typeof obj === 'string';
}
/**
 * @param {?} obj
 * @return {?}
 */
function isFunction(obj) {
    return typeof obj === 'function';
}
/**
 * @param {?} target
 * @return {?}
 */
function isStaticDecorator(target) {
    return isFunction(target);
}
/** @type {?} */
const undef = undefined;
/**
 * @param {?} obj
 * @return {?}
 */
function isUndefined(obj) {
    return obj === undef;
}
/**
 * @param {?} type
 * @return {?}
 */
function ensureTargetIsType(type) {
    return isFunction(type) ? type : type.constructor;
}
/**
 * @param {?} obj
 * @return {?}
 */
function isJsObject(obj) {
    return obj !== null && (typeof obj === 'function' || typeof obj === 'object');
}
/**
 * @param {?} obj
 * @return {?}
 */
function isPrimitive(obj) {
    return !isJsObject(obj);
}
/**
 * See https://github.com/angular/angular/blob/2.0.0-rc.4/modules/%40angular/facade/src/lang.ts#L149
 * @param {?} token
 * @return {?}
 */
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    /** @type {?} */
    const res = token.toString();
    /** @type {?} */
    const newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the chain of prototypes up to Object (not included)
 * \@pluginApi
 * @param {?} cls
 * @return {?}
 */
function getProtoChain(cls) {
    /** @type {?} */
    const classes = [];
    while (cls && cls !== Object) {
        classes.push(cls);
        /** @type {?} */
        const proto = Object.getPrototypeOf(cls.prototype);
        cls = isFunction(proto) || !proto ? proto : proto.constructor;
    }
    return classes;
}
/**
 * @param {?} cls
 * @return {?}
 */
function getBaseClass(cls) {
    /** @type {?} */
    const proto = Object.getPrototypeOf(cls.prototype);
    return !proto || isFunction(proto) ? proto : proto.constructor;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Mixin, MixinExt, MixinFree, UnRx, ensureTargetIsType, getBaseClass, getProtoChain, isFunction, isJsObject, isNumber, isPrimitive, isStaticDecorator, isString, isUndefined, removeFromArray, stringify, unrx as ɵa };
//# sourceMappingURL=pebula-utils.js.map
