/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
/**
 * Emits the values emitted by the source observable until a kill signal is sent to the group.
 * You can also specify a `subKillGroup` which can be used to kill specific subscriptions within a group.
 *
 * When a `killGroup` is "killed" all `subKillGroup` are killed as well. When a `subKillGroup` is "killed" the group remains
 * as well as other "subKillGroup" registered for that group.
 *
 * > WARNING: Do not apply operators that subscribe internally (e.g. combineLatest, switchMap) after the `killOnDestroy` operator.
 * Internal subscriptions will not unsubscribe automatically.
 * For more information see {\@link https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef | this blog post}
 * @template T
 * @param {?} killGroup
 * @param {?=} subKillGroup
 * @return {?}
 */
export function unrx(killGroup, subKillGroup) {
    return unrx.pipe(killGroup, subKillGroup);
}
(function (unrx) {
    /** @type {?} */
    const ALL_HANDLERS_TOKEN = {};
    /** @type {?} */
    const notifierStore = new WeakMap();
    /**
     * @param {?} component
     * @param {?=} create
     * @return {?}
     */
    function getNotifier(component, create = false) {
        /** @type {?} */
        let notifier = notifierStore.get(component);
        if (!notifier && create === true) {
            notifierStore.set(component, notifier = new Subject());
        }
        return notifier;
    }
    /**
     * @param {?} killGroup
     * @param {...?} subKillGroup
     * @return {?}
     */
    function kill(killGroup, ...subKillGroup) {
        if (subKillGroup.length === 0) {
            killAll(killGroup);
        }
        else {
            /** @type {?} */
            const notifier = getNotifier(killGroup);
            if (notifier) {
                for (const h of subKillGroup) {
                    notifier.next(h);
                }
            }
        }
    }
    unrx.kill = kill;
    /**
     * {\@inheritdoc unrx}
     * @template T
     * @param {?} killGroup
     * @param {?=} subKillGroup
     * @return {?}
     */
    function pipe(killGroup, subKillGroup) {
        return (/**
         * @param {?} source
         * @return {?}
         */
        (source) => source.pipe(takeUntil(getNotifier(killGroup, true).pipe(filter((/**
         * @param {?} h
         * @return {?}
         */
        h => h === ALL_HANDLERS_TOKEN || (subKillGroup && h === subKillGroup)))))));
    }
    unrx.pipe = pipe;
    /**
     * @param {?} obj
     * @return {?}
     */
    function killAll(obj) {
        /** @type {?} */
        const notifier = getNotifier(obj);
        if (notifier) {
            notifier.next(ALL_HANDLERS_TOKEN);
            notifier.complete();
            notifierStore.delete(obj);
        }
    }
})(unrx || (unrx = {}));
/**
 * @template T
 * @param {?=} component
 * @param {?=} handler
 * @return {?}
 */
export function UnRx(component, handler) {
    return component
        ? unrx(component, handler)
        : UnRx.decorateComponent;
}
(function (UnRx) {
    /** @type {?} */
    let invokeTypeStack = [];
    /** @type {?} */
    const originalOnDestroyFunctionStore = new Map();
    /**
     * @return {?}
     */
    function ngOnDestroy() {
        /** @type {?} */
        const len = invokeTypeStack.length;
        /** @type {?} */
        let type = this.constructor;
        if (len > 0) {
            /** @type {?} */
            const lastType = invokeTypeStack[len - 1];
            if (type === lastType) {
                type = Object.getPrototypeOf(type);
            }
        }
        invokeTypeStack.push(type);
        /** @type {?} */
        const oldNgOnDestroy = originalOnDestroyFunctionStore.get(type);
        if (oldNgOnDestroy) {
            try {
                oldNgOnDestroy.apply(this);
            }
            catch (err) {
                invokeTypeStack = [];
                throw err;
            }
        }
        invokeTypeStack.pop();
        if (len === 0) {
            unrx.kill(this);
        }
    }
    /**
     * @param {?} target
     * @return {?}
     */
    function decorateComponent(target) {
        /** @type {?} */
        const proto = target.prototype;
        if (proto.ngOnDestroy) {
            originalOnDestroyFunctionStore.set(target, proto.ngOnDestroy);
        }
        proto.ngOnDestroy = ngOnDestroy;
        return target;
    }
    UnRx.decorateComponent = decorateComponent;
    /**
     * @param {?} component
     * @param {...?} tokens
     * @return {?}
     */
    function kill(component, ...tokens) {
        unrx.kill(component, ...tokens);
    }
    UnRx.kill = kill;
})(UnRx || (UnRx = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5yeC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BwZWJ1bGEvdXRpbHMvIiwic291cmNlcyI6WyJsaWIvdW5yeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBYW5ELE1BQU0sVUFBVSxJQUFJLENBQUksU0FBYyxFQUFFLFlBQWtCO0lBQ3hELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBSSxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELFdBQWlCLElBQUk7O1VBQ2Isa0JBQWtCLEdBQUcsRUFBRTs7VUFDdkIsYUFBYSxHQUFHLElBQUksT0FBTyxFQUFxQjs7Ozs7O0lBRXRELFNBQVMsV0FBVyxDQUFDLFNBQWMsRUFBRSxNQUFNLEdBQUcsS0FBSzs7WUFDN0MsUUFBUSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQzNDLElBQUksQ0FBQyxRQUFRLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtZQUNoQyxhQUFhLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxRQUFRLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQzs7Ozs7O0lBZUQsU0FBZ0IsSUFBSSxDQUFDLFNBQWMsRUFBRSxHQUFHLFlBQW1CO1FBQ3pELElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3BCO2FBQU07O2tCQUNDLFFBQVEsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO1lBQ3ZDLElBQUksUUFBUSxFQUFFO2dCQUNaLEtBQUssTUFBTSxDQUFDLElBQUksWUFBWSxFQUFFO29CQUM1QixRQUFRLENBQUMs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QUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUZlLFNBQUksT0FFbkIsQ0FBQTtBQUVILENBQUMsRUExRGdCLElBQUksS0FBSixJQUFJLFFBMERwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEVtaXRzIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIG9ic2VydmFibGUgdW50aWwgYSBraWxsIHNpZ25hbCBpcyBzZW50IHRvIHRoZSBncm91cC5cbiAqIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGEgYHN1YktpbGxHcm91cGAgd2hpY2ggY2FuIGJlIHVzZWQgdG8ga2lsbCBzcGVjaWZpYyBzdWJzY3JpcHRpb25zIHdpdGhpbiBhIGdyb3VwLlxuICpcbiAqIFdoZW4gYSBga2lsbEdyb3VwYCBpcyBcImtpbGxlZFwiIGFsbCBgc3ViS2lsbEdyb3VwYCBhcmUga2lsbGVkIGFzIHdlbGwuIFdoZW4gYSBgc3ViS2lsbEdyb3VwYCBpcyBcImtpbGxlZFwiIHRoZSBncm91cCByZW1haW5zXG4gKiBhcyB3ZWxsIGFzIG90aGVyIFwic3ViS2lsbEdyb3VwXCIgcmVnaXN0ZXJlZCBmb3IgdGhhdCBncm91cC5cbiAqXG4gKiA+IFdBUk5JTkc6IERvIG5vdCBhcHBseSBvcGVyYXRvcnMgdGhhdCBzdWJzY3JpYmUgaW50ZXJuYWxseSAoZS5nLiBjb21iaW5lTGF0ZXN0LCBzd2l0Y2hNYXApIGFmdGVyIHRoZSBga2lsbE9uRGVzdHJveWAgb3BlcmF0b3IuXG4gKiBJbnRlcm5hbCBzdWJzY3JpcHRpb25zIHdpbGwgbm90IHVuc3Vic2NyaWJlIGF1dG9tYXRpY2FsbHkuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUge0BsaW5rIGh0dHBzOi8vYmxvZy5hbmd1bGFyaW5kZXB0aC5jb20vcnhqcy1hdm9pZGluZy10YWtldW50aWwtbGVha3MtZmI1MTgyZDA0N2VmIHwgdGhpcyBibG9nIHBvc3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnJ4PFQ+KGtpbGxHcm91cDogYW55LCBzdWJLaWxsR3JvdXA/OiBhbnkpOiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHVucngucGlwZTxUPihraWxsR3JvdXAsIHN1YktpbGxHcm91cCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgdW5yeCB7XG4gIGNvbnN0IEFMTF9IQU5ETEVSU19UT0tFTiA9IHt9O1xuICBjb25zdCBub3RpZmllclN0b3JlID0gbmV3IFdlYWtNYXA8YW55LCBTdWJqZWN0PGFueT4+KCk7XG5cbiAgZnVuY3Rpb24gZ2V0Tm90aWZpZXIoY29tcG9uZW50OiBhbnksIGNyZWF0ZSA9IGZhbHNlKTogU3ViamVjdDxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgbm90aWZpZXIgPSBub3RpZmllclN0b3JlLmdldChjb21wb25lbnQpO1xuICAgIGlmICghbm90aWZpZXIgJiYgY3JlYXRlID09PSB0cnVlKSB7XG4gICAgICBub3RpZmllclN0b3JlLnNldChjb21wb25lbnQsIG5vdGlmaWVyID0gbmV3IFN1YmplY3Q8YW55PigpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vdGlmaWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBcImtpbGxcIiBzaWduYWwgdG8gdGhlIHNwZWNpZmllZCBga2lsbEdyb3VwYC5cbiAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJlIGFsbCBzdWJzY3JpcHRpb25zIHdpdGggdGhlIGB1bnJ4YCBwaXBlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBga2lsbEdyb3VwYC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBlbnRpcmUgYGtpbGxHcm91cGAgaXMgZGVzdHJveWVkLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbGwoa2lsbEdyb3VwOiBhbnkpOiB2b2lkO1xuICAvKipcbiAgICogU2VuZCBhIFwia2lsbFwiIHNpZ25hbCB0byBhIHNwZWNpZmljIGBzdWJLaWxsR3JvdXBgIGluIHRoZSBzcGVjaWZpZWQgYGtpbGxHcm91cGAuXG4gICAqIFRoaXMgd2lsbCBpbW1lZGlhdGVseSB1bnN1YnNjcmliZSBhbGwgc3Vic2NyaXB0aW9ucyB3aXRoIHRoZSBgdW5yeGAgcGlwZSByZWdpc3RlcmVkIHVuZGVyIHRoZSBzcGVjaWZpZWQgYGtpbGxHcm91cGAgYW5kIGBzdWJLaWxsR3JvdXBgLlxuICAgKlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbGwoa2lsbEdyb3VwOiBhbnksIC4uLnN1YktpbGxHcm91cDogYW55W10pOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24ga2lsbChraWxsR3JvdXA6IGFueSwgLi4uc3ViS2lsbEdyb3VwOiBhbnlbXSk6IHZvaWQge1xuICAgIGlmIChzdWJLaWxsR3JvdXAubGVuZ3RoID09PSAwKSB7XG4gICAgICBraWxsQWxsKGtpbGxHcm91cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vdGlmaWVyID0gZ2V0Tm90aWZpZXIoa2lsbEdyb3VwKTtcbiAgICAgIGlmIChub3RpZmllcikge1xuICAgICAgICBmb3IgKGNvbnN0IGggb2Ygc3ViS2lsbEdyb3VwKSB7XG4gICAgICAgICAgbm90aWZpZXIubmV4dChoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiB7QGluaGVyaXRkb2MgdW5yeH0gKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHBpcGU8VD4oa2lsbEdyb3VwOiBhbnksIHN1YktpbGxHcm91cD86IGFueSk6IChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBzb3VyY2UucGlwZShcbiAgICAgIHRha2VVbnRpbChnZXROb3RpZmllcihraWxsR3JvdXAsIHRydWUpLnBpcGUoZmlsdGVyKCBoID0+IGggPT09IEFMTF9IQU5ETEVSU19UT0tFTiB8fCAoc3ViS2lsbEdyb3VwICYmIGggPT09IHN1YktpbGxHcm91cCApICkpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBraWxsQWxsKG9iajogYW55KTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpZXIgPSBnZXROb3RpZmllcihvYmopO1xuICAgIGlmIChub3RpZmllcikge1xuICAgICAgbm90aWZpZXIubmV4dChBTExfSEFORExFUlNfVE9LRU4pO1xuICAgICAgbm90aWZpZXIuY29tcGxldGUoKTtcbiAgICAgIG5vdGlmaWVyU3RvcmUuZGVsZXRlKG9iaik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCB0aGUgYW5ndWxhciBjb21wb25lbnQgaW5zdGFuY2UgaXMgZGVzdHJveWVkLiAoYG5nT25EZXN0cm95YCBpcyBjYWxsZWQpLlxuICogSWYgdGhlIGNvbXBvbmVudCBhbHJlYWR5IGltcGxlbWVudHMgYG5nT25EZXN0cm95YCBpdCB3aWxsIHdyYXAgaXQuXG4gKlxuICogWW91IGNhbiBhbHNvIGRlc3Ryb3kgb24tZGVtYW5kIGJ5IHByb3ZpZGluZyBhIGhhbmRsZXIgYW5kIHVzZSBgVW5SeC5raWxsYCB0byB1bnN1YnNjcmliZS5cbiAqIE5vdGUgdGhhdCB1c2luZyB0aGUgc2FtZSBoYW5kbGVyIGlkIGZvciBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHdpbGwga2lsbCBhbGwgb2YgdGhlbSB0b2dldGhlciwgaS5lLiB0aGUgaGFuZGxlciBpcyBhbHNvIGEgZ3JvdXAuXG4gKlxuICogPiBXQVJOSU5HOiBEbyBub3QgYXBwbHkgb3BlcmF0b3JzIHRoYXQgc3Vic2NyaWJlIGludGVybmFsbHkgKGUuZy4gY29tYmluZUxhdGVzdCwgc3dpdGNoTWFwKSBhZnRlciB0aGUgYGtpbGxPbkRlc3Ryb3lgIG9wZXJhdG9yLlxuICogSW50ZXJuYWwgc3Vic2NyaXB0aW9ucyB3aWxsIG5vdCB1bnN1YnNjcmliZSBhdXRvbWF0aWNhbGx5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9ibG9nLmFuZ3VsYXJpbmRlcHRoLmNvbS9yeGpzLWF2b2lkaW5nLXRha2V1bnRpbC1sZWFrcy1mYjUxODJkMDQ3ZWZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuUng8VD4oY29tcG9uZW50OiBhbnksIGhhbmRsZXI/OiBhbnkpOiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+O1xuLyoqXG4gKiBBIERlY29yYXRvciB0aGF0IGFkZCBzdXBwb3J0IGZvciBhdXRvbWF0aWMgdW5zdWJzY3JpcHRpb24gaW4gYW5ndWxhciBjb21wb25lbnRzLlxuICpcbiAqIFdoZW4gYXBwbGllZCBvbiBhIGNvbXBvbmVudCwgYFVuUnhgIHdpbGwgd3JhcCB0aGUgYG5nT25EZXN0cm95YCBsaWZlLWN5Y2xlYCBob29rIChvciBjcmVhdGUgaWYgZG9lc24ndCBleGlzdCkgYW5kIGF1dG9tYXRpY2FsbHlcbiAqIGRlc3Ryb3kgYWxsIG9wZW4gc3Vic2NyaXB0aW9ucyB0aGF0IGNvbnRhaW4gdGhlIGBVblJ4YCBwaXBlIGluIHRoZWlyIGVtaXNzaW9uIHN0cmVhbS5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZSBhIGNvbXBvbmVudCB1c2luZyB0aGUgSFRUUCBjbGllbnQgdG8gY2FsbCBhIHNlcnZlci5cbiAqIFdlIGFkZCB0aGUgYFVuUnhgIHBpcGUgdG8gdGhlIHJlc3BvbnNlIG9ic2VydmFibGUgKGBwaXBlKFVuUngodGhpcykpYCkgc28gd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCB0aGUgc3Vic2NyaXB0aW9uIGlzIGNsb3NlZCBhcyB3ZWxsLlxuICpcbiAqIFRoaXMgbWlnaHQgc2VlbSByZWR1bmRhbnQgYmVjYXVzZSB0aGUgYEh0dHBDbGllbnRgIHdpbGwgYXV0b21hdGljYWxseSBjbG9zZSB0aGUgc3Vic2NyaXB0aW9uIGFmdGVyIHRoZSByZXNwb25zZSBidXQgd2hhdCBoYXBwZW4gd2hlblxuICogdGhlIHJlc3BvbnNlIGFycml2ZWQgQUZURVIgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgKHVzZXIgbGVmdCB0aGUgcGFnZSk/XG4gKlxuICogSW4gdGhpcyBjYXNlIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBlbWl0IHRoZSByZXNwb25zZSBhbmQgdGhlIGhhbmRsZXIgd2lsbCBydW4sIHdlIGRvbid0IHdhbnQgdGhhdCFcbiAqXG4gKiBCeSBhcHBseWluZyB0aGUgcGlwZSB3ZSBlbnN1cmUgdGhhdCBub3RoaW5nIHdpbGwgcnVuIG9uY2UgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gKlxuICogVGhlIEJJRyBCT05VUyBoZXJlIGlzIGh0dHAgY2FuY2VsbGF0aW9uLCBvbmNlIGRlc3Ryb3llZCBgVW5SeGAgd2lsbCBjbG9zZSB0aGUgc3Vic2NyaXB0aW9uIHdoaWNoIHdpbGwgY2FuY2VsIHRoZSBIVFRQIHJlcXVlc3QhXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktY21wJyxcbiAqICB0ZW1wbGF0ZTogYGBcbiAqIH0pXG4gKiBAVW5SeCgpIC8vIFdpbGwgdW4tc3Vic2NyaWJlIGFsbCBvcGVuIHN1YnNjcmlwdGlvbnMgd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogICBzdGF0aWMgVVJMID0gJy9zb21lLWVuZHBvaW50JztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogSHR0cENsaWVudCkgeyB9XG4gKlxuICogICBnZXREYXRhKCkge1xuICogICAgIHRoaXMuaHR0cC5nZXQoTXlDb21wb25lbnQuVVJMKVxuICogICAgICAgLnBpcGUoVW5SeCh0aGlzKSkgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHN0cmVhbSBmb3IgYXV0by1raWxsIG9uIGRlc3Ryb3lcbiAqICAgICAgIC5zdWJzY3JpYmUoIHJlc3BvbnNlID0+IHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICogICAgICAgfSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBpcyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIHRoZSBwcmV2aW91cyBvbmUuXG4gKiBBbGwgcGVuZGluZyByZXF1ZXN0IHdpbGwgYmUgY2FuY2VsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYnV0IHdlIHdpbGwgYWxzbyBjYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAqIHdoZW4gYSBuZXcgcmVxdWVzdCBpcyBmaXJlZC5cbiAqXG4gKiBXaXRoIHRoaXMgd2UgZW5zdXJlIHN0YXRlIGFuZCBmbG93IGludGVncml0eSAobm8gcmFjZSBjb25kaXRpb24gYmV0d2VlbiAyIHJlcXVlc3RzKS5cbiAqIFdlIGFsc28gbWFrZSBzdXJlIHRoYXQgcmVzb3VyY2VzIGFyZSBub3Qgd2FzdGVkIChtdWx0aXBsZSByZWR1bmRhbnQgcmVxdWVzdHMuKVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LWNtcCcsXG4gKiAgdGVtcGxhdGU6IGBgXG4gKiB9KVxuICogQFVuUngoKSAvLyBXaWxsIHVuLXN1YnNjcmliZSBhbGwgb3BlbiBzdWJzY3JpcHRpb25zIHdoZW4gY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgc3RhdGljIFVSTCA9ICcvc29tZS1lbmRwb2ludCc7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQpIHsgfVxuICpcbiAqICAgZ2V0RGF0YSgpIHtcbiAqICAgICBVblJ4LmtpbGwodGhpcywgTXlDb21wb25lbnQuVVJMKTsgLy8gS2lsbCAoY2FuY2VsKSBwZW5kaW5nIEhUVFAgcmVxdWVzdHNcbiAqICAgICB0aGlzLmh0dHAuZ2V0KE15Q29tcG9uZW50LlVSTClcbiAqICAgICAgIC5waXBlKFVuUngodGhpcywgTXlDb21wb25lbnQuVVJMKSkgLy8gUmVnaXN0ZXIgdGhlIHN0cmVhbSBmb3IgYXV0by1raWxsIG9uIGRlc3Ryb3kgYW5kIGFkZCBhIGhhbmRsZXIgZm9yIGFkLWhvYyB1bnN1YnNjcmliZVxuICogICAgICAgLnN1YnNjcmliZSggcmVzcG9uc2UgPT4ge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gKiAgICAgICB9KTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQGludGVybmFscmVtYXJrc1xuICogQmFzZWQgb24gd29yayBmcm9tOlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS93MTFrL25nMi1yeC1jb21wb25lbnRkZXN0cm95ZWQvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzXG4gKiAgIC0gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzgwMDgzMzQvYW5ndWxhci1yeGpzLXdoZW4tc2hvdWxkLWktdW5zdWJzY3JpYmUtZnJvbS1zdWJzY3JpcHRpb24vNDExNzcxNjMjNDExNzcxNjNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuUng8VCA9IGFueT4oKTogQ2xhc3NEZWNvcmF0b3I7XG5leHBvcnQgZnVuY3Rpb24gVW5SeDxUPihjb21wb25lbnQ/OiBhbnksIGhhbmRsZXI/OiBhbnkpOiBDbGFzc0RlY29yYXRvciB8ICggKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPiApIHtcbiAgcmV0dXJuIGNvbXBvbmVudFxuICAgID8gdW5yeDxUPihjb21wb25lbnQsIGhhbmRsZXIpXG4gICAgOiBVblJ4LmRlY29yYXRlQ29tcG9uZW50XG4gIDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBVblJ4IHtcbiAgbGV0IGludm9rZVR5cGVTdGFjazogYW55W10gPSBbXTtcbiAgY29uc3Qgb3JpZ2luYWxPbkRlc3Ryb3lGdW5jdGlvblN0b3JlID0gbmV3IE1hcDxhbnksICgpID0+IHZvaWQ+KCk7XG5cbiAgZnVuY3Rpb24gbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgY29uc3QgbGVuID0gaW52b2tlVHlwZVN0YWNrLmxlbmd0aDtcbiAgICBsZXQgdHlwZSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgY29uc3QgbGFzdFR5cGUgPSBpbnZva2VUeXBlU3RhY2tbbGVuIC0gMV07XG4gICAgICBpZiAodHlwZSA9PT0gbGFzdFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VUeXBlU3RhY2sucHVzaCh0eXBlKTtcblxuICAgIGNvbnN0IG9sZE5nT25EZXN0cm95ID0gb3JpZ2luYWxPbkRlc3Ryb3lGdW5jdGlvblN0b3JlLmdldCh0eXBlKTtcbiAgICBpZiAob2xkTmdPbkRlc3Ryb3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9sZE5nT25EZXN0cm95LmFwcGx5KHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGludm9rZVR5cGVTdGFjayA9IFtdO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlVHlwZVN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdW5yeC5raWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZUNvbXBvbmVudCh0YXJnZXQ6IGFueSk6IGFueSB7XG4gICAgY29uc3QgcHJvdG8gPSB0YXJnZXQucHJvdG90eXBlO1xuICAgIGlmIChwcm90by5uZ09uRGVzdHJveSkge1xuICAgICAgb3JpZ2luYWxPbkRlc3Ryb3lGdW5jdGlvblN0b3JlLnNldCh0YXJnZXQsIHByb3RvLm5nT25EZXN0cm95KTtcbiAgICB9XG4gICAgcHJvdG8ubmdPbkRlc3Ryb3kgPSBuZ09uRGVzdHJveTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBcImtpbGxcIiBzaWduYWwgdG8gdGhlIHNwZWNpZmllZCBgY29tcG9uZW50YCBpbnN0YW5jZS5cbiAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJlIGFsbCBzdWJzY3JpcHRpb25zIHdpdGggdGhlIGBVblJ4YCBwaXBlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24ga2lsbChraWxsR3JvdXA6IGFueSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTZW5kIGEgXCJraWxsXCIgc2lnbmFsIHRvIGEgc3BlY2lmaWMgYHRva2VuYCBpbiB0aGUgc3BlY2lmaWVkIGBjb21wb25lbnRgIGluc3RhbmNlLlxuICAgKiBUaGlzIHdpbGwgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmUgYWxsIHN1YnNjcmlwdGlvbnMgd2l0aCB0aGUgYFVuUnhgIHBpcGUgcmVnaXN0ZXJlZCB1bmRlciB0aGUgc3BlY2lmaWVkIGBjb21wb25lbnRgIGluc3RhbmNlIGFuZCBgdG9rZW5gLlxuICAgKlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbGwoY29tcG9uZW50OiBhbnksIC4uLnRva2VuczogYW55W10pOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24ga2lsbChjb21wb25lbnQ6IGFueSwgLi4udG9rZW5zOiBhbnlbXSk6IHZvaWQge1xuICAgIHVucngua2lsbChjb21wb25lbnQsIC4uLnRva2Vucyk7XG4gIH1cblxufVxuIl19