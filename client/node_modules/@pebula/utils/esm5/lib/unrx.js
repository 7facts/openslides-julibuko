/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
/**
 * Emits the values emitted by the source observable until a kill signal is sent to the group.
 * You can also specify a `subKillGroup` which can be used to kill specific subscriptions within a group.
 *
 * When a `killGroup` is "killed" all `subKillGroup` are killed as well. When a `subKillGroup` is "killed" the group remains
 * as well as other "subKillGroup" registered for that group.
 *
 * > WARNING: Do not apply operators that subscribe internally (e.g. combineLatest, switchMap) after the `killOnDestroy` operator.
 * Internal subscriptions will not unsubscribe automatically.
 * For more information see {\@link https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef | this blog post}
 * @template T
 * @param {?} killGroup
 * @param {?=} subKillGroup
 * @return {?}
 */
export function unrx(killGroup, subKillGroup) {
    return unrx.pipe(killGroup, subKillGroup);
}
(function (unrx) {
    /** @type {?} */
    var ALL_HANDLERS_TOKEN = {};
    /** @type {?} */
    var notifierStore = new WeakMap();
    /**
     * @param {?} component
     * @param {?=} create
     * @return {?}
     */
    function getNotifier(component, create) {
        if (create === void 0) { create = false; }
        /** @type {?} */
        var notifier = notifierStore.get(component);
        if (!notifier && create === true) {
            notifierStore.set(component, notifier = new Subject());
        }
        return notifier;
    }
    /**
     * @param {?} killGroup
     * @param {...?} subKillGroup
     * @return {?}
     */
    function kill(killGroup) {
        var e_1, _a;
        var subKillGroup = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            subKillGroup[_i - 1] = arguments[_i];
        }
        if (subKillGroup.length === 0) {
            killAll(killGroup);
        }
        else {
            /** @type {?} */
            var notifier = getNotifier(killGroup);
            if (notifier) {
                try {
                    for (var subKillGroup_1 = tslib_1.__values(subKillGroup), subKillGroup_1_1 = subKillGroup_1.next(); !subKillGroup_1_1.done; subKillGroup_1_1 = subKillGroup_1.next()) {
                        var h = subKillGroup_1_1.value;
                        notifier.next(h);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (subKillGroup_1_1 && !subKillGroup_1_1.done && (_a = subKillGroup_1.return)) _a.call(subKillGroup_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    }
    unrx.kill = kill;
    /**
     * {\@inheritdoc unrx}
     * @template T
     * @param {?} killGroup
     * @param {?=} subKillGroup
     * @return {?}
     */
    function pipe(killGroup, subKillGroup) {
        return (/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return source.pipe(takeUntil(getNotifier(killGroup, true).pipe(filter((/**
         * @param {?} h
         * @return {?}
         */
        function (h) { return h === ALL_HANDLERS_TOKEN || (subKillGroup && h === subKillGroup); }))))); });
    }
    unrx.pipe = pipe;
    /**
     * @param {?} obj
     * @return {?}
     */
    function killAll(obj) {
        /** @type {?} */
        var notifier = getNotifier(obj);
        if (notifier) {
            notifier.next(ALL_HANDLERS_TOKEN);
            notifier.complete();
            notifierStore.delete(obj);
        }
    }
})(unrx || (unrx = {}));
/**
 * @template T
 * @param {?=} component
 * @param {?=} handler
 * @return {?}
 */
export function UnRx(component, handler) {
    return component
        ? unrx(component, handler)
        : UnRx.decorateComponent;
}
(function (UnRx) {
    /** @type {?} */
    var invokeTypeStack = [];
    /** @type {?} */
    var originalOnDestroyFunctionStore = new Map();
    /**
     * @return {?}
     */
    function ngOnDestroy() {
        /** @type {?} */
        var len = invokeTypeStack.length;
        /** @type {?} */
        var type = this.constructor;
        if (len > 0) {
            /** @type {?} */
            var lastType = invokeTypeStack[len - 1];
            if (type === lastType) {
                type = Object.getPrototypeOf(type);
            }
        }
        invokeTypeStack.push(type);
        /** @type {?} */
        var oldNgOnDestroy = originalOnDestroyFunctionStore.get(type);
        if (oldNgOnDestroy) {
            try {
                oldNgOnDestroy.apply(this);
            }
            catch (err) {
                invokeTypeStack = [];
                throw err;
            }
        }
        invokeTypeStack.pop();
        if (len === 0) {
            unrx.kill(this);
        }
    }
    /**
     * @param {?} target
     * @return {?}
     */
    function decorateComponent(target) {
        /** @type {?} */
        var proto = target.prototype;
        if (proto.ngOnDestroy) {
            originalOnDestroyFunctionStore.set(target, proto.ngOnDestroy);
        }
        proto.ngOnDestroy = ngOnDestroy;
        return target;
    }
    UnRx.decorateComponent = decorateComponent;
    /**
     * @param {?} component
     * @param {...?} tokens
     * @return {?}
     */
    function kill(component) {
        var tokens = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            tokens[_i - 1] = arguments[_i];
        }
        unrx.kill.apply(unrx, tslib_1.__spread([component], tokens));
    }
    UnRx.kill = kill;
})(UnRx || (UnRx = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5yeC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BwZWJ1bGEvdXRpbHMvIiwic291cmNlcyI6WyJsaWIvdW5yeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDM0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWFuRCxNQUFNLFVBQVUsSUFBSSxDQUFJLFNBQWMsRUFBRSxZQUFrQjtJQUN4RCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUksU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxXQUFpQixJQUFJOztRQUNiLGtCQUFrQixHQUFHLEVBQUU7O1FBQ3ZCLGFBQWEsR0FBRyxJQUFJLE9BQU8sRUFBcUI7Ozs7OztJQUV0RCxTQUFTLFdBQVcsQ0FBQyxTQUFjLEVBQUUsTUFBYztRQUFkLHVCQUFBLEVBQUEsY0FBYzs7WUFDN0MsUUFBUSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQzNDLElBQUksQ0FBQyxRQUFRLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtZQUNoQyxhQUFhLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxRQUFRLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQzs7Ozs7O0lBZUQsU0FBZ0IsSUFBSSxDQUFDLFNBQWM7O1FBQUUsc0JBQXNCO2FBQXRCLFVBQXNCLEVBQXRCLHFCQUFzQixFQUF0QixJQUFzQjtZQUF0QixxQ0FBc0I7O1FBQ3pELElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3BCO2FBQU07O2dCQUNDLFFBQVEsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO1lBQ3ZDLElBQUksUUFB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LENBQUM7UUFDaEMsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQVBlLHNCQUFpQixvQkFPaEMsQ0FBQTs7Ozs7O0lBYUQsU0FBZ0IsSUFBSSxDQUFDLFNBQWM7UUFBRSxnQkFBZ0I7YUFBaEIsVUFBZ0IsRUFBaEIscUJBQWdCLEVBQWhCLElBQWdCO1lBQWhCLCtCQUFnQjs7UUFDbkQsSUFBSSxDQUFDLElBQUksT0FBVCxJQUFJLG9CQUFNLFNBQVMsR0FBSyxNQUFNLEdBQUU7SUFDbEMsQ0FBQztJQUZlLFNBQUksT0FFbkIsQ0FBQTtBQUVILENBQUMsRUExRGdCLElBQUksS0FBSixJQUFJLFFBMERwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEVtaXRzIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIG9ic2VydmFibGUgdW50aWwgYSBraWxsIHNpZ25hbCBpcyBzZW50IHRvIHRoZSBncm91cC5cbiAqIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGEgYHN1YktpbGxHcm91cGAgd2hpY2ggY2FuIGJlIHVzZWQgdG8ga2lsbCBzcGVjaWZpYyBzdWJzY3JpcHRpb25zIHdpdGhpbiBhIGdyb3VwLlxuICpcbiAqIFdoZW4gYSBga2lsbEdyb3VwYCBpcyBcImtpbGxlZFwiIGFsbCBgc3ViS2lsbEdyb3VwYCBhcmUga2lsbGVkIGFzIHdlbGwuIFdoZW4gYSBgc3ViS2lsbEdyb3VwYCBpcyBcImtpbGxlZFwiIHRoZSBncm91cCByZW1haW5zXG4gKiBhcyB3ZWxsIGFzIG90aGVyIFwic3ViS2lsbEdyb3VwXCIgcmVnaXN0ZXJlZCBmb3IgdGhhdCBncm91cC5cbiAqXG4gKiA+IFdBUk5JTkc6IERvIG5vdCBhcHBseSBvcGVyYXRvcnMgdGhhdCBzdWJzY3JpYmUgaW50ZXJuYWxseSAoZS5nLiBjb21iaW5lTGF0ZXN0LCBzd2l0Y2hNYXApIGFmdGVyIHRoZSBga2lsbE9uRGVzdHJveWAgb3BlcmF0b3IuXG4gKiBJbnRlcm5hbCBzdWJzY3JpcHRpb25zIHdpbGwgbm90IHVuc3Vic2NyaWJlIGF1dG9tYXRpY2FsbHkuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUge0BsaW5rIGh0dHBzOi8vYmxvZy5hbmd1bGFyaW5kZXB0aC5jb20vcnhqcy1hdm9pZGluZy10YWtldW50aWwtbGVha3MtZmI1MTgyZDA0N2VmIHwgdGhpcyBibG9nIHBvc3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnJ4PFQ+KGtpbGxHcm91cDogYW55LCBzdWJLaWxsR3JvdXA/OiBhbnkpOiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHVucngucGlwZTxUPihraWxsR3JvdXAsIHN1YktpbGxHcm91cCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgdW5yeCB7XG4gIGNvbnN0IEFMTF9IQU5ETEVSU19UT0tFTiA9IHt9O1xuICBjb25zdCBub3RpZmllclN0b3JlID0gbmV3IFdlYWtNYXA8YW55LCBTdWJqZWN0PGFueT4+KCk7XG5cbiAgZnVuY3Rpb24gZ2V0Tm90aWZpZXIoY29tcG9uZW50OiBhbnksIGNyZWF0ZSA9IGZhbHNlKTogU3ViamVjdDxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgbm90aWZpZXIgPSBub3RpZmllclN0b3JlLmdldChjb21wb25lbnQpO1xuICAgIGlmICghbm90aWZpZXIgJiYgY3JlYXRlID09PSB0cnVlKSB7XG4gICAgICBub3RpZmllclN0b3JlLnNldChjb21wb25lbnQsIG5vdGlmaWVyID0gbmV3IFN1YmplY3Q8YW55PigpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vdGlmaWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBcImtpbGxcIiBzaWduYWwgdG8gdGhlIHNwZWNpZmllZCBga2lsbEdyb3VwYC5cbiAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJlIGFsbCBzdWJzY3JpcHRpb25zIHdpdGggdGhlIGB1bnJ4YCBwaXBlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBga2lsbEdyb3VwYC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBlbnRpcmUgYGtpbGxHcm91cGAgaXMgZGVzdHJveWVkLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbGwoa2lsbEdyb3VwOiBhbnkpOiB2b2lkO1xuICAvKipcbiAgICogU2VuZCBhIFwia2lsbFwiIHNpZ25hbCB0byBhIHNwZWNpZmljIGBzdWJLaWxsR3JvdXBgIGluIHRoZSBzcGVjaWZpZWQgYGtpbGxHcm91cGAuXG4gICAqIFRoaXMgd2lsbCBpbW1lZGlhdGVseSB1bnN1YnNjcmliZSBhbGwgc3Vic2NyaXB0aW9ucyB3aXRoIHRoZSBgdW5yeGAgcGlwZSByZWdpc3RlcmVkIHVuZGVyIHRoZSBzcGVjaWZpZWQgYGtpbGxHcm91cGAgYW5kIGBzdWJLaWxsR3JvdXBgLlxuICAgKlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbGwoa2lsbEdyb3VwOiBhbnksIC4uLnN1YktpbGxHcm91cDogYW55W10pOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24ga2lsbChraWxsR3JvdXA6IGFueSwgLi4uc3ViS2lsbEdyb3VwOiBhbnlbXSk6IHZvaWQge1xuICAgIGlmIChzdWJLaWxsR3JvdXAubGVuZ3RoID09PSAwKSB7XG4gICAgICBraWxsQWxsKGtpbGxHcm91cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vdGlmaWVyID0gZ2V0Tm90aWZpZXIoa2lsbEdyb3VwKTtcbiAgICAgIGlmIChub3RpZmllcikge1xuICAgICAgICBmb3IgKGNvbnN0IGggb2Ygc3ViS2lsbEdyb3VwKSB7XG4gICAgICAgICAgbm90aWZpZXIubmV4dChoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiB7QGluaGVyaXRkb2MgdW5yeH0gKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHBpcGU8VD4oa2lsbEdyb3VwOiBhbnksIHN1YktpbGxHcm91cD86IGFueSk6IChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBzb3VyY2UucGlwZShcbiAgICAgIHRha2VVbnRpbChnZXROb3RpZmllcihraWxsR3JvdXAsIHRydWUpLnBpcGUoZmlsdGVyKCBoID0+IGggPT09IEFMTF9IQU5ETEVSU19UT0tFTiB8fCAoc3ViS2lsbEdyb3VwICYmIGggPT09IHN1YktpbGxHcm91cCApICkpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBraWxsQWxsKG9iajogYW55KTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpZXIgPSBnZXROb3RpZmllcihvYmopO1xuICAgIGlmIChub3RpZmllcikge1xuICAgICAgbm90aWZpZXIubmV4dChBTExfSEFORExFUlNfVE9LRU4pO1xuICAgICAgbm90aWZpZXIuY29tcGxldGUoKTtcbiAgICAgIG5vdGlmaWVyU3RvcmUuZGVsZXRlKG9iaik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCB0aGUgYW5ndWxhciBjb21wb25lbnQgaW5zdGFuY2UgaXMgZGVzdHJveWVkLiAoYG5nT25EZXN0cm95YCBpcyBjYWxsZWQpLlxuICogSWYgdGhlIGNvbXBvbmVudCBhbHJlYWR5IGltcGxlbWVudHMgYG5nT25EZXN0cm95YCBpdCB3aWxsIHdyYXAgaXQuXG4gKlxuICogWW91IGNhbiBhbHNvIGRlc3Ryb3kgb24tZGVtYW5kIGJ5IHByb3ZpZGluZyBhIGhhbmRsZXIgYW5kIHVzZSBgVW5SeC5raWxsYCB0byB1bnN1YnNjcmliZS5cbiAqIE5vdGUgdGhhdCB1c2luZyB0aGUgc2FtZSBoYW5kbGVyIGlkIGZvciBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHdpbGwga2lsbCBhbGwgb2YgdGhlbSB0b2dldGhlciwgaS5lLiB0aGUgaGFuZGxlciBpcyBhbHNvIGEgZ3JvdXAuXG4gKlxuICogPiBXQVJOSU5HOiBEbyBub3QgYXBwbHkgb3BlcmF0b3JzIHRoYXQgc3Vic2NyaWJlIGludGVybmFsbHkgKGUuZy4gY29tYmluZUxhdGVzdCwgc3dpdGNoTWFwKSBhZnRlciB0aGUgYGtpbGxPbkRlc3Ryb3lgIG9wZXJhdG9yLlxuICogSW50ZXJuYWwgc3Vic2NyaXB0aW9ucyB3aWxsIG5vdCB1bnN1YnNjcmliZSBhdXRvbWF0aWNhbGx5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9ibG9nLmFuZ3VsYXJpbmRlcHRoLmNvbS9yeGpzLWF2b2lkaW5nLXRha2V1bnRpbC1sZWFrcy1mYjUxODJkMDQ3ZWZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuUng8VD4oY29tcG9uZW50OiBhbnksIGhhbmRsZXI/OiBhbnkpOiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+O1xuLyoqXG4gKiBBIERlY29yYXRvciB0aGF0IGFkZCBzdXBwb3J0IGZvciBhdXRvbWF0aWMgdW5zdWJzY3JpcHRpb24gaW4gYW5ndWxhciBjb21wb25lbnRzLlxuICpcbiAqIFdoZW4gYXBwbGllZCBvbiBhIGNvbXBvbmVudCwgYFVuUnhgIHdpbGwgd3JhcCB0aGUgYG5nT25EZXN0cm95YCBsaWZlLWN5Y2xlYCBob29rIChvciBjcmVhdGUgaWYgZG9lc24ndCBleGlzdCkgYW5kIGF1dG9tYXRpY2FsbHlcbiAqIGRlc3Ryb3kgYWxsIG9wZW4gc3Vic2NyaXB0aW9ucyB0aGF0IGNvbnRhaW4gdGhlIGBVblJ4YCBwaXBlIGluIHRoZWlyIGVtaXNzaW9uIHN0cmVhbS5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZSBhIGNvbXBvbmVudCB1c2luZyB0aGUgSFRUUCBjbGllbnQgdG8gY2FsbCBhIHNlcnZlci5cbiAqIFdlIGFkZCB0aGUgYFVuUnhgIHBpcGUgdG8gdGhlIHJlc3BvbnNlIG9ic2VydmFibGUgKGBwaXBlKFVuUngodGhpcykpYCkgc28gd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCB0aGUgc3Vic2NyaXB0aW9uIGlzIGNsb3NlZCBhcyB3ZWxsLlxuICpcbiAqIFRoaXMgbWlnaHQgc2VlbSByZWR1bmRhbnQgYmVjYXVzZSB0aGUgYEh0dHBDbGllbnRgIHdpbGwgYXV0b21hdGljYWxseSBjbG9zZSB0aGUgc3Vic2NyaXB0aW9uIGFmdGVyIHRoZSByZXNwb25zZSBidXQgd2hhdCBoYXBwZW4gd2hlblxuICogdGhlIHJlc3BvbnNlIGFycml2ZWQgQUZURVIgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgKHVzZXIgbGVmdCB0aGUgcGFnZSk/XG4gKlxuICogSW4gdGhpcyBjYXNlIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBlbWl0IHRoZSByZXNwb25zZSBhbmQgdGhlIGhhbmRsZXIgd2lsbCBydW4sIHdlIGRvbid0IHdhbnQgdGhhdCFcbiAqXG4gKiBCeSBhcHBseWluZyB0aGUgcGlwZSB3ZSBlbnN1cmUgdGhhdCBub3RoaW5nIHdpbGwgcnVuIG9uY2UgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gKlxuICogVGhlIEJJRyBCT05VUyBoZXJlIGlzIGh0dHAgY2FuY2VsbGF0aW9uLCBvbmNlIGRlc3Ryb3llZCBgVW5SeGAgd2lsbCBjbG9zZSB0aGUgc3Vic2NyaXB0aW9uIHdoaWNoIHdpbGwgY2FuY2VsIHRoZSBIVFRQIHJlcXVlc3QhXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktY21wJyxcbiAqICB0ZW1wbGF0ZTogYGBcbiAqIH0pXG4gKiBAVW5SeCgpIC8vIFdpbGwgdW4tc3Vic2NyaWJlIGFsbCBvcGVuIHN1YnNjcmlwdGlvbnMgd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogICBzdGF0aWMgVVJMID0gJy9zb21lLWVuZHBvaW50JztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogSHR0cENsaWVudCkgeyB9XG4gKlxuICogICBnZXREYXRhKCkge1xuICogICAgIHRoaXMuaHR0cC5nZXQoTXlDb21wb25lbnQuVVJMKVxuICogICAgICAgLnBpcGUoVW5SeCh0aGlzKSkgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHN0cmVhbSBmb3IgYXV0by1raWxsIG9uIGRlc3Ryb3lcbiAqICAgICAgIC5zdWJzY3JpYmUoIHJlc3BvbnNlID0+IHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICogICAgICAgfSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBpcyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIHRoZSBwcmV2aW91cyBvbmUuXG4gKiBBbGwgcGVuZGluZyByZXF1ZXN0IHdpbGwgYmUgY2FuY2VsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYnV0IHdlIHdpbGwgYWxzbyBjYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAqIHdoZW4gYSBuZXcgcmVxdWVzdCBpcyBmaXJlZC5cbiAqXG4gKiBXaXRoIHRoaXMgd2UgZW5zdXJlIHN0YXRlIGFuZCBmbG93IGludGVncml0eSAobm8gcmFjZSBjb25kaXRpb24gYmV0d2VlbiAyIHJlcXVlc3RzKS5cbiAqIFdlIGFsc28gbWFrZSBzdXJlIHRoYXQgcmVzb3VyY2VzIGFyZSBub3Qgd2FzdGVkIChtdWx0aXBsZSByZWR1bmRhbnQgcmVxdWVzdHMuKVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LWNtcCcsXG4gKiAgdGVtcGxhdGU6IGBgXG4gKiB9KVxuICogQFVuUngoKSAvLyBXaWxsIHVuLXN1YnNjcmliZSBhbGwgb3BlbiBzdWJzY3JpcHRpb25zIHdoZW4gY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgc3RhdGljIFVSTCA9ICcvc29tZS1lbmRwb2ludCc7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQpIHsgfVxuICpcbiAqICAgZ2V0RGF0YSgpIHtcbiAqICAgICBVblJ4LmtpbGwodGhpcywgTXlDb21wb25lbnQuVVJMKTsgLy8gS2lsbCAoY2FuY2VsKSBwZW5kaW5nIEhUVFAgcmVxdWVzdHNcbiAqICAgICB0aGlzLmh0dHAuZ2V0KE15Q29tcG9uZW50LlVSTClcbiAqICAgICAgIC5waXBlKFVuUngodGhpcywgTXlDb21wb25lbnQuVVJMKSkgLy8gUmVnaXN0ZXIgdGhlIHN0cmVhbSBmb3IgYXV0by1raWxsIG9uIGRlc3Ryb3kgYW5kIGFkZCBhIGhhbmRsZXIgZm9yIGFkLWhvYyB1bnN1YnNjcmliZVxuICogICAgICAgLnN1YnNjcmliZSggcmVzcG9uc2UgPT4ge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gKiAgICAgICB9KTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQGludGVybmFscmVtYXJrc1xuICogQmFzZWQgb24gd29yayBmcm9tOlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS93MTFrL25nMi1yeC1jb21wb25lbnRkZXN0cm95ZWQvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzXG4gKiAgIC0gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzgwMDgzMzQvYW5ndWxhci1yeGpzLXdoZW4tc2hvdWxkLWktdW5zdWJzY3JpYmUtZnJvbS1zdWJzY3JpcHRpb24vNDExNzcxNjMjNDExNzcxNjNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuUng8VCA9IGFueT4oKTogQ2xhc3NEZWNvcmF0b3I7XG5leHBvcnQgZnVuY3Rpb24gVW5SeDxUPihjb21wb25lbnQ/OiBhbnksIGhhbmRsZXI/OiBhbnkpOiBDbGFzc0RlY29yYXRvciB8ICggKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPiApIHtcbiAgcmV0dXJuIGNvbXBvbmVudFxuICAgID8gdW5yeDxUPihjb21wb25lbnQsIGhhbmRsZXIpXG4gICAgOiBVblJ4LmRlY29yYXRlQ29tcG9uZW50XG4gIDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBVblJ4IHtcbiAgbGV0IGludm9rZVR5cGVTdGFjazogYW55W10gPSBbXTtcbiAgY29uc3Qgb3JpZ2luYWxPbkRlc3Ryb3lGdW5jdGlvblN0b3JlID0gbmV3IE1hcDxhbnksICgpID0+IHZvaWQ+KCk7XG5cbiAgZnVuY3Rpb24gbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgY29uc3QgbGVuID0gaW52b2tlVHlwZVN0YWNrLmxlbmd0aDtcbiAgICBsZXQgdHlwZSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgY29uc3QgbGFzdFR5cGUgPSBpbnZva2VUeXBlU3RhY2tbbGVuIC0gMV07XG4gICAgICBpZiAodHlwZSA9PT0gbGFzdFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VUeXBlU3RhY2sucHVzaCh0eXBlKTtcblxuICAgIGNvbnN0IG9sZE5nT25EZXN0cm95ID0gb3JpZ2luYWxPbkRlc3Ryb3lGdW5jdGlvblN0b3JlLmdldCh0eXBlKTtcbiAgICBpZiAob2xkTmdPbkRlc3Ryb3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9sZE5nT25EZXN0cm95LmFwcGx5KHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGludm9rZVR5cGVTdGFjayA9IFtdO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlVHlwZVN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdW5yeC5raWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZUNvbXBvbmVudCh0YXJnZXQ6IGFueSk6IGFueSB7XG4gICAgY29uc3QgcHJvdG8gPSB0YXJnZXQucHJvdG90eXBlO1xuICAgIGlmIChwcm90by5uZ09uRGVzdHJveSkge1xuICAgICAgb3JpZ2luYWxPbkRlc3Ryb3lGdW5jdGlvblN0b3JlLnNldCh0YXJnZXQsIHByb3RvLm5nT25EZXN0cm95KTtcbiAgICB9XG4gICAgcHJvdG8ubmdPbkRlc3Ryb3kgPSBuZ09uRGVzdHJveTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBcImtpbGxcIiBzaWduYWwgdG8gdGhlIHNwZWNpZmllZCBgY29tcG9uZW50YCBpbnN0YW5jZS5cbiAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJlIGFsbCBzdWJzY3JpcHRpb25zIHdpdGggdGhlIGBVblJ4YCBwaXBlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24ga2lsbChraWxsR3JvdXA6IGFueSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTZW5kIGEgXCJraWxsXCIgc2lnbmFsIHRvIGEgc3BlY2lmaWMgYHRva2VuYCBpbiB0aGUgc3BlY2lmaWVkIGBjb21wb25lbnRgIGluc3RhbmNlLlxuICAgKiBUaGlzIHdpbGwgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmUgYWxsIHN1YnNjcmlwdGlvbnMgd2l0aCB0aGUgYFVuUnhgIHBpcGUgcmVnaXN0ZXJlZCB1bmRlciB0aGUgc3BlY2lmaWVkIGBjb21wb25lbnRgIGluc3RhbmNlIGFuZCBgdG9rZW5gLlxuICAgKlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbGwoY29tcG9uZW50OiBhbnksIC4uLnRva2VuczogYW55W10pOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24ga2lsbChjb21wb25lbnQ6IGFueSwgLi4udG9rZW5zOiBhbnlbXSk6IHZvaWQge1xuICAgIHVucngua2lsbChjb21wb25lbnQsIC4uLnRva2Vucyk7XG4gIH1cblxufVxuIl19