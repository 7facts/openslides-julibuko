/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/**
 * @record
 * @template T
 */
export function Constructor() { }
/**
 * @param {?} base
 * @param {?} mixins
 * @return {?}
 */
function mixObjects(base, mixins) {
    mixins.forEach((/**
     * @param {?} mixin
     * @return {?}
     */
    function (mixin) {
        Object.getOwnPropertyNames(mixin)
            .concat((/** @type {?} */ (Object.getOwnPropertySymbols(mixin))))
            .forEach((/**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            // mixin can't override base behavior, only add
            if (!base.hasOwnProperty(name)) {
                // if its a property descriptor we need to rewire the context
                /** @type {?} */
                var propDesc = Object.getOwnPropertyDescriptor(mixin, name);
                if (propDesc) {
                    Object.defineProperty(base, name, propDesc);
                }
                else {
                    base[name] = mixin[name];
                }
            }
        }));
    }));
}
/**
 * Type-less mixin
 * @param {?} base
 * @param {?} mixin
 * @param {?=} extend
 * @return {?}
 */
export function MixinFree(base, mixin, extend) {
    if (extend === void 0) { extend = 'both'; }
    if (extend === 'proto' || extend === 'both') {
        mixObjects(base.prototype, [mixin.prototype]);
    }
    if (extend === 'class' || extend === 'both') {
        mixObjects(base, [mixin]);
    }
    return (/** @type {?} */ (base));
}
/**
 * A type friendly, class based, mixin functions that mix in instance and static members.
 *
 * EXAMPLE:
 * ```ts
 * class User_ {
 *   id: number;
 *   firstName: string;
 *   lastName: string;
 * }
 *
 * class FullName {
 *   get fullName(): string {
 *     return `${this['firstName']} ${this['lastName']}`;
 *   }
 *
 *   static createId(): number {
 *     // a shady id generator.
 *     return Date.now();
 *   }
 * }
 *
 * export const User = Mixin(User_, FullName);
 * export type User = Mixin<User_, FullName>;
 *
 * // not using it:
 * const user = new User();
 * user.id = User.createId();
 * user.firstName = 'John';
 * user.lastName = 'Doe';
 * console.log(user.fullName); // John Doe
 * ```
 *
 * > To allow Generics in static members (e.g. static createUser(): T) see MixinExt
 *
 * ## Limitations:
 * From a type perspective this utility has limitations.
 *
 * #### You can't (currently) extend a mixed in type.
 * ```ts
 *  export const User = Mixin(User_, FullName);
 *
 *  export class MyExtendedUser extends User { // <- Type Error
 *  }
 * ```
 *
 * ```
 * Type 'Type<User_ & FullName> & typeof FullName & typeof User_' is not a constructor function type.
 * ```
 *
 * The error is misleading, this is a current known TS limitation (see [Github Issue](https://github.com/Microsoft/TypeScript/issues/4890))
 *
 * #### You can use generic inference once, from that point the generic param types for mixin have to be explicitly set:
 * ```ts
 *   export const User = Mixin(User_, FullName); // fine
 *
 *   export const UserNumber2 = Mixin(User, OtherMixin); // Error
 * ```
 *
 * ```
 * The type argument for type parameter 'TBASE' cannot be inferred from the usage.
 * Consider specifying the type arguments explicitly.
 * Type argument candidate 'FullName' is not a valid type argument because it is not a supertype of candidate 'User_'.
 * Property 'fullName' is missing in type 'User_'.
 * ```
 * This might be related to the previous limitation, or not...
 *
 *
 * There are 2 solution:
 *
 * 1) Using the built in interface that supports up to 6 mixins at once. (base + 6)
 * ```ts
 * export const User = Mixin(User_, FullName, OtherMixin); //  FullName, OtherMixin are 2, you can rest param your way for 5 more...
 * export type User = User_ & FullName & OtherMixin
 * ```
 * > This time we cant use `Mixin` to apply the User **type** so we just do it manually...
 *
 * 2) going the long way:
 * ```ts
 *   export const User = Mixin(User_, FullName); // fine
 *
 *   export const UserNumber2 = Mixin<User, typeof User, OtherMixin, typeof OtherMixin>(User, OtherMixin);
 * ```
 *
 *
 * @template TBASE, CBASE, TMIXIN, CMIXIN
 * @param {?} base
 * @param {...?} mixins
 * @return {?}
 */
export function Mixin(base) {
    var mixins = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        mixins[_i - 1] = arguments[_i];
    }
    mixObjects(base.prototype, mixins.map((/**
     * @param {?} m
     * @return {?}
     */
    function (m) { return m.prototype; })));
    mixObjects(base, mixins);
    return (/** @type {?} */ (base));
}
/**
 * For full description see Mixin function.
 *
 * The MixinExt utility does the same as Mixin but also allows adding an extra static type to the intersection.
 *
 * Although static members are mixed in there is a situation that requires an additional static mixin.
 * In a TypeScript class we can not apply generics on static members in the class level, only in a member based level.
 * If we want to return our final mixin type from a static member (e.g: factory) we need a different type.
 *
 * Example:
 * ```ts
 * class User_ {
 *   id: number;
 *   firstName: string;
 *   lastName: string;
 * }
 *
 * class FullName {
 *   get fullName(): string {
 *     return `${this['firstName']} ${this['lastName']}`;
 *   }
 * }
 *
 * const createNew = {
 *   create(): any {
 *     return new User_(); // at this point User_ is fully mixed in.
 *   }
 * }
 *
 * interface CreateStatic<T> {
 *   create(): Mixin<T, FullName>;
 * }
 *
 * export const User = MixinExt(User_, createNew as CreateStatic<User_>, FullName );
 * export type User = Mixin<User_, FullName>;
 * ```
 *
 * > Same as Mixin, MixinExt supports up to 6 mixins but only 1 extra static member.
 * If you need more then 1 just intersect all of your extera static interfaces to 1.
 * @template TBASE, CBASE, SMIXIN, TMIXIN, CMIXIN
 * @param {?} base
 * @param {?} extraStatic Optional object for extra static member, use for static functions that require generics with Generics.
 * @param {...?} mixins
 * @return {?}
 */
export function MixinExt(base, extraStatic) {
    var mixins = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        mixins[_i - 2] = arguments[_i];
    }
    ((/** @type {?} */ (Mixin))).apply(void 0, tslib_1.__spread([base], mixins));
    mixObjects(base, Array.of(extraStatic));
    return (/** @type {?} */ (base));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWl4aW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcGVidWxhL3V0aWxzLyIsInNvdXJjZXMiOlsibGliL21peGluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBLGlDQUVDOzs7Ozs7QUFJRCxTQUFTLFVBQVUsQ0FBQyxJQUFTLEVBQUUsTUFBYTtJQUMxQyxNQUFNLENBQUMsT0FBTzs7OztJQUFDLFVBQUEsS0FBSztRQUNsQixNQUFNLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDO2FBQzlCLE1BQU0sQ0FBQyxtQkFBQSxNQUFNLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDLEVBQU8sQ0FBQzthQUNsRCxPQUFPOzs7O1FBQUMsVUFBQSxJQUFJO1lBQ1gsK0NBQStDO1lBQy9DLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFOzs7b0JBRXhCLFFBQVEsR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQztnQkFDN0QsSUFBSSxRQUFRLEVBQUU7b0JBQ1osTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2lCQUM3QztxQkFBTTtvQkFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUMxQjthQUNGO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDLEVBQUMsQ0FBQztBQUNMLENBQUM7Ozs7Ozs7O0FBS0QsTUFBTSxVQUFVLFNBQVMsQ0FBQyxJQUFTLEVBQUUsS0FBVSxFQUFFLE1BQTJDO0lBQTNDLHVCQUFBLEVBQUEsZUFBMkM7SUFDMUYsSUFBSSxNQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sS0FBSyxNQUFNLEVBQUU7UUFDM0MsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztLQUMvQztJQUNELElBQUksTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFFO1FBQzNDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQzNCO0lBQ0QsT0FBTyxtQkFBQSxJQUFJLEVBQU8sQ0FBQztBQUNyQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUdELE1BQU0sVUFBVSxLQUFLLENBQStCLElBQWdDO0lBQUUsZ0JBQThDO1NBQTlDLFVBQThDLEVBQTlDLHFCQUE4QyxFQUE5QyxJQUE4QztRQUE5QywrQkFBOEM7O0lBQ2xJLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxHQUFHOzs7O0lBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsU0FBUyxFQUFYLENBQVcsRUFBQyxDQUFDLENBQUM7SUFDekQsVUFBVSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN6QixPQUFPLG1CQUFBLElBQUksRUFBTyxDQUFDO0FBQ3JCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvREQsTUFBTSxVQUFVLFFBQVEsQ0FBdUMsSUFBZ0MsRUFBRSxXQUFtQjtJQUFFLGdCQUE4QztTQUE5QyxVQUE4QyxFQUE5QyxxQkFBOEMsRUFBOUMsSUFBOEM7UUFBOUMsK0JBQThDOztJQUNsSyxDQUFDLG1CQUFBLEtBQUssRUFBTyxDQUFDLGlDQUFDLElBQUksR0FBSyxNQUFNLEdBQUU7SUFDaEMsVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDeEMsT0FBTyxtQkFBQSxJQUFJLEVBQU8sQ0FBQztBQUNyQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnN0cnVjdG9yPFQ+IGV4dGVuZHMgRnVuY3Rpb24ge1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDtcbn1cblxuZXhwb3J0IHR5cGUgTWl4aW48QkFTRSwgTUlYSU4+ID0gQkFTRSAmIE1JWElOO1xuXG5mdW5jdGlvbiBtaXhPYmplY3RzKGJhc2U6IGFueSwgbWl4aW5zOiBhbnlbXSk6IHZvaWQge1xuICBtaXhpbnMuZm9yRWFjaChtaXhpbiA9PiB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobWl4aW4pXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWl4aW4pIGFzIGFueSlcbiAgICAgIC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAvLyBtaXhpbiBjYW4ndCBvdmVycmlkZSBiYXNlIGJlaGF2aW9yLCBvbmx5IGFkZFxuICAgICAgICBpZiAoIWJhc2UuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAvLyBpZiBpdHMgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdlIG5lZWQgdG8gcmV3aXJlIHRoZSBjb250ZXh0XG4gICAgICAgICAgY29uc3QgcHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1peGluLCBuYW1lKTtcbiAgICAgICAgICBpZiAocHJvcERlc2MpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlLCBuYW1lLCBwcm9wRGVzYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VbbmFtZV0gPSBtaXhpbltuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUeXBlLWxlc3MgbWl4aW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluRnJlZShiYXNlOiBhbnksIG1peGluOiBhbnksIGV4dGVuZDogJ2NsYXNzJyB8ICdwcm90bycgfCAnYm90aCcgPSAnYm90aCcpOiBhbnkge1xuICBpZiAoZXh0ZW5kID09PSAncHJvdG8nIHx8IGV4dGVuZCA9PT0gJ2JvdGgnKSB7XG4gICAgbWl4T2JqZWN0cyhiYXNlLnByb3RvdHlwZSwgW21peGluLnByb3RvdHlwZV0pO1xuICB9XG4gIGlmIChleHRlbmQgPT09ICdjbGFzcycgfHwgZXh0ZW5kID09PSAnYm90aCcpIHtcbiAgICBtaXhPYmplY3RzKGJhc2UsIFttaXhpbl0pO1xuICB9XG4gIHJldHVybiBiYXNlIGFzIGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1peGluPFRCQVNFLCBDQkFTRSwgVDEsIEMxPihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMT4gJiBDQkFTRSAmIEMxO1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluPFRCQVNFLCBDQkFTRSwgVDEsIEMxLCBUMiwgQzI+KGJhc2U6IENCQVNFICYgQ29uc3RydWN0b3I8VEJBU0U+LCBtMTogQzEgJiBDb25zdHJ1Y3RvcjxUMT4sIG0yOiBDMiAmIENvbnN0cnVjdG9yPFQyPik6IENvbnN0cnVjdG9yPFRCQVNFICYgVDEgJiBUMj4gJiBDQkFTRSAmIEMxICYgQzI7XG5leHBvcnQgZnVuY3Rpb24gTWl4aW48VEJBU0UsIENCQVNFLCBUMSwgQzEsIFQyLCBDMiwgVDMsIEMzPihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+LCBtMjogQzIgJiBDb25zdHJ1Y3RvcjxUMj4sIG0zOiBDMyAmIENvbnN0cnVjdG9yPFQzPik6IENvbnN0cnVjdG9yPFRCQVNFICYgVDEgJiBUMiAmIFQzPiAmIENCQVNFICYgQzEgJiBDMiAmIEMzO1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluPFRCQVNFLCBDQkFTRSwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMywgVDQsIEM0PihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+LCBtMjogQzIgJiBDb25zdHJ1Y3RvcjxUMj4sIG0zOiBDMyAmIENvbnN0cnVjdG9yPFQzPiwgbTQ6IEM0ICYgQ29uc3RydWN0b3I8VDQ+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMSAmIFQyICYgVDMgJiBUND4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMyAmIEM0O1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluPFRCQVNFLCBDQkFTRSwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMywgVDQsIEM0LCBUNSwgQzU+KGJhc2U6IENCQVNFICYgQ29uc3RydWN0b3I8VEJBU0U+LCBtMTogQzEgJiBDb25zdHJ1Y3RvcjxUMT4sIG0yOiBDMiAmIENvbnN0cnVjdG9yPFQyPiwgbTM6IEMzICYgQ29uc3RydWN0b3I8VDM+LCBtNDogQzQgJiBDb25zdHJ1Y3RvcjxUND4sIG01OiBDNSAmIENvbnN0cnVjdG9yPFQ1Pik6IENvbnN0cnVjdG9yPFRCQVNFICYgVDEgJiBUMiAmIFQzICYgVDQgJiBUNT4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMyAmIEM0ICYgQzU7XG5leHBvcnQgZnVuY3Rpb24gTWl4aW48VEJBU0UsIENCQVNFLCBUMSwgQzEsIFQyLCBDMiwgVDMsIEMzLCBUNCwgQzQsIFQ1LCBDNSwgVDYsIEM2PihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+LCBtMjogQzIgJiBDb25zdHJ1Y3RvcjxUMj4sIG0zOiBDMyAmIENvbnN0cnVjdG9yPFQzPiwgbTQ6IEM0ICYgQ29uc3RydWN0b3I8VDQ+LCBtNTogQzUgJiBDb25zdHJ1Y3RvcjxUNT4sIG02OiBDNiAmIENvbnN0cnVjdG9yPFQ2Pik6IENvbnN0cnVjdG9yPFRCQVNFICYgVDEgJiBUMiAmIFQzICYgVDQgJiBUNSAmIFQ2PiAmIENCQVNFICYgQzEgJiBDMiAmIEMzICYgQzQgJiBDNSAmIEM2O1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluPFRCQVNFLCBDQkFTRSwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMywgVDQsIEM0LCBUNSwgQzUsIFQ2LCBDNiwgVDcsIEM3PihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+LCBtMjogQzIgJiBDb25zdHJ1Y3RvcjxUMj4sIG0zOiBDMyAmIENvbnN0cnVjdG9yPFQzPiwgbTQ6IEM0ICYgQ29uc3RydWN0b3I8VDQ+LCBtNTogQzUgJiBDb25zdHJ1Y3RvcjxUNT4sIG02OiBDNiAmIENvbnN0cnVjdG9yPFQ2PiwgbTc6IEM3ICYgQ29uc3RydWN0b3I8VDc+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMSAmIFQyICYgVDMgJiBUNCAmIFQ1ICYgVDYgJiBUNz4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMyAmIEM0ICYgQzUgJiBDNiAmIEM3O1xuLyoqXG4gKiBBIHR5cGUgZnJpZW5kbHksIGNsYXNzIGJhc2VkLCBtaXhpbiBmdW5jdGlvbnMgdGhhdCBtaXggaW4gaW5zdGFuY2UgYW5kIHN0YXRpYyBtZW1iZXJzLlxuICpcbiAqIEVYQU1QTEU6XG4gKiBgYGB0c1xuICogY2xhc3MgVXNlcl8ge1xuICogICBpZDogbnVtYmVyO1xuICogICBmaXJzdE5hbWU6IHN0cmluZztcbiAqICAgbGFzdE5hbWU6IHN0cmluZztcbiAqIH1cbiAqXG4gKiBjbGFzcyBGdWxsTmFtZSB7XG4gKiAgIGdldCBmdWxsTmFtZSgpOiBzdHJpbmcge1xuICogICAgIHJldHVybiBgJHt0aGlzWydmaXJzdE5hbWUnXX0gJHt0aGlzWydsYXN0TmFtZSddfWA7XG4gKiAgIH1cbiAqXG4gKiAgIHN0YXRpYyBjcmVhdGVJZCgpOiBudW1iZXIge1xuICogICAgIC8vIGEgc2hhZHkgaWQgZ2VuZXJhdG9yLlxuICogICAgIHJldHVybiBEYXRlLm5vdygpO1xuICogICB9XG4gKiB9XG4gKlxuICogZXhwb3J0IGNvbnN0IFVzZXIgPSBNaXhpbihVc2VyXywgRnVsbE5hbWUpO1xuICogZXhwb3J0IHR5cGUgVXNlciA9IE1peGluPFVzZXJfLCBGdWxsTmFtZT47XG4gKlxuICogLy8gbm90IHVzaW5nIGl0OlxuICogY29uc3QgdXNlciA9IG5ldyBVc2VyKCk7XG4gKiB1c2VyLmlkID0gVXNlci5jcmVhdGVJZCgpO1xuICogdXNlci5maXJzdE5hbWUgPSAnSm9obic7XG4gKiB1c2VyLmxhc3ROYW1lID0gJ0RvZSc7XG4gKiBjb25zb2xlLmxvZyh1c2VyLmZ1bGxOYW1lKTsgLy8gSm9obiBEb2VcbiAqIGBgYFxuICpcbiAqID4gVG8gYWxsb3cgR2VuZXJpY3MgaW4gc3RhdGljIG1lbWJlcnMgKGUuZy4gc3RhdGljIGNyZWF0ZVVzZXIoKTogVCkgc2VlIE1peGluRXh0XG4gKlxuICogIyMgTGltaXRhdGlvbnM6XG4gKiBGcm9tIGEgdHlwZSBwZXJzcGVjdGl2ZSB0aGlzIHV0aWxpdHkgaGFzIGxpbWl0YXRpb25zLlxuICpcbiAqICMjIyMgWW91IGNhbid0IChjdXJyZW50bHkpIGV4dGVuZCBhIG1peGVkIGluIHR5cGUuXG4gKmBgYHRzXG4gKiAgZXhwb3J0IGNvbnN0IFVzZXIgPSBNaXhpbihVc2VyXywgRnVsbE5hbWUpO1xuICpcbiAqICBleHBvcnQgY2xhc3MgTXlFeHRlbmRlZFVzZXIgZXh0ZW5kcyBVc2VyIHsgLy8gPC0gVHlwZSBFcnJvclxuICogIH1cbiAqYGBgXG4gKlxuICogYGBgXG4gKiBUeXBlICdUeXBlPFVzZXJfICYgRnVsbE5hbWU+ICYgdHlwZW9mIEZ1bGxOYW1lICYgdHlwZW9mIFVzZXJfJyBpcyBub3QgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0eXBlLlxuICogYGBgXG4gKlxuICogVGhlIGVycm9yIGlzIG1pc2xlYWRpbmcsIHRoaXMgaXMgYSBjdXJyZW50IGtub3duIFRTIGxpbWl0YXRpb24gKHNlZSBbR2l0aHViIElzc3VlXShodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ4OTApKVxuICpcbiAqICMjIyMgWW91IGNhbiB1c2UgZ2VuZXJpYyBpbmZlcmVuY2Ugb25jZSwgZnJvbSB0aGF0IHBvaW50IHRoZSBnZW5lcmljIHBhcmFtIHR5cGVzIGZvciBtaXhpbiBoYXZlIHRvIGJlIGV4cGxpY2l0bHkgc2V0OlxuICogYGBgdHNcbiAqICAgZXhwb3J0IGNvbnN0IFVzZXIgPSBNaXhpbihVc2VyXywgRnVsbE5hbWUpOyAvLyBmaW5lXG4gKlxuICogICBleHBvcnQgY29uc3QgVXNlck51bWJlcjIgPSBNaXhpbihVc2VyLCBPdGhlck1peGluKTsgLy8gRXJyb3JcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogVGhlIHR5cGUgYXJndW1lbnQgZm9yIHR5cGUgcGFyYW1ldGVyICdUQkFTRScgY2Fubm90IGJlIGluZmVycmVkIGZyb20gdGhlIHVzYWdlLlxuICogQ29uc2lkZXIgc3BlY2lmeWluZyB0aGUgdHlwZSBhcmd1bWVudHMgZXhwbGljaXRseS5cbiAqIFR5cGUgYXJndW1lbnQgY2FuZGlkYXRlICdGdWxsTmFtZScgaXMgbm90IGEgdmFsaWQgdHlwZSBhcmd1bWVudCBiZWNhdXNlIGl0IGlzIG5vdCBhIHN1cGVydHlwZSBvZiBjYW5kaWRhdGUgJ1VzZXJfJy5cbiAqIFByb3BlcnR5ICdmdWxsTmFtZScgaXMgbWlzc2luZyBpbiB0eXBlICdVc2VyXycuXG4gKiBgYGBcbiAqIFRoaXMgbWlnaHQgYmUgcmVsYXRlZCB0byB0aGUgcHJldmlvdXMgbGltaXRhdGlvbiwgb3Igbm90Li4uXG4gKlxuICpcbiAqIFRoZXJlIGFyZSAyIHNvbHV0aW9uOlxuICpcbiAqIDEpIFVzaW5nIHRoZSBidWlsdCBpbiBpbnRlcmZhY2UgdGhhdCBzdXBwb3J0cyB1cCB0byA2IG1peGlucyBhdCBvbmNlLiAoYmFzZSArIDYpXG4gKiBgYGB0c1xuICogZXhwb3J0IGNvbnN0IFVzZXIgPSBNaXhpbihVc2VyXywgRnVsbE5hbWUsIE90aGVyTWl4aW4pOyAvLyAgRnVsbE5hbWUsIE90aGVyTWl4aW4gYXJlIDIsIHlvdSBjYW4gcmVzdCBwYXJhbSB5b3VyIHdheSBmb3IgNSBtb3JlLi4uXG4gKiBleHBvcnQgdHlwZSBVc2VyID0gVXNlcl8gJiBGdWxsTmFtZSAmIE90aGVyTWl4aW5cbiAqIGBgYFxuICogPiBUaGlzIHRpbWUgd2UgY2FudCB1c2UgYE1peGluYCB0byBhcHBseSB0aGUgVXNlciAqKnR5cGUqKiBzbyB3ZSBqdXN0IGRvIGl0IG1hbnVhbGx5Li4uXG4gKlxuICogMikgZ29pbmcgdGhlIGxvbmcgd2F5OlxuICogYGBgdHNcbiAqICAgZXhwb3J0IGNvbnN0IFVzZXIgPSBNaXhpbihVc2VyXywgRnVsbE5hbWUpOyAvLyBmaW5lXG4gKlxuICogICBleHBvcnQgY29uc3QgVXNlck51bWJlcjIgPSBNaXhpbjxVc2VyLCB0eXBlb2YgVXNlciwgT3RoZXJNaXhpbiwgdHlwZW9mIE90aGVyTWl4aW4+KFVzZXIsIE90aGVyTWl4aW4pO1xuICogYGBgXG4gKlxuICpcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcGFyYW0gbWl4aW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluPFRCQVNFLCBDQkFTRSwgVE1JWElOLCBDTUlYSU4+KGJhc2U6IENCQVNFICYgQ29uc3RydWN0b3I8VEJBU0U+LCAuLi5taXhpbnM6IEFycmF5PENNSVhJTiAmIENvbnN0cnVjdG9yPFRNSVhJTj4+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUTUlYSU4+ICYgQ01JWElOICYgQ0JBU0Uge1xuICBtaXhPYmplY3RzKGJhc2UucHJvdG90eXBlLCBtaXhpbnMubWFwKG0gPT4gbS5wcm90b3R5cGUpKTtcbiAgbWl4T2JqZWN0cyhiYXNlLCBtaXhpbnMpO1xuICByZXR1cm4gYmFzZSBhcyBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkV4dDxUQkFTRSwgQ0JBU0UsIFNNSVhJTiwgVDEsIEMxPihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgZXh0cmFTdGF0aWM6IFNNSVhJTiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMT4gJiBTTUlYSU4gJiBDQkFTRSAmIEMxO1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluRXh0PFRCQVNFLCBDQkFTRSwgU01JWElOLCBUMSwgQzEsIFQyLCBDMj4oYmFzZTogQ0JBU0UgJiBDb25zdHJ1Y3RvcjxUQkFTRT4sIGV4dHJhU3RhdGljOiBTTUlYSU4sIG0xOiBDMSAmIENvbnN0cnVjdG9yPFQxPiwgbTI6IEMyICYgQ29uc3RydWN0b3I8VDI+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMSAmIFQyPiAmIFNNSVhJTiAmIENCQVNFICYgQzEgJiBDMjtcbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkV4dDxUQkFTRSwgQ0JBU0UsIFNNSVhJTiwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMz4oYmFzZTogQ0JBU0UgJiBDb25zdHJ1Y3RvcjxUQkFTRT4sIGV4dHJhU3RhdGljOiBTTUlYSU4sIG0xOiBDMSAmIENvbnN0cnVjdG9yPFQxPiwgbTI6IEMyICYgQ29uc3RydWN0b3I8VDI+LCBtMzogQzMgJiBDb25zdHJ1Y3RvcjxUMz4pOiBDb25zdHJ1Y3RvcjxUQkFTRSAmIFQxICYgVDIgJiBUMz4gJiBTTUlYSU4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMztcbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkV4dDxUQkFTRSwgQ0JBU0UsIFNNSVhJTiwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMywgVDQsIEM0PihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgZXh0cmFTdGF0aWM6IFNNSVhJTiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+LCBtMjogQzIgJiBDb25zdHJ1Y3RvcjxUMj4sIG0zOiBDMyAmIENvbnN0cnVjdG9yPFQzPiwgbTQ6IEM0ICYgQ29uc3RydWN0b3I8VDQ+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMSAmIFQyICYgVDMgJiBUND4gJiBTTUlYSU4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMyAmIEM0O1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluRXh0PFRCQVNFLCBDQkFTRSwgU01JWElOLCBUMSwgQzEsIFQyLCBDMiwgVDMsIEMzLCBUNCwgQzQsIFQ1LCBDNT4oYmFzZTogQ0JBU0UgJiBDb25zdHJ1Y3RvcjxUQkFTRT4sIGV4dHJhU3RhdGljOiBTTUlYSU4sIG0xOiBDMSAmIENvbnN0cnVjdG9yPFQxPiwgbTI6IEMyICYgQ29uc3RydWN0b3I8VDI+LCBtMzogQzMgJiBDb25zdHJ1Y3RvcjxUMz4sIG00OiBDNCAmIENvbnN0cnVjdG9yPFQ0PiwgbTU6IEM1ICYgQ29uc3RydWN0b3I8VDU+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMSAmIFQyICYgVDMgJiBUNCAmIFQ1PiAmIFNNSVhJTiAmIENCQVNFICYgQzEgJiBDMiAmIEMzICYgQzQgJiBDNTtcbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkV4dDxUQkFTRSwgQ0JBU0UsIFNNSVhJTiwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMywgVDQsIEM0LCBUNSwgQzUsIFQ2LCBDNj4oYmFzZTogQ0JBU0UgJiBDb25zdHJ1Y3RvcjxUQkFTRT4sIGV4dHJhU3RhdGljOiBTTUlYSU4sIG0xOiBDMSAmIENvbnN0cnVjdG9yPFQxPiwgbTI6IEMyICYgQ29uc3RydWN0b3I8VDI+LCBtMzogQzMgJiBDb25zdHJ1Y3RvcjxUMz4sIG00OiBDNCAmIENvbnN0cnVjdG9yPFQ0PiwgbTU6IEM1ICYgQ29uc3RydWN0b3I8VDU+LCBtNjogQzYgJiBDb25zdHJ1Y3RvcjxUNj4pOiBDb25zdHJ1Y3RvcjxUQkFTRSAmIFQxICYgVDIgJiBUMyAmIFQ0ICYgVDUgJiBUNj4gJiBTTUlYSU4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMyAmIEM0ICYgQzUgJiBDNjtcbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkV4dDxUQkFTRSwgQ0JBU0UsIFNNSVhJTiwgVDEsIEMxLCBUMiwgQzIsIFQzLCBDMywgVDQsIEM0LCBUNSwgQzUsIFQ2LCBDNiwgVDcsIEM3PihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgZXh0cmFTdGF0aWM6IFNNSVhJTiwgbTE6IEMxICYgQ29uc3RydWN0b3I8VDE+LCBtMjogQzIgJiBDb25zdHJ1Y3RvcjxUMj4sIG0zOiBDMyAmIENvbnN0cnVjdG9yPFQzPiwgbTQ6IEM0ICYgQ29uc3RydWN0b3I8VDQ+LCBtNTogQzUgJiBDb25zdHJ1Y3RvcjxUNT4sIG02OiBDNiAmIENvbnN0cnVjdG9yPFQ2PiwgbTc6IEM3ICYgQ29uc3RydWN0b3I8VDc+KTogQ29uc3RydWN0b3I8VEJBU0UgJiBUMSAmIFQyICYgVDMgJiBUNCAmIFQ1ICYgVDYgJiBUNz4gJiBTTUlYSU4gJiBDQkFTRSAmIEMxICYgQzIgJiBDMyAmIEM0ICYgQzUgJiBDNiAmIEM3O1xuLyoqXG4gKiBGb3IgZnVsbCBkZXNjcmlwdGlvbiBzZWUgTWl4aW4gZnVuY3Rpb24uXG4gKlxuICogVGhlIE1peGluRXh0IHV0aWxpdHkgZG9lcyB0aGUgc2FtZSBhcyBNaXhpbiBidXQgYWxzbyBhbGxvd3MgYWRkaW5nIGFuIGV4dHJhIHN0YXRpYyB0eXBlIHRvIHRoZSBpbnRlcnNlY3Rpb24uXG4gKlxuICogQWx0aG91Z2ggc3RhdGljIG1lbWJlcnMgYXJlIG1peGVkIGluIHRoZXJlIGlzIGEgc2l0dWF0aW9uIHRoYXQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzdGF0aWMgbWl4aW4uXG4gKiBJbiBhIFR5cGVTY3JpcHQgY2xhc3Mgd2UgY2FuIG5vdCBhcHBseSBnZW5lcmljcyBvbiBzdGF0aWMgbWVtYmVycyBpbiB0aGUgY2xhc3MgbGV2ZWwsIG9ubHkgaW4gYSBtZW1iZXIgYmFzZWQgbGV2ZWwuXG4gKiBJZiB3ZSB3YW50IHRvIHJldHVybiBvdXIgZmluYWwgbWl4aW4gdHlwZSBmcm9tIGEgc3RhdGljIG1lbWJlciAoZS5nOiBmYWN0b3J5KSB3ZSBuZWVkIGEgZGlmZmVyZW50IHR5cGUuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjbGFzcyBVc2VyXyB7XG4gKiAgIGlkOiBudW1iZXI7XG4gKiAgIGZpcnN0TmFtZTogc3RyaW5nO1xuICogICBsYXN0TmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIGNsYXNzIEZ1bGxOYW1lIHtcbiAqICAgZ2V0IGZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gKiAgICAgcmV0dXJuIGAke3RoaXNbJ2ZpcnN0TmFtZSddfSAke3RoaXNbJ2xhc3ROYW1lJ119YDtcbiAqICAgfVxuICogfVxuICpcbiAqIGNvbnN0IGNyZWF0ZU5ldyA9IHtcbiAqICAgY3JlYXRlKCk6IGFueSB7XG4gKiAgICAgcmV0dXJuIG5ldyBVc2VyXygpOyAvLyBhdCB0aGlzIHBvaW50IFVzZXJfIGlzIGZ1bGx5IG1peGVkIGluLlxuICogICB9XG4gKiB9XG4gKlxuICogaW50ZXJmYWNlIENyZWF0ZVN0YXRpYzxUPiB7XG4gKiAgIGNyZWF0ZSgpOiBNaXhpbjxULCBGdWxsTmFtZT47XG4gKiB9XG4gKlxuICogZXhwb3J0IGNvbnN0IFVzZXIgPSBNaXhpbkV4dChVc2VyXywgY3JlYXRlTmV3IGFzIENyZWF0ZVN0YXRpYzxVc2VyXz4sIEZ1bGxOYW1lICk7XG4gKiBleHBvcnQgdHlwZSBVc2VyID0gTWl4aW48VXNlcl8sIEZ1bGxOYW1lPjtcbiAqIGBgYFxuICpcbiAqID4gU2FtZSBhcyBNaXhpbiwgTWl4aW5FeHQgc3VwcG9ydHMgdXAgdG8gNiBtaXhpbnMgYnV0IG9ubHkgMSBleHRyYSBzdGF0aWMgbWVtYmVyLlxuICogSWYgeW91IG5lZWQgbW9yZSB0aGVuIDEganVzdCBpbnRlcnNlY3QgYWxsIG9mIHlvdXIgZXh0ZXJhIHN0YXRpYyBpbnRlcmZhY2VzIHRvIDEuXG4gKiBAcGFyYW0gYmFzZVxuICogQHBhcmFtIGV4dHJhU3RhdGljIE9wdGlvbmFsIG9iamVjdCBmb3IgZXh0cmEgc3RhdGljIG1lbWJlciwgdXNlIGZvciBzdGF0aWMgZnVuY3Rpb25zIHRoYXQgcmVxdWlyZSBnZW5lcmljcyB3aXRoIEdlbmVyaWNzLlxuICogQHBhcmFtIG1peGluc1xuICovXG5leHBvcnQgZnVuY3Rpb24gTWl4aW5FeHQ8VEJBU0UsIENCQVNFLCBTTUlYSU4sIFRNSVhJTiwgQ01JWElOPihiYXNlOiBDQkFTRSAmIENvbnN0cnVjdG9yPFRCQVNFPiwgZXh0cmFTdGF0aWM6IFNNSVhJTiwgLi4ubWl4aW5zOiBBcnJheTxDTUlYSU4gJiBDb25zdHJ1Y3RvcjxUTUlYSU4+Pik6IENvbnN0cnVjdG9yPFRCQVNFICYgVE1JWElOPiAmIENCQVNFICYgU01JWElOICYgQ01JWElOIHtcbiAgKE1peGluIGFzIGFueSkoYmFzZSwgLi4ubWl4aW5zKTtcbiAgbWl4T2JqZWN0cyhiYXNlLCBBcnJheS5vZihleHRyYVN0YXRpYykpO1xuICByZXR1cm4gYmFzZSBhcyBhbnk7XG59XG4iXX0=