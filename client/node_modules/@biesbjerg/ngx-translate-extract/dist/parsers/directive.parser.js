Object.defineProperty(exports, "__esModule", { value: true });
const translation_collection_1 = require("../utils/translation.collection");
const utils_1 = require("../utils/utils");
const compiler_1 = require("@angular/compiler");
class DirectiveParser {
    extract(source, filePath) {
        if (filePath && utils_1.isPathAngularComponent(filePath)) {
            source = utils_1.extractComponentInlineTemplate(source);
        }
        let collection = new translation_collection_1.TranslationCollection();
        const nodes = this.parseTemplate(source, filePath);
        this.getTranslatableElements(nodes).forEach((element) => {
            const key = this.getElementTranslateAttrValue(element) || this.getElementContent(element);
            collection = collection.add(key);
        });
        return collection;
    }
    getTranslatableElements(nodes) {
        return nodes
            .filter((element) => this.isElement(element))
            .reduce((result, element) => {
            return result.concat(this.findChildrenElements(element));
        }, [])
            .filter((element) => this.isTranslatable(element));
    }
    findChildrenElements(node) {
        if (!this.isElement(node)) {
            return [];
        }
        if (this.isTranslatable(node)) {
            return [node];
        }
        return node.children.reduce((result, childNode) => {
            if (this.isElement(childNode)) {
                const children = this.findChildrenElements(childNode);
                return result.concat(children);
            }
            return result;
        }, [node]);
    }
    parseTemplate(template, path) {
        return compiler_1.parseTemplate(template, path).nodes;
    }
    isElement(node) {
        return (node === null || node === void 0 ? void 0 : node.attributes) && (node === null || node === void 0 ? void 0 : node.children);
    }
    isTranslatable(node) {
        if (this.isElement(node) && node.attributes.some((attribute) => attribute.name === 'translate')) {
            return true;
        }
        return false;
    }
    getElementTranslateAttrValue(element) {
        var _a;
        const attr = element.attributes.find((attribute) => attribute.name === 'translate');
        return (_a = attr === null || attr === void 0 ? void 0 : attr.value) !== null && _a !== void 0 ? _a : '';
    }
    getElementContent(element) {
        const content = element.sourceSpan.start.file.content;
        const start = element.startSourceSpan.end.offset;
        const end = element.endSourceSpan.start.offset;
        const val = content.substring(start, end);
        return this.cleanKey(val);
    }
    cleanKey(val) {
        return val.replace(/\r?\n|\r|\t/g, '').trim();
    }
}
exports.DirectiveParser = DirectiveParser;
//# sourceMappingURL=directive.parser.js.map