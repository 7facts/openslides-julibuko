import { Observable } from 'rxjs';
import { StorageMap } from './storage-map.service';
import { JSONSchema, JSONSchemaBoolean, JSONSchemaInteger, JSONSchemaNumber, JSONSchemaString, JSONSchemaArrayOf } from '../validation';
import * as ɵngcc0 from '@angular/core';
export declare class LocalStorage {
    protected storageMap: StorageMap;
    /**
     * Number of items in storage wrapped in an `Observable`
     *
     * @example
     * this.localStorage.length.subscribe((length) => {
     *   console.log(length);
     * });
     */
    get length(): Observable<number>;
    constructor(storageMap: StorageMap);
    /**
     * Get an item value in storage.
     * The signature has many overloads due to validation, **please refer to the documentation.**
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/VALIDATION.md}
     * @param key The item's key
     * @param schema Optional JSON schema to validate the data.
     * **Note you must pass the schema directly as the second argument.**
     * **Passing the schema in an object `{ schema }` is deprecated and only here**
     * **for backward compatibility: it will be removed in a future version.**
     * @returns The item's value if the key exists, `null` otherwise, wrapped in a RxJS `Observable`
     *
     * @example
     * this.localStorage.get('key', { type: 'string' }).subscribe((result) => {
     *   result; // string or null
     * });
     *
     * @example
     * interface User {
     *   firstName: string;
     *   lastName?: string;
     * }
     *
     * const schema = {
     *   type: 'object',
     *   properties: {
     *     firstName: { type: 'string' },
     *     lastName: { type: 'string' },
     *   },
     *   required: ['firstName']
     * };
     *
     * this.localStorage.get<User>('user', schema).subscribe((user) => {
     *   if (user) {
     *     user.firstName;
     *   }
     * });
     */
    getItem<T = string>(key: string, schema: JSONSchemaString): Observable<string | null>;
    getItem<T = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<number | null>;
    getItem<T = boolean>(key: string, schema: JSONSchemaBoolean): Observable<boolean | null>;
    getItem<T = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<string[] | null>;
    getItem<T = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<number[] | null>;
    getItem<T = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<boolean[] | null>;
    getItem<T = unknown>(key: string, schema: JSONSchema | {
        schema: JSONSchema;
    }): Observable<T | null>;
    getItem<T = unknown>(key: string, schema?: JSONSchema): Observable<unknown>;
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.set('key', 'value').subscribe(() => {});
     */
    setItem(key: string, data: unknown, schema?: JSONSchema): Observable<boolean>;
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.delete('key').subscribe(() => {});
     */
    removeItem(key: string): Observable<boolean>;
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.clear().subscribe(() => {});
     */
    clear(): Observable<boolean>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LocalStorage, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtc3RvcmFnZS5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImxvY2FsLXN0b3JhZ2Uuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN0b3JhZ2VNYXAgfSBmcm9tICcuL3N0b3JhZ2UtbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgSlNPTlNjaGVtYSwgSlNPTlNjaGVtYUJvb2xlYW4sIEpTT05TY2hlbWFJbnRlZ2VyLCBKU09OU2NoZW1hTnVtYmVyLCBKU09OU2NoZW1hU3RyaW5nLCBKU09OU2NoZW1hQXJyYXlPZiB9IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTG9jYWxTdG9yYWdlIHtcbiAgICBwcm90ZWN0ZWQgc3RvcmFnZU1hcDogU3RvcmFnZU1hcDtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gc3RvcmFnZSB3cmFwcGVkIGluIGFuIGBPYnNlcnZhYmxlYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0aGlzLmxvY2FsU3RvcmFnZS5sZW5ndGguc3Vic2NyaWJlKChsZW5ndGgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGxlbmd0aCk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpOiBPYnNlcnZhYmxlPG51bWJlcj47XG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZU1hcDogU3RvcmFnZU1hcCk7XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICAgKiBUaGUgc2lnbmF0dXJlIGhhcyBtYW55IG92ZXJsb2FkcyBkdWUgdG8gdmFsaWRhdGlvbiwgKipwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uKipcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFzdGVyL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YS5cbiAgICAgKiAqKk5vdGUgeW91IG11c3QgcGFzcyB0aGUgc2NoZW1hIGRpcmVjdGx5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuKipcbiAgICAgKiAqKlBhc3NpbmcgdGhlIHNjaGVtYSBpbiBhbiBvYmplY3QgYHsgc2NoZW1hIH1gIGlzIGRlcHJlY2F0ZWQgYW5kIG9ubHkgaGVyZSoqXG4gICAgICogKipmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTogaXQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uKipcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBgbnVsbGAgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0KCdrZXknLCB7IHR5cGU6ICdzdHJpbmcnIH0pLnN1YnNjcmliZSgocmVzdWx0KSA9PiB7XG4gICAgICogICByZXN1bHQ7IC8vIHN0cmluZyBvciBudWxsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGludGVyZmFjZSBVc2VyIHtcbiAgICAgKiAgIGZpcnN0TmFtZTogc3RyaW5nO1xuICAgICAqICAgbGFzdE5hbWU/OiBzdHJpbmc7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3Qgc2NoZW1hID0ge1xuICAgICAqICAgdHlwZTogJ29iamVjdCcsXG4gICAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAgICogICAgIGZpcnN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAqICAgICBsYXN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHJlcXVpcmVkOiBbJ2ZpcnN0TmFtZSddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHRoaXMubG9jYWxTdG9yYWdlLmdldDxVc2VyPigndXNlcicsIHNjaGVtYSkuc3Vic2NyaWJlKCh1c2VyKSA9PiB7XG4gICAgICogICBpZiAodXNlcikge1xuICAgICAqICAgICB1c2VyLmZpcnN0TmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBnZXRJdGVtPFQgPSBzdHJpbmc+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFTdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZyB8IG51bGw+O1xuICAgIGdldEl0ZW08VCA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxudW1iZXIgfCBudWxsPjtcbiAgICBnZXRJdGVtPFQgPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8Ym9vbGVhbiB8IG51bGw+O1xuICAgIGdldEl0ZW08VCA9IHN0cmluZ1tdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hU3RyaW5nPik6IE9ic2VydmFibGU8c3RyaW5nW10gfCBudWxsPjtcbiAgICBnZXRJdGVtPFQgPSBudW1iZXJbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyPik6IE9ic2VydmFibGU8bnVtYmVyW10gfCBudWxsPjtcbiAgICBnZXRJdGVtPFQgPSBib29sZWFuW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFCb29sZWFuPik6IE9ic2VydmFibGU8Ym9vbGVhbltdIHwgbnVsbD47XG4gICAgZ2V0SXRlbTxUID0gdW5rbm93bj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYSB8IHtcbiAgICAgICAgc2NoZW1hOiBKU09OU2NoZW1hO1xuICAgIH0pOiBPYnNlcnZhYmxlPFQgfCBudWxsPjtcbiAgICBnZXRJdGVtPFQgPSB1bmtub3duPihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5rbm93bj47XG4gICAgLyoqXG4gICAgICogU2V0IGFuIGl0ZW0gaW4gc3RvcmFnZS5cbiAgICAgKiBOb3RlIHRoYXQgc2V0dGluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCByZW1vdmUgdGhlIGl0ZW0gdG8gYXZvaWQgc29tZSBicm93c2VycyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhXG4gICAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0aGlzLmxvY2FsU3RvcmFnZS5zZXQoJ2tleScsICd2YWx1ZScpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAgICovXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgZGF0YTogdW5rbm93biwgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGl0ZW0gaW4gc3RvcmFnZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRoaXMubG9jYWxTdG9yYWdlLmRlbGV0ZSgna2V5Jykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICAgKi9cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIGl0ZW1zIGluIHN0b3JhZ2VcbiAgICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRoaXMubG9jYWxTdG9yYWdlLmNsZWFyKCkuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICAgKi9cbiAgICBjbGVhcigpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xufVxuIl19