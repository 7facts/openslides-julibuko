/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Subject } from 'rxjs';
import { ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { EditRef } from './edit-ref';
/** Options for what do to when the user clicks outside of an edit lens. */
import * as ɵngcc0 from '@angular/core';
export declare type PopoverEditClickOutBehavior = 'close' | 'submit' | 'noop';
/**
 * A directive that attaches to a form within the edit lens.
 * It coordinates the form state with the table-wide edit system and handles
 * closing the edit lens when the form is submitted or the user clicks
 * out.
 */
export declare class CdkEditControl<FormValue> implements OnDestroy, OnInit {
    protected readonly elementRef: ElementRef;
    readonly editRef: EditRef<FormValue>;
    protected readonly destroyed: Subject<void>;
    /**
     * Specifies what should happen when the user clicks outside of the edit lens.
     * The default behavior is to close the lens without submitting the form.
     */
    clickOutBehavior: PopoverEditClickOutBehavior;
    /**
     * A two-way binding for storing unsubmitted form state. If not provided
     * then form state will be discarded on close. The PeristBy directive is offered
     * as a convenient shortcut for these bindings.
     */
    preservedFormValue?: FormValue;
    readonly preservedFormValueChange: EventEmitter<FormValue>;
    /**
     * Determines whether the lens will close on form submit if the form is not in a valid
     * state. By default the lens will remain open.
     */
    ignoreSubmitUnlessValid: boolean;
    constructor(elementRef: ElementRef, editRef: EditRef<FormValue>);
    ngOnInit(): void;
    ngOnDestroy(): void;
    /**
     * Called when the form submits. If ignoreSubmitUnlessValid is true, checks
     * the form for validity before proceeding.
     * Updates the revert state with the latest submitted value then closes the edit.
     */
    handleFormSubmit(): void;
    /** Called on Escape keyup. Closes the edit. */
    close(): void;
    /**
     * Called on click anywhere in the document.
     * If the click was outside of the lens, trigger the specified click out behavior.
     */
    handlePossibleClickOut(evt: Event): void;
    _handleKeydown(event: KeyboardEvent): void;
    /** Triggers submit on tab out if clickOutBehavior is 'submit'. */
    private _handleBlur;
    private _triggerFormSubmit;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkEditControl<any>, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkEditControl<any>, "form[cdkEditControl]", never, { "clickOutBehavior": "cdkEditControlClickOutBehavior"; "preservedFormValue": "cdkEditControlPreservedFormValue"; "ignoreSubmitUnlessValid": "cdkEditControlIgnoreSubmitUnlessValid"; }, { "preservedFormValueChange": "cdkEditControlPreservedFormValueChange"; }, never>;
}
/** Reverts the form to its initial or previously submitted state on click. */
export declare class CdkEditRevert<FormValue> {
    protected readonly editRef: EditRef<FormValue>;
    /** Type of the button. Defaults to `button` to avoid accident form submits. */
    type: string;
    constructor(editRef: EditRef<FormValue>);
    revertEdit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkEditRevert<any>, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkEditRevert<any>, "button[cdkEditRevert]", never, { "type": "type"; }, {}, never>;
}
/** Closes the lens on click. */
export declare class CdkEditClose<FormValue> {
    protected readonly elementRef: ElementRef<HTMLElement>;
    protected readonly editRef: EditRef<FormValue>;
    constructor(elementRef: ElementRef<HTMLElement>, editRef: EditRef<FormValue>);
    closeEdit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkEditClose<any>, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkEditClose<any>, "[cdkEditClose]", never, {}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVucy1kaXJlY3RpdmVzLmQudHMiLCJzb3VyY2VzIjpbImxlbnMtZGlyZWN0aXZlcy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVkaXRSZWYgfSBmcm9tICcuL2VkaXQtcmVmJztcbi8qKiBPcHRpb25zIGZvciB3aGF0IGRvIHRvIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG91dHNpZGUgb2YgYW4gZWRpdCBsZW5zLiAqL1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBQb3BvdmVyRWRpdENsaWNrT3V0QmVoYXZpb3IgPSAnY2xvc2UnIHwgJ3N1Ym1pdCcgfCAnbm9vcCc7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgYXR0YWNoZXMgdG8gYSBmb3JtIHdpdGhpbiB0aGUgZWRpdCBsZW5zLlxuICogSXQgY29vcmRpbmF0ZXMgdGhlIGZvcm0gc3RhdGUgd2l0aCB0aGUgdGFibGUtd2lkZSBlZGl0IHN5c3RlbSBhbmQgaGFuZGxlc1xuICogY2xvc2luZyB0aGUgZWRpdCBsZW5zIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0dGVkIG9yIHRoZSB1c2VyIGNsaWNrc1xuICogb3V0LlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDZGtFZGl0Q29udHJvbDxGb3JtVmFsdWU+IGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQge1xuICAgIHByb3RlY3RlZCByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmO1xuICAgIHJlYWRvbmx5IGVkaXRSZWY6IEVkaXRSZWY8Rm9ybVZhbHVlPjtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB3aGF0IHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgZWRpdCBsZW5zLlxuICAgICAqIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNsb3NlIHRoZSBsZW5zIHdpdGhvdXQgc3VibWl0dGluZyB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBjbGlja091dEJlaGF2aW9yOiBQb3BvdmVyRWRpdENsaWNrT3V0QmVoYXZpb3I7XG4gICAgLyoqXG4gICAgICogQSB0d28td2F5IGJpbmRpbmcgZm9yIHN0b3JpbmcgdW5zdWJtaXR0ZWQgZm9ybSBzdGF0ZS4gSWYgbm90IHByb3ZpZGVkXG4gICAgICogdGhlbiBmb3JtIHN0YXRlIHdpbGwgYmUgZGlzY2FyZGVkIG9uIGNsb3NlLiBUaGUgUGVyaXN0QnkgZGlyZWN0aXZlIGlzIG9mZmVyZWRcbiAgICAgKiBhcyBhIGNvbnZlbmllbnQgc2hvcnRjdXQgZm9yIHRoZXNlIGJpbmRpbmdzLlxuICAgICAqL1xuICAgIHByZXNlcnZlZEZvcm1WYWx1ZT86IEZvcm1WYWx1ZTtcbiAgICByZWFkb25seSBwcmVzZXJ2ZWRGb3JtVmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGb3JtVmFsdWU+O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbGVucyB3aWxsIGNsb3NlIG9uIGZvcm0gc3VibWl0IGlmIHRoZSBmb3JtIGlzIG5vdCBpbiBhIHZhbGlkXG4gICAgICogc3RhdGUuIEJ5IGRlZmF1bHQgdGhlIGxlbnMgd2lsbCByZW1haW4gb3Blbi5cbiAgICAgKi9cbiAgICBpZ25vcmVTdWJtaXRVbmxlc3NWYWxpZDogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBlZGl0UmVmOiBFZGl0UmVmPEZvcm1WYWx1ZT4pO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZm9ybSBzdWJtaXRzLiBJZiBpZ25vcmVTdWJtaXRVbmxlc3NWYWxpZCBpcyB0cnVlLCBjaGVja3NcbiAgICAgKiB0aGUgZm9ybSBmb3IgdmFsaWRpdHkgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgICogVXBkYXRlcyB0aGUgcmV2ZXJ0IHN0YXRlIHdpdGggdGhlIGxhdGVzdCBzdWJtaXR0ZWQgdmFsdWUgdGhlbiBjbG9zZXMgdGhlIGVkaXQuXG4gICAgICovXG4gICAgaGFuZGxlRm9ybVN1Ym1pdCgpOiB2b2lkO1xuICAgIC8qKiBDYWxsZWQgb24gRXNjYXBlIGtleXVwLiBDbG9zZXMgdGhlIGVkaXQuICovXG4gICAgY2xvc2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gY2xpY2sgYW55d2hlcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqIElmIHRoZSBjbGljayB3YXMgb3V0c2lkZSBvZiB0aGUgbGVucywgdHJpZ2dlciB0aGUgc3BlY2lmaWVkIGNsaWNrIG91dCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBoYW5kbGVQb3NzaWJsZUNsaWNrT3V0KGV2dDogRXZlbnQpOiB2b2lkO1xuICAgIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICAvKiogVHJpZ2dlcnMgc3VibWl0IG9uIHRhYiBvdXQgaWYgY2xpY2tPdXRCZWhhdmlvciBpcyAnc3VibWl0Jy4gKi9cbiAgICBwcml2YXRlIF9oYW5kbGVCbHVyO1xuICAgIHByaXZhdGUgX3RyaWdnZXJGb3JtU3VibWl0O1xufVxuLyoqIFJldmVydHMgdGhlIGZvcm0gdG8gaXRzIGluaXRpYWwgb3IgcHJldmlvdXNseSBzdWJtaXR0ZWQgc3RhdGUgb24gY2xpY2suICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDZGtFZGl0UmV2ZXJ0PEZvcm1WYWx1ZT4ge1xuICAgIHByb3RlY3RlZCByZWFkb25seSBlZGl0UmVmOiBFZGl0UmVmPEZvcm1WYWx1ZT47XG4gICAgLyoqIFR5cGUgb2YgdGhlIGJ1dHRvbi4gRGVmYXVsdHMgdG8gYGJ1dHRvbmAgdG8gYXZvaWQgYWNjaWRlbnQgZm9ybSBzdWJtaXRzLiAqL1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBjb25zdHJ1Y3RvcihlZGl0UmVmOiBFZGl0UmVmPEZvcm1WYWx1ZT4pO1xuICAgIHJldmVydEVkaXQoKTogdm9pZDtcbn1cbi8qKiBDbG9zZXMgdGhlIGxlbnMgb24gY2xpY2suICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDZGtFZGl0Q2xvc2U8Rm9ybVZhbHVlPiB7XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuICAgIHByb3RlY3RlZCByZWFkb25seSBlZGl0UmVmOiBFZGl0UmVmPEZvcm1WYWx1ZT47XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIGVkaXRSZWY6IEVkaXRSZWY8Rm9ybVZhbHVlPik7XG4gICAgY2xvc2VFZGl0KCk6IHZvaWQ7XG59XG4iXX0=