/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NumberInput } from '@angular/cdk/coercion';
import { ListRange } from '@angular/cdk/collections';
import { CdkVirtualScrollViewport, VirtualScrollStrategy } from '@angular/cdk/scrolling';
import { OnChanges } from '@angular/core';
import { Observable } from 'rxjs';
/**
 * A class that tracks the size of items that have been seen and uses it to estimate the average
 * item size.
 */
import * as ɵngcc0 from '@angular/core';
export declare class ItemSizeAverager {
    /** The total amount of weight behind the current average. */
    private _totalWeight;
    /** The current average item size. */
    private _averageItemSize;
    /** The default size to use for items when no data is available. */
    private _defaultItemSize;
    /** @param defaultItemSize The default size to use for items when no data is available. */
    constructor(defaultItemSize?: number);
    /** Returns the average item size. */
    getAverageItemSize(): number;
    /**
     * Adds a measurement sample for the estimator to consider.
     * @param range The measured range.
     * @param size The measured size of the given range in pixels.
     */
    addSample(range: ListRange, size: number): void;
    /** Resets the averager. */
    reset(): void;
}
/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */
export declare class AutoSizeVirtualScrollStrategy implements VirtualScrollStrategy {
    /** @docs-private Implemented as part of VirtualScrollStrategy. */
    scrolledIndexChange: Observable<number>;
    /** The attached viewport. */
    private _viewport;
    /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
    private _minBufferPx;
    /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
    private _maxBufferPx;
    /** The estimator used to estimate the size of unseen items. */
    private _averager;
    /** The last measured scroll offset of the viewport. */
    private _lastScrollOffset;
    /** The last measured size of the rendered content in the viewport. */
    private _lastRenderedContentSize;
    /** The last measured size of the rendered content in the viewport. */
    private _lastRenderedContentOffset;
    /**
     * The number of consecutive cycles where removing extra items has failed. Failure here means that
     * we estimated how many items we could safely remove, but our estimate turned out to be too much
     * and it wasn't safe to remove that many elements.
     */
    private _removalFailures;
    /**
     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).
     *     If the amount of buffer dips below this number, more items will be rendered.
     * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.
     *     If the actual amount turns out to be less it will not necessarily trigger an additional
     *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).
     * @param averager The averager used to estimate the size of unseen items.
     */
    constructor(minBufferPx: number, maxBufferPx: number, averager?: ItemSizeAverager);
    /**
     * Attaches this scroll strategy to a viewport.
     * @param viewport The viewport to attach this strategy to.
     */
    attach(viewport: CdkVirtualScrollViewport): void;
    /** Detaches this scroll strategy from the currently attached viewport. */
    detach(): void;
    /** @docs-private Implemented as part of VirtualScrollStrategy. */
    onContentScrolled(): void;
    /** @docs-private Implemented as part of VirtualScrollStrategy. */
    onDataLengthChanged(): void;
    /** @docs-private Implemented as part of VirtualScrollStrategy. */
    onContentRendered(): void;
    /** @docs-private Implemented as part of VirtualScrollStrategy. */
    onRenderedOffsetChanged(): void;
    /** Scroll to the offset for the given index. */
    scrollToIndex(): void;
    /**
     * Update the buffer parameters.
     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).
     * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in
     *     pixels).
     */
    updateBufferSize(minBufferPx: number, maxBufferPx: number): void;
    /** Update the rendered content after the user scrolls. */
    private _updateRenderedContentAfterScroll;
    /**
     * Checks the size of the currently rendered content and uses it to update the estimated item size
     * and estimated total content size.
     */
    private _checkRenderedContentSize;
    /** Checks the currently rendered content offset and saves the value for later use. */
    private _checkRenderedContentOffset;
    /**
     * Recalculates the rendered content based on our estimate of what should be shown at the current
     * scroll offset.
     */
    private _renderContentForCurrentOffset;
    /**
     * Gets the visible range of data for the given start index. If the start index is too close to
     * the end of the list it may be backed up to ensure the estimated size of the range is enough to
     * fill the viewport.
     * Note: must not be called if `this._viewport` is null
     * @param startIndex The index to start the range at
     * @return a range estimated to be large enough to fill the viewport when rendered.
     */
    private _getVisibleRangeForIndex;
    /**
     * Expand the given range by the given amount in either direction.
     * Note: must not be called if `this._viewport` is null
     * @param range The range to expand
     * @param expandStart The number of items to expand the start of the range by.
     * @param expandEnd The number of items to expand the end of the range by.
     * @return The expanded range.
     */
    private _expandRange;
    /** Update the viewport's total content size. */
    private _updateTotalContentSize;
}
/**
 * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created
 * `AutoSizeVirtualScrollStrategy` from the given directive.
 * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the
 *     `AutoSizeVirtualScrollStrategy` from.
 */
export declare function _autoSizeVirtualScrollStrategyFactory(autoSizeDir: CdkAutoSizeVirtualScroll): AutoSizeVirtualScrollStrategy;
/** A virtual scroll strategy that supports unknown or dynamic size items. */
export declare class CdkAutoSizeVirtualScroll implements OnChanges {
    /**
     * The minimum amount of buffer rendered beyond the viewport (in pixels).
     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
     */
    get minBufferPx(): number;
    set minBufferPx(value: number);
    _minBufferPx: number;
    /**
     * The number of pixels worth of buffer to shoot for when rendering new items.
     * If the actual amount turns out to be less it will not necessarily trigger an additional
     * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).
     * Defaults to 200px.
     */
    get maxBufferPx(): number;
    set maxBufferPx(value: number);
    _maxBufferPx: number;
    /** The scroll strategy used by this directive. */
    _scrollStrategy: AutoSizeVirtualScrollStrategy;
    ngOnChanges(): void;
    static ngAcceptInputType_minBufferPx: NumberInput;
    static ngAcceptInputType_maxBufferPx: NumberInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkAutoSizeVirtualScroll, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkAutoSizeVirtualScroll, "cdk-virtual-scroll-viewport[autosize]", never, { "minBufferPx": "minBufferPx"; "maxBufferPx": "maxBufferPx"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1zaXplLXZpcnR1YWwtc2Nyb2xsLmQudHMiLCJzb3VyY2VzIjpbImF1dG8tc2l6ZS12aXJ0dWFsLXNjcm9sbC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgTnVtYmVySW5wdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgTGlzdFJhbmdlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7IENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCwgVmlydHVhbFNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbi8qKlxuICogQSBjbGFzcyB0aGF0IHRyYWNrcyB0aGUgc2l6ZSBvZiBpdGVtcyB0aGF0IGhhdmUgYmVlbiBzZWVuIGFuZCB1c2VzIGl0IHRvIGVzdGltYXRlIHRoZSBhdmVyYWdlXG4gKiBpdGVtIHNpemUuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEl0ZW1TaXplQXZlcmFnZXIge1xuICAgIC8qKiBUaGUgdG90YWwgYW1vdW50IG9mIHdlaWdodCBiZWhpbmQgdGhlIGN1cnJlbnQgYXZlcmFnZS4gKi9cbiAgICBwcml2YXRlIF90b3RhbFdlaWdodDtcbiAgICAvKiogVGhlIGN1cnJlbnQgYXZlcmFnZSBpdGVtIHNpemUuICovXG4gICAgcHJpdmF0ZSBfYXZlcmFnZUl0ZW1TaXplO1xuICAgIC8qKiBUaGUgZGVmYXVsdCBzaXplIHRvIHVzZSBmb3IgaXRlbXMgd2hlbiBubyBkYXRhIGlzIGF2YWlsYWJsZS4gKi9cbiAgICBwcml2YXRlIF9kZWZhdWx0SXRlbVNpemU7XG4gICAgLyoqIEBwYXJhbSBkZWZhdWx0SXRlbVNpemUgVGhlIGRlZmF1bHQgc2l6ZSB0byB1c2UgZm9yIGl0ZW1zIHdoZW4gbm8gZGF0YSBpcyBhdmFpbGFibGUuICovXG4gICAgY29uc3RydWN0b3IoZGVmYXVsdEl0ZW1TaXplPzogbnVtYmVyKTtcbiAgICAvKiogUmV0dXJucyB0aGUgYXZlcmFnZSBpdGVtIHNpemUuICovXG4gICAgZ2V0QXZlcmFnZUl0ZW1TaXplKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVhc3VyZW1lbnQgc2FtcGxlIGZvciB0aGUgZXN0aW1hdG9yIHRvIGNvbnNpZGVyLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbWVhc3VyZWQgcmFuZ2UuXG4gICAgICogQHBhcmFtIHNpemUgVGhlIG1lYXN1cmVkIHNpemUgb2YgdGhlIGdpdmVuIHJhbmdlIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBhZGRTYW1wbGUocmFuZ2U6IExpc3RSYW5nZSwgc2l6ZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKiogUmVzZXRzIHRoZSBhdmVyYWdlci4gKi9cbiAgICByZXNldCgpOiB2b2lkO1xufVxuLyoqIFZpcnR1YWwgc2Nyb2xsaW5nIHN0cmF0ZWd5IGZvciBsaXN0cyB3aXRoIGl0ZW1zIG9mIHVua25vd24gb3IgZHluYW1pYyBzaXplLiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQXV0b1NpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kgaW1wbGVtZW50cyBWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kge1xuICAgIC8qKiBAZG9jcy1wcml2YXRlIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgVmlydHVhbFNjcm9sbFN0cmF0ZWd5LiAqL1xuICAgIHNjcm9sbGVkSW5kZXhDaGFuZ2U6IE9ic2VydmFibGU8bnVtYmVyPjtcbiAgICAvKiogVGhlIGF0dGFjaGVkIHZpZXdwb3J0LiAqL1xuICAgIHByaXZhdGUgX3ZpZXdwb3J0O1xuICAgIC8qKiBUaGUgbWluaW11bSBhbW91bnQgb2YgYnVmZmVyIHJlbmRlcmVkIGJleW9uZCB0aGUgdmlld3BvcnQgKGluIHBpeGVscykuICovXG4gICAgcHJpdmF0ZSBfbWluQnVmZmVyUHg7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgYnVmZmVyIGl0ZW1zIHRvIHJlbmRlciBiZXlvbmQgdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IChpbiBwaXhlbHMpLiAqL1xuICAgIHByaXZhdGUgX21heEJ1ZmZlclB4O1xuICAgIC8qKiBUaGUgZXN0aW1hdG9yIHVzZWQgdG8gZXN0aW1hdGUgdGhlIHNpemUgb2YgdW5zZWVuIGl0ZW1zLiAqL1xuICAgIHByaXZhdGUgX2F2ZXJhZ2VyO1xuICAgIC8qKiBUaGUgbGFzdCBtZWFzdXJlZCBzY3JvbGwgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBwcml2YXRlIF9sYXN0U2Nyb2xsT2Zmc2V0O1xuICAgIC8qKiBUaGUgbGFzdCBtZWFzdXJlZCBzaXplIG9mIHRoZSByZW5kZXJlZCBjb250ZW50IGluIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBwcml2YXRlIF9sYXN0UmVuZGVyZWRDb250ZW50U2l6ZTtcbiAgICAvKiogVGhlIGxhc3QgbWVhc3VyZWQgc2l6ZSBvZiB0aGUgcmVuZGVyZWQgY29udGVudCBpbiB0aGUgdmlld3BvcnQuICovXG4gICAgcHJpdmF0ZSBfbGFzdFJlbmRlcmVkQ29udGVudE9mZnNldDtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGN5Y2xlcyB3aGVyZSByZW1vdmluZyBleHRyYSBpdGVtcyBoYXMgZmFpbGVkLiBGYWlsdXJlIGhlcmUgbWVhbnMgdGhhdFxuICAgICAqIHdlIGVzdGltYXRlZCBob3cgbWFueSBpdGVtcyB3ZSBjb3VsZCBzYWZlbHkgcmVtb3ZlLCBidXQgb3VyIGVzdGltYXRlIHR1cm5lZCBvdXQgdG8gYmUgdG9vIG11Y2hcbiAgICAgKiBhbmQgaXQgd2Fzbid0IHNhZmUgdG8gcmVtb3ZlIHRoYXQgbWFueSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9yZW1vdmFsRmFpbHVyZXM7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1pbkJ1ZmZlclB4IFRoZSBtaW5pbXVtIGFtb3VudCBvZiBidWZmZXIgcmVuZGVyZWQgYmV5b25kIHRoZSB2aWV3cG9ydCAoaW4gcGl4ZWxzKS5cbiAgICAgKiAgICAgSWYgdGhlIGFtb3VudCBvZiBidWZmZXIgZGlwcyBiZWxvdyB0aGlzIG51bWJlciwgbW9yZSBpdGVtcyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBtYXhCdWZmZXJQeCBUaGUgbnVtYmVyIG9mIHBpeGVscyB3b3J0aCBvZiBidWZmZXIgdG8gc2hvb3QgZm9yIHdoZW4gcmVuZGVyaW5nIG5ldyBpdGVtcy5cbiAgICAgKiAgICAgSWYgdGhlIGFjdHVhbCBhbW91bnQgdHVybnMgb3V0IHRvIGJlIGxlc3MgaXQgd2lsbCBub3QgbmVjZXNzYXJpbHkgdHJpZ2dlciBhbiBhZGRpdGlvbmFsXG4gICAgICogICAgIHJlbmRlcmluZyBjeWNsZSAoYXMgbG9uZyBhcyB0aGUgYW1vdW50IG9mIGJ1ZmZlciBpcyBzdGlsbCBncmVhdGVyIHRoYW4gYG1pbkJ1ZmZlclB4YCkuXG4gICAgICogQHBhcmFtIGF2ZXJhZ2VyIFRoZSBhdmVyYWdlciB1c2VkIHRvIGVzdGltYXRlIHRoZSBzaXplIG9mIHVuc2VlbiBpdGVtcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtaW5CdWZmZXJQeDogbnVtYmVyLCBtYXhCdWZmZXJQeDogbnVtYmVyLCBhdmVyYWdlcj86IEl0ZW1TaXplQXZlcmFnZXIpO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoaXMgc2Nyb2xsIHN0cmF0ZWd5IHRvIGEgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydCB0byBhdHRhY2ggdGhpcyBzdHJhdGVneSB0by5cbiAgICAgKi9cbiAgICBhdHRhY2godmlld3BvcnQ6IENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCk6IHZvaWQ7XG4gICAgLyoqIERldGFjaGVzIHRoaXMgc2Nyb2xsIHN0cmF0ZWd5IGZyb20gdGhlIGN1cnJlbnRseSBhdHRhY2hlZCB2aWV3cG9ydC4gKi9cbiAgICBkZXRhY2goKTogdm9pZDtcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIFZpcnR1YWxTY3JvbGxTdHJhdGVneS4gKi9cbiAgICBvbkNvbnRlbnRTY3JvbGxlZCgpOiB2b2lkO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgVmlydHVhbFNjcm9sbFN0cmF0ZWd5LiAqL1xuICAgIG9uRGF0YUxlbmd0aENoYW5nZWQoKTogdm9pZDtcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIFZpcnR1YWxTY3JvbGxTdHJhdGVneS4gKi9cbiAgICBvbkNvbnRlbnRSZW5kZXJlZCgpOiB2b2lkO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgVmlydHVhbFNjcm9sbFN0cmF0ZWd5LiAqL1xuICAgIG9uUmVuZGVyZWRPZmZzZXRDaGFuZ2VkKCk6IHZvaWQ7XG4gICAgLyoqIFNjcm9sbCB0byB0aGUgb2Zmc2V0IGZvciB0aGUgZ2l2ZW4gaW5kZXguICovXG4gICAgc2Nyb2xsVG9JbmRleCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYnVmZmVyIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG1pbkJ1ZmZlclB4IFRoZSBtaW5pbXVtIGFtb3VudCBvZiBidWZmZXIgcmVuZGVyZWQgYmV5b25kIHRoZSB2aWV3cG9ydCAoaW4gcGl4ZWxzKS5cbiAgICAgKiBAcGFyYW0gbWF4QnVmZmVyUHggVGhlIG51bWJlciBvZiBidWZmZXIgaXRlbXMgdG8gcmVuZGVyIGJleW9uZCB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnQgKGluXG4gICAgICogICAgIHBpeGVscykuXG4gICAgICovXG4gICAgdXBkYXRlQnVmZmVyU2l6ZShtaW5CdWZmZXJQeDogbnVtYmVyLCBtYXhCdWZmZXJQeDogbnVtYmVyKTogdm9pZDtcbiAgICAvKiogVXBkYXRlIHRoZSByZW5kZXJlZCBjb250ZW50IGFmdGVyIHRoZSB1c2VyIHNjcm9sbHMuICovXG4gICAgcHJpdmF0ZSBfdXBkYXRlUmVuZGVyZWRDb250ZW50QWZ0ZXJTY3JvbGw7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgY29udGVudCBhbmQgdXNlcyBpdCB0byB1cGRhdGUgdGhlIGVzdGltYXRlZCBpdGVtIHNpemVcbiAgICAgKiBhbmQgZXN0aW1hdGVkIHRvdGFsIGNvbnRlbnQgc2l6ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jaGVja1JlbmRlcmVkQ29udGVudFNpemU7XG4gICAgLyoqIENoZWNrcyB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGNvbnRlbnQgb2Zmc2V0IGFuZCBzYXZlcyB0aGUgdmFsdWUgZm9yIGxhdGVyIHVzZS4gKi9cbiAgICBwcml2YXRlIF9jaGVja1JlbmRlcmVkQ29udGVudE9mZnNldDtcbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIHJlbmRlcmVkIGNvbnRlbnQgYmFzZWQgb24gb3VyIGVzdGltYXRlIG9mIHdoYXQgc2hvdWxkIGJlIHNob3duIGF0IHRoZSBjdXJyZW50XG4gICAgICogc2Nyb2xsIG9mZnNldC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9yZW5kZXJDb250ZW50Rm9yQ3VycmVudE9mZnNldDtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aXNpYmxlIHJhbmdlIG9mIGRhdGEgZm9yIHRoZSBnaXZlbiBzdGFydCBpbmRleC4gSWYgdGhlIHN0YXJ0IGluZGV4IGlzIHRvbyBjbG9zZSB0b1xuICAgICAqIHRoZSBlbmQgb2YgdGhlIGxpc3QgaXQgbWF5IGJlIGJhY2tlZCB1cCB0byBlbnN1cmUgdGhlIGVzdGltYXRlZCBzaXplIG9mIHRoZSByYW5nZSBpcyBlbm91Z2ggdG9cbiAgICAgKiBmaWxsIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBOb3RlOiBtdXN0IG5vdCBiZSBjYWxsZWQgaWYgYHRoaXMuX3ZpZXdwb3J0YCBpcyBudWxsXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSByYW5nZSBhdFxuICAgICAqIEByZXR1cm4gYSByYW5nZSBlc3RpbWF0ZWQgdG8gYmUgbGFyZ2UgZW5vdWdoIHRvIGZpbGwgdGhlIHZpZXdwb3J0IHdoZW4gcmVuZGVyZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0VmlzaWJsZVJhbmdlRm9ySW5kZXg7XG4gICAgLyoqXG4gICAgICogRXhwYW5kIHRoZSBnaXZlbiByYW5nZSBieSB0aGUgZ2l2ZW4gYW1vdW50IGluIGVpdGhlciBkaXJlY3Rpb24uXG4gICAgICogTm90ZTogbXVzdCBub3QgYmUgY2FsbGVkIGlmIGB0aGlzLl92aWV3cG9ydGAgaXMgbnVsbFxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gZXhwYW5kXG4gICAgICogQHBhcmFtIGV4cGFuZFN0YXJ0IFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gZXhwYW5kIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgYnkuXG4gICAgICogQHBhcmFtIGV4cGFuZEVuZCBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGV4cGFuZCB0aGUgZW5kIG9mIHRoZSByYW5nZSBieS5cbiAgICAgKiBAcmV0dXJuIFRoZSBleHBhbmRlZCByYW5nZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9leHBhbmRSYW5nZTtcbiAgICAvKiogVXBkYXRlIHRoZSB2aWV3cG9ydCdzIHRvdGFsIGNvbnRlbnQgc2l6ZS4gKi9cbiAgICBwcml2YXRlIF91cGRhdGVUb3RhbENvbnRlbnRTaXplO1xufVxuLyoqXG4gKiBQcm92aWRlciBmYWN0b3J5IGZvciBgQXV0b1NpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3lgIHRoYXQgc2ltcGx5IGV4dHJhY3RzIHRoZSBhbHJlYWR5IGNyZWF0ZWRcbiAqIGBBdXRvU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAgZnJvbSB0aGUgZ2l2ZW4gZGlyZWN0aXZlLlxuICogQHBhcmFtIGF1dG9TaXplRGlyIFRoZSBpbnN0YW5jZSBvZiBgQ2RrQXV0b1NpemVWaXJ0dWFsU2Nyb2xsYCB0byBleHRyYWN0IHRoZVxuICogICAgIGBBdXRvU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAgZnJvbS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gX2F1dG9TaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5RmFjdG9yeShhdXRvU2l6ZURpcjogQ2RrQXV0b1NpemVWaXJ0dWFsU2Nyb2xsKTogQXV0b1NpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3k7XG4vKiogQSB2aXJ0dWFsIHNjcm9sbCBzdHJhdGVneSB0aGF0IHN1cHBvcnRzIHVua25vd24gb3IgZHluYW1pYyBzaXplIGl0ZW1zLiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ2RrQXV0b1NpemVWaXJ0dWFsU2Nyb2xsIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBhbW91bnQgb2YgYnVmZmVyIHJlbmRlcmVkIGJleW9uZCB0aGUgdmlld3BvcnQgKGluIHBpeGVscykuXG4gICAgICogSWYgdGhlIGFtb3VudCBvZiBidWZmZXIgZGlwcyBiZWxvdyB0aGlzIG51bWJlciwgbW9yZSBpdGVtcyB3aWxsIGJlIHJlbmRlcmVkLiBEZWZhdWx0cyB0byAxMDBweC5cbiAgICAgKi9cbiAgICBnZXQgbWluQnVmZmVyUHgoKTogbnVtYmVyO1xuICAgIHNldCBtaW5CdWZmZXJQeCh2YWx1ZTogbnVtYmVyKTtcbiAgICBfbWluQnVmZmVyUHg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBpeGVscyB3b3J0aCBvZiBidWZmZXIgdG8gc2hvb3QgZm9yIHdoZW4gcmVuZGVyaW5nIG5ldyBpdGVtcy5cbiAgICAgKiBJZiB0aGUgYWN0dWFsIGFtb3VudCB0dXJucyBvdXQgdG8gYmUgbGVzcyBpdCB3aWxsIG5vdCBuZWNlc3NhcmlseSB0cmlnZ2VyIGFuIGFkZGl0aW9uYWxcbiAgICAgKiByZW5kZXJpbmcgY3ljbGUgKGFzIGxvbmcgYXMgdGhlIGFtb3VudCBvZiBidWZmZXIgaXMgc3RpbGwgZ3JlYXRlciB0aGFuIGBtaW5CdWZmZXJQeGApLlxuICAgICAqIERlZmF1bHRzIHRvIDIwMHB4LlxuICAgICAqL1xuICAgIGdldCBtYXhCdWZmZXJQeCgpOiBudW1iZXI7XG4gICAgc2V0IG1heEJ1ZmZlclB4KHZhbHVlOiBudW1iZXIpO1xuICAgIF9tYXhCdWZmZXJQeDogbnVtYmVyO1xuICAgIC8qKiBUaGUgc2Nyb2xsIHN0cmF0ZWd5IHVzZWQgYnkgdGhpcyBkaXJlY3RpdmUuICovXG4gICAgX3Njcm9sbFN0cmF0ZWd5OiBBdXRvU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneTtcbiAgICBuZ09uQ2hhbmdlcygpOiB2b2lkO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9taW5CdWZmZXJQeDogTnVtYmVySW5wdXQ7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX21heEJ1ZmZlclB4OiBOdW1iZXJJbnB1dDtcbn1cbiJdfQ==